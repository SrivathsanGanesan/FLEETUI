/* eslint-disable */
import { Injectable, Directive, ElementRef, NgZone, Input as Input$1, Output, ViewContainerRef, EventEmitter, NgModule, ViewChild, Optional, Component, ChangeDetectionStrategy, ChangeDetectorRef, ViewChildren } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NgControl, FormsModule } from '@angular/forms';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var mobiscroll = mobiscroll || {},
    util = {};

var os,
    vers,
    majorVersion,
    minorVersion,
    version = [],
    isBrowser = typeof window !== 'undefined',
    isDark = isBrowser && window.matchMedia && window.matchMedia('(prefers-color-scheme:dark)').matches,
    userAgent = isBrowser ? navigator.userAgent : '',
    platform = isBrowser ? navigator.platform : '',
    maxTouchPoints = isBrowser ? navigator.maxTouchPoints : 0,
    isSafari = /Safari/.test(userAgent),
    device = userAgent.match(/Android|iPhone|iPad|iPod|Windows Phone|Windows|MSIE/i),
    raf = isBrowser && window.requestAnimationFrame || function (func) {
  return setTimeout(func, 20);
};

if (/Android/i.test(device)) {
  os = 'android';
  vers = userAgent.match(/Android\s+([\d.]+)/i);

  if (vers) {
    version = vers[0].replace('Android ', '').split('.');
  }
} else if (/iPhone|iPad|iPod/i.test(device) || /iPhone|iPad|iPod/i.test(platform) || platform === 'MacIntel' && maxTouchPoints > 1) {
  // On iPad with iOS 13 desktop site request is automatically enabled in Safari,
  // so 'iPad' is no longer present in the user agent string.
  // In this case we check `navigator.platform` and `navigator.maxTouchPoints`.
  // maxTouchPoints is needed to exclude desktop Mac OS X.
  os = 'ios';
  vers = userAgent.match(/OS\s+([\d_]+)/i);

  if (vers) {
    version = vers[0].replace(/_/g, '.').replace('OS ', '').split('.');
  }
} else if (/Windows Phone/i.test(device)) {
  os = 'wp';
} else if (/Windows|MSIE/i.test(device)) {
  os = 'windows';
}

majorVersion = version[0];
minorVersion = version[1];

function testProps(props) {
  var i;

  for (i in props) {
    if (mod[props[i]] !== undefined) {
      return true;
    }
  }

  return false;
}

function testPrefix() {
  var prefixes = ['Webkit', 'Moz', 'O', 'ms'],
      p;

  for (p in prefixes) {
    if (testProps([prefixes[p] + 'Transform'])) {
      return '-' + prefixes[p].toLowerCase() + '-';
    }
  }

  return '';
}

function testTouch(e, elm) {
  if (e.type == 'touchstart') {
    elm.__mbscTouched = 1;
  } else if (elm.__mbscTouched) {
    delete elm.__mbscTouched;
    return false;
  }

  return true;
}

function listen(el, event, handler, opt) {
  if (el) {
    el.addEventListener(event, handler, opt);
  }
}

function unlisten(el, event, handler, opt) {
  if (el) {
    el.removeEventListener(event, handler, opt);
  }
}

function matches(element, selector) {
  if (!selector || !element || element.nodeType !== 1) {
    return false;
  }

  var matchesSelector = element.matches || element.matchesSelector || element.webkitMatchesSelector || element.mozMatchesSelector || element.msMatchesSelector;
  return matchesSelector.call(element, selector);
}

function closest(el, target, selector) {
  while (target) {
    if (matches(target, selector)) {
      return target;
    }

    target = target !== el ? target.parentNode : null;
  }

  return null;
}

function trigger(elm, name, data) {
  var evt;

  try {
    evt = new CustomEvent(name, {
      detail: data,
      bubbles: true,
      cancelable: true
    });
  } catch (e) {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
    evt.detail = data;
  }

  elm.dispatchEvent(evt);
}

var animEnd,
    canvas,
    mod,
    cssPrefix,
    hasGhostClick,
    hasTransition,
    isWebView,
    isWkWebView,
    jsPrefix,
    win;

if (isBrowser) {
  win = window;
  canvas = document.createElement('canvas');
  mod = document.createElement('modernizr').style;
  cssPrefix = testPrefix();
  jsPrefix = cssPrefix.replace(/^-/, '').replace(/-$/, '').replace('moz', 'Moz');
  animEnd = mod.animation !== undefined ? 'animationend' : 'webkitAnimationEnd';
  hasTransition = mod.transition !== undefined; // UIWebView on iOS still has the ghost click, 
  // WkWebView does not have a ghost click, but it's hard to tell if it's UIWebView or WkWebView
  // In addition in iOS 12.2 if we enable tap handling, it brakes the form inputs
  // (keyboard appears, but the cursor is not in the input).

  isWebView = os === 'ios' && !isSafari;
  isWkWebView = isWebView && win.webkit && win.webkit.messageHandlers;
  hasGhostClick = mod.touchAction === undefined || isWebView && !isWkWebView;
}

var cssNumber = {
  'column-count': 1,
  'columns': 1,
  'font-weight': 1,
  'line-height': 1,
  'opacity': 1,
  'z-index': 1,
  'zoom': 1
},
    propMap = {
  'readonly': 'readOnly'
},
    emptyArray = [],
    _slice = Array.prototype.slice;

function isFunction(value) {
  return typeof value === "function";
}

function isObject(obj) {
  return typeof obj === "object";
}

function likeArray(obj) {
  return typeof obj.length == 'number';
}

function camelize(str) {
  return str.replace(/-+(.)?/g, function (match, chr) {
    return chr ? chr.toUpperCase() : '';
  });
}

function extend(target, source, deep) {
  for (var key in source) {
    if (deep && ($.isPlainObject(source[key]) || $.isArray(source[key]))) {
      if ($.isPlainObject(source[key]) && !$.isPlainObject(target[key]) || $.isArray(source[key]) && !$.isArray(target[key])) {
        target[key] = {};
      }

      extend(target[key], source[key], deep);
    } else if (source[key] !== undefined) {
      target[key] = source[key];
    }
  }
}

function dasherize(str) {
  return str.replace(/::/g, '/').replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z\d])([A-Z])/g, '$1_$2').replace(/_/g, '-').toLowerCase();
}

function maybeAddPx(name, value) {
  return typeof value == "number" && !cssNumber[dasherize(name)] ? value + "px" : value;
}

var Dom = function () {
  var Dom = function Dom(arr) {
    var _this = this,
        i = 0; // Create array-like object


    for (i = 0; i < arr.length; i++) {
      _this[i] = arr[i];
    }

    _this.length = arr.length; // Return collection with methods

    return $(this);
  };

  var $ = function $(selector, context) {
    var arr = [],
        i = 0;

    if (selector && !context) {
      if (selector instanceof Dom) {
        return selector;
      }
    }

    if (isFunction(selector)) {
      return $(document).ready(selector);
    }

    if (selector) {
      // String
      if (typeof selector === 'string') {
        var els, tempParent, html;
        selector = html = selector.trim();

        if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
          var toCreate = 'div';

          if (html.indexOf('<li') === 0) {
            toCreate = 'ul';
          }

          if (html.indexOf('<tr') === 0) {
            toCreate = 'tbody';
          }

          if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) {
            toCreate = 'tr';
          }

          if (html.indexOf('<tbody') === 0) {
            toCreate = 'table';
          }

          if (html.indexOf('<option') === 0) {
            toCreate = 'select';
          }

          tempParent = document.createElement(toCreate);
          tempParent.innerHTML = html;

          for (i = 0; i < tempParent.childNodes.length; i++) {
            arr.push(tempParent.childNodes[i]);
          }
        } else {
          if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
            // Pure ID selector
            els = [document.getElementById(selector.split('#')[1])];
          } else {
            if (context instanceof Dom) {
              context = context[0];
            } // Other selectors


            els = (context || document).querySelectorAll(selector);
          }

          for (i = 0; i < els.length; i++) {
            if (els[i]) {
              arr.push(els[i]);
            }
          }
        }
      } // Node/element
      else if (selector.nodeType || selector === window || selector === document) {
          arr.push(selector);
        } //Array of elements or instance of Dom
        else if (selector.length > 0 && selector[0].nodeType) {
            for (i = 0; i < selector.length; i++) {
              arr.push(selector[i]);
            }
          } else if ($.isArray(selector)) {
            arr = selector;
          }
    }

    return new Dom(arr);
  };

  Dom.prototype = {
    ready: function ready(callback) {
      if (document.attachEvent ? document.readyState == 'complete' : document.readyState != 'loading') {
        callback($);
      } else {
        document.addEventListener('DOMContentLoaded', function () {
          callback($);
        }, false);
      }

      return this;
    },
    concat: emptyArray.concat,
    empty: function empty() {
      return this.each(function () {
        this.innerHTML = '';
      });
    },
    map: function map(fn) {
      return $($.map(this, function (el, i) {
        return fn.call(el, i, el);
      }));
    },
    slice: function slice() {
      return $(_slice.apply(this, arguments));
    },
    // Classes and attriutes
    // NOTE: element.classList attribure is not supported on android 2.3!!!
    addClass: function addClass(className) {
      if (typeof className === 'undefined') {
        return this;
      }

      var classes = className.split(' ');

      for (var i = 0; i < classes.length; i++) {
        for (var j = 0; j < this.length; j++) {
          if (typeof this[j].classList !== 'undefined' && classes[i] !== '') {
            this[j].classList.add(classes[i]);
          }
        }
      }

      return this;
    },
    removeClass: function removeClass(className) {
      if (typeof className === 'undefined') {
        return this;
      }

      var classes = className.split(' ');

      for (var i = 0; i < classes.length; i++) {
        for (var j = 0; j < this.length; j++) {
          if (typeof this[j].classList !== 'undefined' && classes[i] !== '') {
            this[j].classList.remove(classes[i]);
          }
        }
      }

      return this;
    },
    hasClass: function hasClass(className) {
      return this[0] ? this[0].classList.contains(className) : false;
    },
    toggleClass: function toggleClass(className) {
      var classes = className.split(' ');

      for (var i = 0; i < classes.length; i++) {
        for (var j = 0; j < this.length; j++) {
          if (typeof this[j].classList !== 'undefined') {
            this[j].classList.toggle(classes[i]);
          }
        }
      }

      return this;
    },
    closest: function closest(selector, context) {
      var node = this[0],
          collection = false;

      if (isObject(selector)) {
        collection = $(selector);
      }

      while (node && !(collection ? collection.indexOf(node) >= 0 : matches(node, selector))) {
        node = node !== context && node.nodeType !== node.DOCUMENT_NODE && node.parentNode;
      }

      return $(node);
    },
    attr: function attr(attrs, value) {
      var attr;

      if (arguments.length === 1 && typeof attrs === 'string') {
        // Get attr
        if (this.length) {
          attr = this[0].getAttribute(attrs);
          return attr || attr === '' ? attr : undefined;
        }
      } else {
        // Set attrs
        for (var i = 0; i < this.length; i++) {
          if (arguments.length === 2) {
            // String
            this[i].setAttribute(attrs, value);
          } else {
            // Object
            for (var attrName in attrs) {
              this[i][attrName] = attrs[attrName];
              this[i].setAttribute(attrName, attrs[attrName]);
            }
          }
        }

        return this;
      }
    },
    removeAttr: function removeAttr(attr) {
      for (var i = 0; i < this.length; i++) {
        this[i].removeAttribute(attr);
      }

      return this;
    },
    prop: function prop(props, value) {
      props = propMap[props] || props;

      if (arguments.length === 1 && typeof props === 'string') {
        // Get prop
        return this[0] ? this[0][props] : undefined;
      } else {
        // Set props
        for (var i = 0; i < this.length; i++) {
          this[i][props] = value;
        }

        return this;
      }
    },
    val: function val(value) {
      if (typeof value === 'undefined') {
        if (this.length && this[0].multiple) {
          return $.map(this.find('option:checked'), function (v) {
            return v.value;
          });
        }

        return this[0] ? this[0].value : undefined;
      }

      if (this.length && this[0].multiple) {
        $.each(this[0].options, function () {
          this.selected = value.indexOf(this.value) != -1;
        });
      } else {
        for (var i = 0; i < this.length; i++) {
          this[i].value = value;
        }
      }

      return this;
    },
    //Events
    on: function on(eventName, targetSelector, listener, capture) {
      var boundListener,
          elm,
          event,
          events = eventName.split(' '),
          i,
          j;

      function handleLiveEvent(e) {
        var target = e.target;

        while (target) {
          if ($(target).is(targetSelector)) {
            listener.call(target, e);
          }

          target = target !== this ? target.parentNode : null;
        }
      }

      function handleNamespaces(el, name, listener, capture) {
        var namespace = name.split('.');

        if (!el.DomNameSpaces) {
          el.DomNameSpaces = [];
        }

        el.DomNameSpaces.push({
          namespace: namespace[1],
          event: namespace[0],
          listener: listener,
          capture: capture
        });
        el.addEventListener(namespace[0], listener, capture);
      }

      for (i = 0; i < this.length; i++) {
        elm = this[i];

        if (isFunction(targetSelector) || targetSelector === false) {
          // Usual events
          if (isFunction(targetSelector)) {
            capture = listener || false;
            listener = targetSelector;
          }

          for (j = 0; j < events.length; j++) {
            event = events[j]; // check for namespaces

            if (event.indexOf('.') != -1) {
              handleNamespaces(elm, event, listener, capture);
            } else {
              elm.addEventListener(event, listener, capture);
            }
          }
        } else {
          // Live events
          boundListener = handleLiveEvent.bind(elm);

          for (j = 0; j < events.length; j++) {
            event = events[j];

            if (!elm.DomLiveListeners) {
              elm.DomLiveListeners = [];
            }

            elm.DomLiveListeners.push({
              listener: listener,
              liveListener: boundListener
            });

            if (event.indexOf('.') != -1) {
              handleNamespaces(elm, event, boundListener, capture);
            } else {
              elm.addEventListener(event, boundListener, capture);
            }
          }
        }
      }

      return this;
    },
    off: function off(eventName, targetSelector, listener, capture) {
      var elm,
          event,
          events,
          i,
          j,
          k,
          liveListeners,
          that = this;

      function removeEvents(event) {
        var el,
            i,
            j,
            item,
            nameSpaces,
            parts = event.split('.'),
            name = parts[0],
            ns = parts[1];

        for (i = 0; i < that.length; ++i) {
          el = that[i];
          nameSpaces = el.DomNameSpaces;

          if (nameSpaces) {
            for (j = 0; j < nameSpaces.length; ++j) {
              item = nameSpaces[j];

              if (item.namespace == ns && (item.event == name || !name)) {
                el.removeEventListener(item.event, item.listener, item.capture);
                item.removed = true;
              }
            } // remove the events from the DomNameSpaces array


            for (j = nameSpaces.length - 1; j >= 0; --j) {
              if (nameSpaces[j].removed) {
                nameSpaces.splice(j, 1);
              }
            }
          }
        }
      }

      events = eventName.split(' ');

      for (i = 0; i < events.length; i++) {
        event = events[i];

        for (j = 0; j < this.length; j++) {
          elm = this[j];
          liveListeners = elm.DomLiveListeners;

          if (isFunction(targetSelector) || targetSelector === false) {
            // Usual events
            if (isFunction(targetSelector)) {
              capture = listener || false;
              listener = targetSelector;
            }

            if (event.indexOf('.') === 0) {
              // remove namespace events
              removeEvents(event.substr(1));
            } else {
              elm.removeEventListener(event, listener, capture);
            }
          } else {
            // Live event
            if (liveListeners) {
              for (k = 0; k < liveListeners.length; k++) {
                if (liveListeners[k].listener === listener) {
                  elm.removeEventListener(event, liveListeners[k].liveListener, capture);
                }
              }
            }

            if (elm.DomNameSpaces && elm.DomNameSpaces.length && event) {
              removeEvents(event);
            }
          }
        }
      }

      return this;
    },
    trigger: function trigger$1(eventName, eventData) {
      var events = eventName.split(' ');

      for (var i = 0; i < events.length; i++) {
        for (var j = 0; j < this.length; j++) {
          trigger(this[j], events[i], eventData);
        }
      }

      return this;
    },
    // Sizing/Styles
    width: function width(dim) {
      if (dim !== undefined) {
        return this.css('width', dim);
      }

      if (this[0] === window) {
        return window.innerWidth;
      } else if (this[0] === document) {
        return document.documentElement.scrollWidth;
      } else {
        return this.length > 0 ? parseFloat(this.css('width')) : null;
      }
    },
    height: function height(dim) {
      if (dim !== undefined) {
        return this.css('height', dim);
      }

      if (this[0] === window) {
        return window.innerHeight;
      } else if (this[0] === document) {
        var body = document.body,
            html = document.documentElement;
        return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
      } else {
        return this.length > 0 ? parseFloat(this.css('height')) : null;
      }
    },
    innerWidth: function innerWidth() {
      var elm = this;

      if (this.length > 0) {
        if (this[0].innerWidth) {
          return this[0].innerWidth;
        } else {
          var size = this[0].offsetWidth,
              sides = ['left', 'right'];
          sides.forEach(function (side) {
            size -= parseInt(elm.css(camelize('border-' + side + '-width')) || 0, 10);
          });
          return size;
        }
      }
    },
    innerHeight: function innerHeight() {
      var elm = this;

      if (this.length > 0) {
        if (this[0].innerHeight) {
          return this[0].innerHeight;
        } else {
          var size = this[0].offsetHeight,
              sides = ['top', 'bottom'];
          sides.forEach(function (side) {
            size -= parseInt(elm.css(camelize('border-' + side + '-width')) || 0, 10);
          });
          return size;
        }
      }
    },
    offset: function offset() {
      if (this.length > 0) {
        var el = this[0],
            box = el.getBoundingClientRect(),
            doc = document.documentElement;
        return {
          top: box.top + window.pageYOffset - doc.clientTop,
          left: box.left + window.pageXOffset - doc.clientLeft
        };
      }
    },
    hide: function hide() {
      for (var i = 0; i < this.length; i++) {
        this[i].style.display = 'none';
      }

      return this;
    },
    show: function show() {
      for (var i = 0; i < this.length; i++) {
        if (this[i].style.display == "none") {
          this[i].style.display = '';
        }

        if (getComputedStyle(this[i], '').getPropertyValue("display") == "none") {
          this[i].style.display = 'block';
        }
      }

      return this;
    },
    clone: function clone() {
      return this.map(function () {
        return this.cloneNode(true);
      });
    },
    styles: function styles() {
      return this[0] ? window.getComputedStyle(this[0], null) : undefined;
    },
    css: function css(property, value) {
      var i,
          key,
          element = this[0],
          css = '';

      if (arguments.length < 2) {
        if (!element) {
          return;
        }

        if (typeof property === 'string') {
          return element.style[property] || getComputedStyle(element, '').getPropertyValue(property);
        }
      }

      if (typeof property === 'string') {
        if (!value && value !== 0) {
          this.each(function () {
            this.style.removeProperty(dasherize(property));
          });
        } else {
          css = dasherize(property) + ":" + maybeAddPx(property, value);
        }
      } else {
        for (key in property) {
          if (!property[key] && property[key] !== 0) {
            for (i = 0; i < this.length; i++) {
              this[i].style.removeProperty(dasherize(key));
            }
          } else {
            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';';
          }
        }
      }

      return this.each(function () {
        this.style.cssText += ';' + css;
      });
    },
    each: function each(callback) {
      for (var i = 0; i < this.length; i++) {
        if (callback.apply(this[i], [i, this[i]]) === false) {
          break;
        }
      }

      return this;
    },
    filter: function filter(callback) {
      var matchedItems = [];

      for (var i = 0; i < this.length; i++) {
        if (isFunction(callback)) {
          if (callback.call(this[i], i, this[i])) {
            matchedItems.push(this[i]);
          }
        } else if (matches(this[i], callback)) {
          matchedItems.push(this[i]);
        }
      }

      return new Dom(matchedItems);
    },
    html: function html(_html) {
      if (typeof _html === 'undefined') {
        return this[0] ? this[0].innerHTML : undefined;
      } else {
        this.empty();

        for (var i = 0; i < this.length; i++) {
          this[i].innerHTML = _html;
        }

        return this;
      }
    },
    text: function text(_text) {
      if (typeof _text === 'undefined') {
        return this[0] ? this[0].textContent.trim() : null;
      } else {
        for (var i = 0; i < this.length; i++) {
          this[i].textContent = _text;
        }

        return this;
      }
    },
    is: function is(selector) {
      return this.length > 0 && matches(this[0], selector);
    },
    not: function not(selector) {
      var nodes = [];

      if (isFunction(selector) && selector.call !== undefined) {
        this.each(function (idx) {
          if (!selector.call(this, idx)) {
            nodes.push(this);
          }
        });
      } else {
        var excludes = typeof selector == 'string' ? this.filter(selector) : likeArray(selector) && isFunction(selector.item) ? _slice.call(selector) : $(selector);

        if (isObject(excludes)) {
          excludes = $.map(excludes, function (el) {
            return el;
          });
        }

        this.each(function (i, el) {
          if (excludes.indexOf(el) < 0) {
            nodes.push(el);
          }
        });
      }

      return $(nodes);
    },
    indexOf: function indexOf(el) {
      for (var i = 0; i < this.length; i++) {
        if (this[i] === el) {
          return i;
        }
      }
    },
    index: function index(element) {
      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0]);
    },
    get: function get(idx) {
      return idx === undefined ? _slice.call(this) : this[idx >= 0 ? idx : idx + this.length];
    },
    eq: function eq(index) {
      if (typeof index === 'undefined') {
        return this;
      }

      var length = this.length,
          returnIndex;

      if (index > length - 1) {
        return new Dom([]);
      }

      if (index < 0) {
        returnIndex = length + index;
        return returnIndex < 0 ? new Dom([]) : new Dom([this[returnIndex]]);
      }

      return new Dom([this[index]]);
    },
    append: function append(newChild) {
      var i, j;

      for (i = 0; i < this.length; i++) {
        if (typeof newChild === 'string') {
          var tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;

          while (tempDiv.firstChild) {
            this[i].appendChild(tempDiv.firstChild);
          }
        } else if (newChild instanceof Dom) {
          for (j = 0; j < newChild.length; j++) {
            this[i].appendChild(newChild[j]);
          }
        } else {
          this[i].appendChild(newChild);
        }
      }

      return this;
    },
    appendTo: function appendTo(parent) {
      $(parent).append(this);
      return this;
    },
    prepend: function prepend(newChild) {
      var i, j;

      for (i = 0; i < this.length; i++) {
        if (typeof newChild === 'string') {
          var tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;

          for (j = tempDiv.childNodes.length - 1; j >= 0; j--) {
            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
          } // this[i].insertAdjacentHTML('afterbegin', newChild);

        } else if (newChild instanceof Dom) {
          for (j = 0; j < newChild.length; j++) {
            this[i].insertBefore(newChild[j], this[i].childNodes[0]);
          }
        } else {
          this[i].insertBefore(newChild, this[i].childNodes[0]);
        }
      }

      return this;
    },
    prependTo: function prependTo(parent) {
      $(parent).prepend(this);
      return this;
    },
    insertBefore: function insertBefore(selector) {
      var before = $(selector);

      for (var i = 0; i < this.length; i++) {
        if (before.length === 1) {
          before[0].parentNode.insertBefore(this[i], before[0]);
        } else if (before.length > 1) {
          for (var j = 0; j < before.length; j++) {
            before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
          }
        }
      }

      return this;
    },
    insertAfter: function insertAfter(selector) {
      var after = $(selector);

      for (var i = 0; i < this.length; i++) {
        if (after.length === 1) {
          after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
        } else if (after.length > 1) {
          for (var j = 0; j < after.length; j++) {
            after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
          }
        }
      }

      return this;
    },
    next: function next(selector) {
      if (this.length > 0) {
        if (selector) {
          if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
            return new Dom([this[0].nextElementSibling]);
          } else {
            return new Dom([]);
          }
        } else {
          if (this[0].nextElementSibling) {
            return new Dom([this[0].nextElementSibling]);
          } else {
            return new Dom([]);
          }
        }
      } else {
        return new Dom([]);
      }
    },
    nextAll: function nextAll(selector) {
      var nextEls = [],
          el = this[0];

      if (!el) {
        return new Dom([]);
      }

      while (el.nextElementSibling) {
        var next = el.nextElementSibling;

        if (selector) {
          if ($(next).is(selector)) {
            nextEls.push(next);
          }
        } else {
          nextEls.push(next);
        }

        el = next;
      }

      return new Dom(nextEls);
    },
    prev: function prev(selector) {
      if (this.length > 0) {
        if (selector) {
          if (this[0].previousElementSibling && $(this[0].previousElementSibling).is(selector)) {
            return new Dom([this[0].previousElementSibling]);
          } else {
            return new Dom([]);
          }
        } else {
          if (this[0].previousElementSibling) {
            return new Dom([this[0].previousElementSibling]);
          } else {
            return new Dom([]);
          }
        }
      } else {
        return new Dom([]);
      }
    },
    prevAll: function prevAll(selector) {
      var prevEls = [];
      var el = this[0];

      if (!el) {
        return new Dom([]);
      }

      while (el.previousElementSibling) {
        var prev = el.previousElementSibling;

        if (selector) {
          if ($(prev).is(selector)) {
            prevEls.push(prev);
          }
        } else {
          prevEls.push(prev);
        }

        el = prev;
      }

      return new Dom(prevEls);
    },
    parent: function parent(selector) {
      var parents = [];

      for (var i = 0; i < this.length; i++) {
        if (this[i].parentNode !== null) {
          if (selector) {
            if ($(this[i].parentNode).is(selector)) {
              parents.push(this[i].parentNode);
            }
          } else {
            parents.push(this[i].parentNode);
          }
        }
      }

      return $($.unique(parents));
    },
    parents: function parents(selector) {
      var parents = [];

      for (var i = 0; i < this.length; i++) {
        var parent = this[i].parentNode;

        while (parent) {
          if (selector) {
            if ($(parent).is(selector)) {
              parents.push(parent);
            }
          } else {
            parents.push(parent);
          }

          parent = parent.parentNode;
        }
      }

      return $($.unique(parents));
    },
    find: function find(selector) {
      var foundElements = [];

      for (var i = 0; i < this.length; i++) {
        var found = this[i].querySelectorAll(selector);

        for (var j = 0; j < found.length; j++) {
          foundElements.push(found[j]);
        }
      }

      return new Dom(foundElements);
    },
    children: function children(selector) {
      var children = [];

      for (var i = 0; i < this.length; i++) {
        var childNodes = this[i].childNodes;

        for (var j = 0; j < childNodes.length; j++) {
          if (!selector) {
            if (childNodes[j].nodeType === 1) {
              children.push(childNodes[j]);
            }
          } else {
            if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
              children.push(childNodes[j]);
            }
          }
        }
      }

      return new Dom($.unique(children));
    },
    remove: function remove() {
      for (var i = 0; i < this.length; i++) {
        if (this[i].parentNode) {
          this[i].parentNode.removeChild(this[i]);
        }
      }

      return this;
    },
    add: function add() {
      var dom = this;
      var i, j;

      for (i = 0; i < arguments.length; i++) {
        var toAdd = $(arguments[i]);

        for (j = 0; j < toAdd.length; j++) {
          dom[dom.length] = toAdd[j];
          dom.length++;
        }
      }

      return dom;
    },
    before: function before(elm) {
      $(elm).insertBefore(this);
      return this;
    },
    after: function after(elm) {
      $(elm).insertAfter(this);
      return this;
    },
    scrollTop: function scrollTop(value) {
      if (!this.length) {
        return;
      }

      var hasScrollTop = 'scrollTop' in this[0];

      if (value === undefined) {
        return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset;
      }

      return this.each(hasScrollTop ? function () {
        this.scrollTop = value;
      } : function () {
        this.scrollTo(this.scrollX, value);
      });
    },
    scrollLeft: function scrollLeft(value) {
      if (!this.length) {
        return;
      }

      var hasScrollLeft = 'scrollLeft' in this[0];

      if (value === undefined) {
        return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset;
      }

      return this.each(hasScrollLeft ? function () {
        this.scrollLeft = value;
      } : function () {
        this.scrollTo(value, this.scrollY);
      });
    },
    contents: function contents() {
      return this.map(function (i, v) {
        return _slice.call(v.childNodes);
      });
    },
    nextUntil: function nextUntil(selector) {
      var n = this,
          array = [];

      while (n.length && !n.filter(selector).length) {
        array.push(n[0]);
        n = n.next();
      }

      return $(array);
    },
    prevUntil: function prevUntil(selector) {
      var n = this,
          array = [];

      while (n.length && !$(n).filter(selector).length) {
        array.push(n[0]);
        n = n.prev();
      }

      return $(array);
    },
    detach: function detach() {
      return this.remove();
    }
  }; // Link to prototype

  $.fn = Dom.prototype;
  return $;
}(); // Export to local scope


var $ = Dom; // Export to mobiscroll

mobiscroll.$ = Dom; // DOM Library Utilites

$.inArray = function (elem, array, i) {
  return emptyArray.indexOf.call(array, elem, i);
};

$.extend = function (target) {
  var deep,
      args = _slice.call(arguments, 1);

  if (typeof target == 'boolean') {
    deep = target;
    target = args.shift();
  }

  target = target || {};
  args.forEach(function (arg) {
    extend(target, arg, deep);
  });
  return target;
};

$.isFunction = isFunction;

$.isArray = function (arr) {
  return Object.prototype.toString.apply(arr) === '[object Array]';
};

$.isPlainObject = function (obj) {
  return isObject(obj) && obj !== null && obj !== obj.window && Object.getPrototypeOf(obj) == Object.prototype;
};

$.each = function (obj, callback) {
  var i, prop;

  if (!isObject(obj) || !callback) {
    return;
  }

  if ($.isArray(obj) || obj instanceof Dom) {
    // Array
    for (i = 0; i < obj.length; i++) {
      if (callback.call(obj[i], i, obj[i]) === false) {
        break;
      }
    }
  } else {
    // Object
    for (prop in obj) {
      // eslint-disable-next-line no-prototype-builtins
      if (obj.hasOwnProperty(prop) && prop !== 'length') {
        if (callback.call(obj[prop], prop, obj[prop]) === false) {
          break;
        }
      }
    }
  }

  return this;
};

$.unique = function (arr) {
  var unique = [];

  for (var i = 0; i < arr.length; i++) {
    if (unique.indexOf(arr[i]) === -1) {
      unique.push(arr[i]);
    }
  }

  return unique;
};

$.map = function (elements, callback) {
  var value,
      values = [],
      i,
      key;

  if (likeArray(elements)) {
    for (i = 0; i < elements.length; i++) {
      value = callback(elements[i], i);

      if (value !== null) {
        values.push(value);
      }
    }
  } else {
    for (key in elements) {
      value = callback(elements[key], key);

      if (value !== null) {
        values.push(value);
      }
    }
  }

  return values.length > 0 ? $.fn.concat.apply([], values) : values;
};

function noop() {}

function isString(s) {
  return typeof s === 'string';
}

function constrain(val, min, max) {
  return Math.max(min, Math.min(val, max));
}

function vibrate(time) {
  if ('vibrate' in navigator) {
    navigator.vibrate(time || 50);
  }
}

function getPercent(v, min, max) {
  return (v - min) * 100 / (max - min);
}

function getBoolAttr(attr, def, $elm) {
  var v = $elm.attr(attr);
  return v === undefined || v === '' ? def : v === 'true';
}

var tapped = 0;
var allowQuick;

function preventClick() {
  // Prevent ghost click
  tapped++;
  setTimeout(function () {
    tapped--;
  }, 500);
}

function triggerClick(ev, control) {
  // Prevent duplicate triggers on the same element
  // e.g. a form checkbox inside a listview item
  if (control.mbscClick) {
    return;
  }

  var touch = (ev.originalEvent || ev).changedTouches[0],
      evt = document.createEvent('MouseEvents');
  evt.initMouseEvent('click', true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
  evt.isMbscTap = true; // Prevent ionic to bust our click
  // This works for Ionic 1 - 3, not sure about 4

  evt.isIonicTap = true; // This will allow a click fired together with this click
  // We need this, because clicking on a label will trigger a click
  // on the associated input as well, which should not be busted

  allowQuick = true;
  control.mbscChange = true;
  control.mbscClick = true;
  control.dispatchEvent(evt);
  allowQuick = false; // Prevent ghost click

  preventClick();
  setTimeout(function () {
    delete control.mbscClick;
  });
}

function getCoord(e, c, page) {
  var ev = e.originalEvent || e,
      prop = (page ? 'page' : 'client') + c; // Multi touch support

  if (ev.targetTouches && ev.targetTouches[0]) {
    return ev.targetTouches[0][prop];
  }

  if (ev.changedTouches && ev.changedTouches[0]) {
    return ev.changedTouches[0][prop];
  }

  return e[prop];
}

function getControlType($elm) {
  var attrs = ['switch', 'range', 'rating', 'segmented', 'stepper'];
  var elm = $elm[0];
  var role = $elm.attr('data-role');
  var type = $elm.attr('type') || elm.nodeName.toLowerCase();

  if (/(switch|range|rating|segmented|stepper|select)/.test(role)) {
    type = role;
  } else {
    for (var i = 0; i < attrs.length; i++) {
      if ($elm.is('[mbsc-' + attrs[i] + ']')) {
        type = attrs[i];
      }
    }
  }

  return type;
}

function activateControl(control, type, ev) {
  control.focus();

  if (/(button|submit|checkbox|switch|radio)/.test(type)) {
    ev.preventDefault();
  }

  if (!/select/.test(type)) {
    triggerClick(ev, control);
  }
}

function tap(that, el, handler, prevent, tolerance, time) {
  var startX,
      startY,
      target,
      moved,
      startTime,
      $ = mobiscroll.$,
      $elm = $(el);
  tolerance = tolerance || 9;

  function onStart(ev) {
    if (!target) {
      // Can't always call preventDefault here, it kills page scroll
      // if (prevent) {
      //     ev.preventDefault();
      // }
      target = this;
      startX = getCoord(ev, 'X');
      startY = getCoord(ev, 'Y');
      moved = false;
      startTime = new Date();
    }
  }

  function onMove(ev) {
    // If movement is more than 20px, don't fire the click event handler
    if (target && !moved && (Math.abs(getCoord(ev, 'X') - startX) > tolerance || Math.abs(getCoord(ev, 'Y') - startY) > tolerance)) {
      moved = true;
    }
  }

  function onEnd(ev) {
    if (target) {
      if (time && new Date() - startTime < 100 || !moved) {
        // ev.preventDefault();
        // handler.call(target, ev, that);
        triggerClick(ev, ev.target);
      } else {
        preventClick();
      }

      target = false;
    }
  }

  function onClick(ev) {
    if (prevent) {
      ev.preventDefault();
    } // If handler was not called on touchend, call it on click;


    handler.call(this, ev, that);
  }

  function onCancel() {
    target = false;
  }

  $elm.each(function (i, elm) {
    if (that.settings.tap) {
      listen(elm, 'touchstart', onStart, {
        passive: true
      });
      listen(elm, 'touchcancel', onCancel);
      listen(elm, 'touchmove', onMove, {
        passive: true
      });
      listen(elm, 'touchend', onEnd);
    }

    listen(elm, 'click', onClick);

    elm.__mbscOff = function () {
      unlisten(elm, 'touchstart', onStart, {
        passive: true
      });
      unlisten(elm, 'touchcancel', onCancel);
      unlisten(elm, 'touchmove', onMove, {
        passive: true
      });
      unlisten(elm, 'touchend', onEnd);
      unlisten(elm, 'click', onClick);
      delete elm.__mbscOff;
    };
  });
}

function tapOff($elm) {
  if ($elm && $elm[0] && $elm[0].__mbscOff) {
    $elm[0].__mbscOff();
  }
} // Prevent standard behaviour on body click


function bustClick(ev) {
  // Textarea needs the mousedown event
  if (tapped && !allowQuick && !ev.isMbscTap && !(ev.target.nodeName == 'TEXTAREA' && ev.type == 'mousedown')) {
    ev.stopPropagation();
    ev.preventDefault();
    return false;
  }
}

if (isBrowser) {
  ['mouseover', 'mousedown', 'mouseup', 'click'].forEach(function (ev) {
    document.addEventListener(ev, bustClick, true);
  });

  if (os == 'android' && majorVersion < 5) {
    document.addEventListener('change', function (ev) {
      if (tapped && ev.target.type == 'checkbox' && !ev.target.mbscChange) {
        ev.stopPropagation();
        ev.preventDefault();
      }

      delete ev.target.mbscChange;
    }, true);
  }
}

/*!
 * Mobiscroll v4.10.9
 * http://mobiscroll.com
 *
 *
 * Copyright 2010-2018, Acid Media
 *
 */

function getWidth(el) {
  return el[0].innerWidth || el.innerWidth();
}

function getThemeName(s) {
  var themeName = s.theme,
      themeVariant = s.themeVariant;

  if (themeName == 'auto' || !themeName) {
    themeName = ms.autoTheme;
  }

  if (themeName == 'default') {
    themeName = 'mobiscroll';
  }

  if ((themeVariant === 'dark' || isDark && themeVariant === 'auto') && ms.themes.form[themeName + '-dark']) {
    themeName = themeName + '-dark';
  } else if (themeVariant === 'light' && /.+-dark$/.test(themeName)) {
    themeName = themeName.replace(/-dark$/, '');
  }

  return themeName;
}

function autoInit(selector, Component, hasRefresh) {
  if (isBrowser) {
    $$1(function () {
      $$1(selector).each(function () {
        new Component(this, {});
      });
      $$1(document).on('mbsc-enhance', function (ev, settings) {
        if ($$1(ev.target).is(selector)) {
          new Component(ev.target, settings || {});
        } else {
          $$1(selector, ev.target).each(function () {
            new Component(this, settings || {});
          });
        }
      });

      if (hasRefresh) {
        $$1(document).on('mbsc-refresh', function (ev) {
          var inst;

          if ($$1(ev.target).is(selector)) {
            inst = instances[ev.target.id];

            if (inst) {
              inst.refresh();
            }
          } else {
            $$1(selector, ev.target).each(function () {
              inst = instances[this.id];

              if (inst) {
                inst.refresh();
              }
            });
          }
        });
      }
    });
  }
}

var ms,
    $$1 = mobiscroll.$,
    id = +new Date(),
    instances = {},
    classes = {},
    empty = {},
    breakpoints = {
  xsmall: 0,
  small: 576,
  medium: 768,
  large: 992,
  xlarge: 1200
},
    extend$1 = $$1.extend;
extend$1(util, {
  getCoord: getCoord,
  preventClick: preventClick,
  vibrate: vibrate
});
ms = extend$1(mobiscroll, {
  $: $$1,
  version: '4.10.9',
  autoTheme: 'mobiscroll',
  themes: {
    form: {},
    page: {},
    frame: {},
    scroller: {},
    listview: {},
    navigation: {},
    progress: {},
    card: {}
  },
  platform: {
    name: os,
    majorVersion: majorVersion,
    minorVersion: minorVersion
  },
  i18n: {},
  instances: instances,
  classes: classes,
  util: util,
  settings: {},
  setDefaults: function setDefaults(o) {
    extend$1(this.settings, o);
  },
  customTheme: function customTheme(name, baseTheme) {
    var i,
        themes = mobiscroll.themes,
        comps = ['frame', 'scroller', 'listview', 'navigation', 'form', 'page', 'progress', 'card'];

    for (i = 0; i < comps.length; i++) {
      themes[comps[i]][name] = extend$1({}, themes[comps[i]][baseTheme], {
        baseTheme: baseTheme
      });
    }
  }
});

var Base = function Base(el, settings) {
  var ctx,
      lang,
      preset,
      resp,
      s,
      theme,
      themeName,
      trigger,
      defaults,
      that = this;
  that.settings = {};
  that.element = el;
  that._init = noop;
  that._destroy = noop;
  that._processSettings = noop;

  that._checkResp = function (width) {
    if (that && that._responsive) {
      var newResp = getResponsiveSettings(width);

      if (resp !== newResp) {
        resp = newResp;
        that.init({});
        return true;
      }
    }
  };

  that._getRespCont = function () {
    return $$1(s.context == 'body' ? window : s.context);
  };

  that.init = function (newSettings, newValue) {
    var key, value; // In case of settings update save the old value

    if (newSettings && that.getVal) {
      value = that.getVal();
    } // Reset settings object


    for (key in that.settings) {
      delete that.settings[key];
    }

    s = that.settings; // Update original user settings

    extend$1(settings, newSettings); // Load user defaults

    if (that._hasDef) {
      defaults = ms.settings;
    } // Create settings object


    extend$1(s, that._defaults, defaults, settings);
    ctx = that._getRespCont();

    if (that._responsive) {
      if (!resp) {
        resp = getResponsiveSettings();
      }

      extend$1(s, resp);
    } // Get theme defaults


    if (that._hasTheme) {
      themeName = getThemeName(s);
      settings.theme = themeName;
      theme = ms.themes[that._class] ? ms.themes[that._class][themeName] : {};
    } // Get language defaults


    if (that._hasLang) {
      lang = ms.i18n[s.lang];
    } // Update settings object


    extend$1(s, theme, lang, defaults, settings, resp);

    that._processSettings(resp || {}); // Load preset settings


    if (that._presets) {
      preset = that._presets[s.preset];

      if (preset) {
        preset = preset.call(el, that, settings, resp);
        extend$1(s, preset, settings, resp);
      }
    }

    that._init(newSettings); // In case of settings update reset the value.
    // This is needed to adapt the value for the updated settings
    // E.g. min/max, date format, etc.


    if (newSettings && that.setVal) {
      that.setVal(newValue === undefined ? value : newValue, true);
    }

    trigger('onInit');
  };

  that.destroy = function () {
    if (that) {
      that._destroy();

      trigger('onDestroy'); // Delete scroller instance

      delete instances[el.id];
      that = null;
    }
  };
  /**
   * Attach tap event to the given element.
   */


  that.tap = function (el, handler, prevent, tolerance, time) {
    tap(that, el, handler, prevent, tolerance, time);
  };
  /**
   * Triggers an event
   */


  that.trigger = function (name, ev) {
    var ret,
        i,
        v,
        s = [defaults, theme, preset, settings];

    for (i = 0; i < 4; i++) {
      v = s[i];

      if (v && v[name]) {
        ret = v[name].call(el, ev || {}, that);
      }
    }

    return ret;
  };
  /**
   * Sets one ore more options.
   */


  that.option = function (opt, value, newValue) {
    var obj = {},
        // preserve settings that are possible to change runtime
    dynamic = ['data', 'invalid', 'valid', 'readonly'];

    if (/calendar|eventcalendar|range/.test(s.preset)) {
      dynamic.push('marked', 'labels', 'colors');
    }

    if (typeof opt === 'object') {
      obj = opt;
    } else {
      obj[opt] = value;
    }

    dynamic.forEach(function (v) {
      settings[v] = s[v];
    });
    that.init(obj, newValue);
  };
  /**
   * Returns the mobiscroll instance.
   */


  that.getInst = function () {
    return that;
  };

  settings = settings || {};
  trigger = that.trigger;

  function getResponsiveSettings(w) {
    var result = empty,
        width;

    if (s.responsive) {
      width = w || getWidth(ctx);
      $$1.each(s.responsive, function (key, value) {
        if (width >= (value.breakpoint || breakpoints[key])) {
          result = value;
        }
      });
    }

    return result;
  }

  function construct() {
    $$1(el).addClass('mbsc-comp'); // Autogenerate id

    if (!el.id) {
      el.id = 'mobiscroll' + ++id;
    } else if (instances[el.id]) {
      instances[el.id].destroy();
    } // Save instance


    instances[el.id] = that;
    that.__ready = true;
  }

  if (!that.__ready) {
    construct();
  }
};

var Observable = function () {
  function Observable() {
    this.keyCount = 0;
    this.subscribers = new Map();
  }

  Observable.prototype.subscribe = function (handler) {
    var key = this.keyCount++;
    this.subscribers.set(key, handler);
    return key;
  };

  Observable.prototype.unsubscribe = function (handler) {
    if (typeof handler === 'number') {
      this.subscribers.delete(handler);
    } else {
      var foundKey_1 = null;
      this.subscribers.forEach(function (fn, key) {
        if (fn === handler) {
          foundKey_1 = key;
        }
      });
      this.subscribers.delete(foundKey_1);
    }
  };

  Observable.prototype.next = function (value) {
    this.subscribers.forEach(function (handler) {
      handler(value);
    });
  };

  return Observable;
}();

var MbscOptionsService = (function () {
    function MbscOptionsService() {
    }
    Object.defineProperty(MbscOptionsService.prototype, "options", {
        get: function () {
            return this._options;
        },
        set: function (o) {
            this._options = o;
        },
        enumerable: true,
        configurable: true
    });
    MbscOptionsService.decorators = [
        { type: Injectable },
    ];
    MbscOptionsService.ctorParameters = function () { return []; };
    return MbscOptionsService;
}());
var MbscInputService = (function () {
    function MbscInputService() {
        this._controlSet = false;
        this._componentRef = undefined;
    }
    Object.defineProperty(MbscInputService.prototype, "isControlSet", {
        get: function () {
            return this._controlSet;
        },
        set: function (v) {
            this._controlSet = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscInputService.prototype, "input", {
        get: function () {
            return this._componentRef;
        },
        set: function (v) {
            this._componentRef = v;
        },
        enumerable: true,
        configurable: true
    });
    MbscInputService.decorators = [
        { type: Injectable },
    ];
    MbscInputService.ctorParameters = function () { return []; };
    return MbscInputService;
}());
var MbscBase = (function () {
    function MbscBase(initialElem, zone) {
        this.initialElem = initialElem;
        this.zone = zone;
        this.options = {};
        this.onInit = new EventEmitter();
        this.onDestroy = new EventEmitter();
        this.inlineOptionsObj = {};
        this.pendingValue = undefined;
        this.themeClassesSet = false;
        this.instance = null;
        this.element = null;
        this.inlineOptionsObj.zone = zone;
    }
    MbscBase.prototype.getInlineEvents = function () {
        var _this = this;
        var _loop_1 = function (prop) {
            if (this_1[prop] instanceof (EventEmitter) && (!this_1.options || !(this_1.options[prop]))) {
                this_1.inlineOptionsObj[prop] = function (event, inst) {
                    event.inst = inst;
                    _this[prop].emit(event);
                };
            }
        };
        var this_1 = this;
        for (var prop in this) {
            _loop_1(prop);
        }
    };
    MbscBase.prototype.setThemeClasses = function () {
        $$1(this.initialElem.nativeElement).addClass(this.getThemeClasses());
        this.themeClassesSet = true;
    };
    MbscBase.prototype.clearThemeClasses = function () {
        $$1(this.initialElem.nativeElement).removeClass(this.getThemeClasses());
    };
    MbscBase.prototype.getThemeClasses = function () {
        var s = this.instance.settings;
        return 'mbsc-control-ng mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '');
    };
    MbscBase.prototype.setElement = function () {
        this.element = this.initialElem.nativeElement;
        var contentInput = $$1('input', this.initialElem.nativeElement);
        if (contentInput.length) {
            this.element = contentInput[0];
        }
    };
    MbscBase.prototype.ngAfterViewInit = function () {
        this.setElement();
        this.startInit();
    };
    MbscBase.prototype.startInit = function () {
        var _this = this;
        this.getInlineEvents();
        var ionInput = this.getIonInput();
        if (ionInput && (ionInput.getInputElement || ionInput.then) && this.element.nodeName !== "INPUT") {
            if (ionInput.getInputElement) {
                ionInput.getInputElement().then(function (inp) {
                    _this.setElement();
                    _this.initControl();
                });
            }
            else {
                ionInput.then(function (ionInpComponent) {
                    ionInpComponent
                        .getInputElement()
                        .then(function (inp) {
                        _this.setElement();
                        _this.initControl();
                    });
                });
            }
        }
        else if (!this.instance) {
            this.initControl();
        }
    };
    MbscBase.prototype.getIonInput = function () {
        var v = this._view;
        var native = this.initialElem.nativeElement;
        var ionInputNode = native.nodeName === "ION-INPUT";
        var inp1 = ionInputNode && v && v._data && v._data.componentView && v._data.componentView.component;
        var inp2 = ionInputNode && native.componentOnReady && native.componentOnReady();
        return inp1 || inp2;
    };
    MbscBase.prototype.initControl = function () { };
    MbscBase.prototype.ngOnDestroy = function () {
        if (this.instance) {
            this.instance.destroy();
        }
    };
    MbscBase.prototype.updateOptions = function (newOptions, optionChanged, invalidChanged, dataChanged) {
        var _this = this;
        if (optionChanged || invalidChanged) {
            setTimeout(function () {
                if (newOptions.theme && _this.themeClassesSet) {
                    _this.clearThemeClasses();
                }
                _this.instance.option(newOptions, undefined, _this.pendingValue);
                if (newOptions.theme && _this.themeClassesSet) {
                    _this.setThemeClasses();
                }
            });
        }
        else if (dataChanged) {
            this.refreshData(this.data);
        }
        else if (this.instance.redraw) {
            this.instance.redraw();
        }
    };
    MbscBase.prototype.ngOnChanges = function (changes) {
        var optionChange = false, cloneChange = false, invalidChange = false, dataChange = false, newOptions = {};
        for (var prop in changes) {
            if (!changes[prop].firstChange && prop !== 'options' && prop !== 'value') {
                if (this.cloneDictionary && this.cloneDictionary[prop]) {
                    this.makeClone(prop, changes[prop].currentValue);
                    if (this.instance) {
                        this.instance.settings[prop] = changes[prop].currentValue;
                    }
                    if (prop == 'invalid') {
                        invalidChange = true;
                    }
                    if (prop == 'data') {
                        dataChange = true;
                    }
                    cloneChange = true;
                }
                else {
                    newOptions[prop] = changes[prop].currentValue;
                    optionChange = true;
                }
            }
            else if (!changes[prop].firstChange && prop !== 'value') {
                newOptions = extend$1(changes[prop].currentValue, newOptions);
                optionChange = true;
            }
            else if (changes[prop].firstChange) {
                if (prop !== 'options' && prop !== 'value') {
                    this.inlineOptionsObj[prop] = changes[prop].currentValue;
                }
            }
        }
        if (cloneChange) {
            extend$1(newOptions, this.cloneDictionary);
        }
        if (optionChange || cloneChange) {
            this.updateOptions(newOptions, optionChange, invalidChange, dataChange);
        }
    };
    MbscBase.decorators = [
        { type: Directive, args: [{ selector: '[mbsc-b]' },] },
    ];
    MbscBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
    ]; };
    MbscBase.propDecorators = {
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'cssClass': [{ type: Input$1 },],
        'theme': [{ type: Input$1 },],
        'themeVariant': [{ type: Input$1 },],
        'lang': [{ type: Input$1 },],
        'rtl': [{ type: Input$1 },],
        'responsive': [{ type: Input$1 },],
        'onInit': [{ type: Output },],
        'onDestroy': [{ type: Output },],
    };
    return MbscBase;
}());
var MbscValueBase = (function (_super) {
    __extends(MbscValueBase, _super);
    function MbscValueBase(initialElem, zone) {
        var _this = _super.call(this, initialElem, zone) || this;
        _this.initialValue = undefined;
        return _this;
    }
    MbscValueBase.prototype.setNewValue = function (v) { };
    MbscValueBase.prototype.setNewValueProxy = function (v) {
        if (!this.instance) {
            this.initialValue = v;
        }
        this.setNewValue(v);
    };
    MbscValueBase.decorators = [
        { type: Directive, args: [{ selector: '[mbsc-v-b]' },] },
    ];
    MbscValueBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
    ]; };
    return MbscValueBase;
}(MbscBase));
var MbscCloneBase = (function (_super) {
    __extends(MbscCloneBase, _super);
    function MbscCloneBase(initElem, zone) {
        var _this = _super.call(this, initElem, zone) || this;
        _this.cloneDictionary = {};
        return _this;
    }
    MbscCloneBase.prototype.makeClone = function (setting, value) {
        if (value) {
            this.cloneDictionary[setting] = [];
            for (var i = 0; i < value.length; i++) {
                this.cloneDictionary[setting].push(value[i]);
            }
        }
        else {
            this.cloneDictionary[setting] = value;
        }
    };
    MbscCloneBase.prototype.ngDoCheck = function () {
        var changed = false, data = false, invalid = false;
        for (var key in this.cloneDictionary) {
            if (this[key] !== undefined && !deepEqualsArray(this[key], this.cloneDictionary[key])) {
                this.makeClone(key, this[key]);
                this.instance.settings[key] = this[key];
                changed = true;
                if (key == 'invalid') {
                    invalid = true;
                }
                if (key == 'data') {
                    data = true;
                }
            }
        }
        if (changed && this.instance) {
            this.updateOptions(this.cloneDictionary, false, invalid, data);
        }
    };
    MbscCloneBase.prototype.ngOnInit = function () {
        for (var key in this.cloneDictionary) {
            this.makeClone(key, this[key]);
        }
    };
    MbscCloneBase.decorators = [
        { type: Directive, args: [{ selector: '[mbsc-c-b]' },] },
    ];
    MbscCloneBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
    ]; };
    return MbscCloneBase;
}(MbscValueBase));
var MbscControlBase = (function (_super) {
    __extends(MbscControlBase, _super);
    function MbscControlBase(initialElement, zone, control, _inputService, _view) {
        var _this = _super.call(this, initialElement, zone) || this;
        _this.control = control;
        _this._inputService = _inputService;
        _this._view = _view;
        _this._needsTimeout = true;
        _this.onChange = function () { };
        _this.onTouch = function () { };
        _this.onChangeEmitter = new EventEmitter();
        _this.oldAccessor = null;
        _this.overwriteAccessor();
        if (_inputService) {
            _inputService.isControlSet = true;
        }
        return _this;
    }
    Object.defineProperty(MbscControlBase.prototype, "optionExtensions", {
        get: function () {
            var _this = this;
            var externalOnClose = this.options && this.options.onClose;
            var externalOnFill = this.options && this.options.onFill;
            var onCloseEmitter = this.onClose;
            return {
                onFill: function (event, inst) {
                    if (_this.oldAccessor) {
                        _this.oldAccessor.writeValue(event.valueText);
                    }
                    else {
                        var ionInput = _this.getIonInput();
                        if (ionInput) {
                            ionInput.value = event.valueText;
                        }
                    }
                    if (externalOnFill) {
                        externalOnFill(event, inst);
                    }
                },
                onClose: function (event, inst) {
                    _this.onTouch();
                    if (externalOnClose) {
                        externalOnClose(event, inst);
                    }
                    if (onCloseEmitter) {
                        event.inst = inst;
                        onCloseEmitter.emit(event);
                    }
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscControlBase.prototype, "enableManualEdit", {
        get: function () {
            var nsf = this.showOnFocus === false || this.options.showOnFocus === false, nst = this.showOnTap === false || this.options.showOnTap === false;
            return nsf && nst;
        },
        enumerable: true,
        configurable: true
    });
    MbscControlBase.prototype.handleChange = function (element) {
        var that = this;
        $$1(element || this.element).on('change', function () {
            that.zone.run(function () {
                var elmValue = that.element.value;
                var instValue = that.instance._value;
                if (elmValue !== instValue && (instValue !== null || elmValue !== '') && that.enableManualEdit) {
                    that.instance.setVal(elmValue, true, true);
                }
                else {
                    var value = that.instance.getVal();
                    if (that.control) {
                        if (!valueEquals(value, that.control.model)) {
                            that.onChange(value);
                            that.control.control.patchValue(value);
                        }
                    }
                    else {
                        that.onChangeEmitter.emit(value);
                    }
                }
            });
        });
        function valueEquals(v1, v2) {
            if (v1 === v2) {
                return true;
            }
            if (v1 instanceof Date && v2 instanceof Date) {
                return (+v1) === (+v2);
            }
            return false;
        }
    };
    MbscControlBase.prototype.overwriteAccessor = function () {
        if (this.control) {
            if (this.control.valueAccessor !== this) {
                this.oldAccessor = this.control.valueAccessor;
            }
            this.control.valueAccessor = this;
        }
    };
    MbscControlBase.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.handleChange();
        this.overwriteAccessor();
        if (this.control && this.control._setUpControl) {
            this.control._setUpControl();
        }
    };
    MbscControlBase.prototype.registerOnChange = function (fn) {
        this.onChange = fn;
    };
    MbscControlBase.prototype.registerOnTouched = function (fn) {
        this.onTouch = fn;
    };
    MbscControlBase.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
        if (this.oldAccessor && this.oldAccessor.setDisabledState) {
            this.oldAccessor.setDisabledState(isDisabled);
        }
        if (this.instance && this.instance.disable && this.instance.enable) {
            if (isDisabled) {
                this.instance.disable();
            }
            else {
                this.instance.enable();
            }
        }
    };
    MbscControlBase.prototype.writeValue = function (v) {
        var _this = this;
        if (this._needsTimeout) {
            this.pendingValue = v;
            setTimeout(function () {
                _this.pendingValue = undefined;
                _this.setNewValueProxy(v);
            });
        }
        else {
            this.setNewValueProxy(v);
        }
    };
    MbscControlBase.decorators = [
        { type: Directive, args: [{ selector: '[mbsc-cc-b]' },] },
    ];
    MbscControlBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, },
        { type: MbscInputService, },
        { type: ViewContainerRef, },
    ]; };
    MbscControlBase.propDecorators = {
        'labelStyle': [{ type: Input$1, args: ['label-style',] },],
        'inputStyle': [{ type: Input$1, args: ['input-style',] },],
        'showOnFocus': [{ type: Input$1 },],
        'showOnTap': [{ type: Input$1 },],
        'disabled': [{ type: Input$1 },],
    };
    return MbscControlBase;
}(MbscCloneBase));
var MbscFrameBase = (function (_super) {
    __extends(MbscFrameBase, _super);
    function MbscFrameBase(initialElem, zone, control, _inputService, view) {
        var _this = _super.call(this, initialElem, zone, control, _inputService, view) || this;
        _this.onBeforeClose = new EventEmitter();
        _this.onBeforeShow = new EventEmitter();
        _this.onCancel = new EventEmitter();
        _this.onClose = new EventEmitter();
        _this.onFill = new EventEmitter();
        _this.onMarkupReady = new EventEmitter();
        _this.onPosition = new EventEmitter();
        _this.onShow = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscFrameBase.prototype, "inline", {
        get: function () {
            return (this.display || (this.options && this.options.display)) === 'inline';
        },
        enumerable: true,
        configurable: true
    });
    MbscFrameBase.prototype.ngOnInit = function () {
        this.cloneDictionary.invalid = [];
        this.cloneDictionary.valid = [];
        _super.prototype.ngOnInit.call(this);
    };
    MbscFrameBase.decorators = [
        { type: Directive, args: [{ selector: '[mbsc-fr-b]' },] },
    ];
    MbscFrameBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, },
        { type: MbscInputService, },
        { type: ViewContainerRef, },
    ]; };
    MbscFrameBase.propDecorators = {
        'options': [{ type: Input$1 },],
        'dropdown': [{ type: Input$1 },],
        'anchor': [{ type: Input$1 },],
        'animate': [{ type: Input$1 },],
        'buttons': [{ type: Input$1 },],
        'closeOnOverlayTap': [{ type: Input$1 },],
        'context': [{ type: Input$1 },],
        'display': [{ type: Input$1 },],
        'showInput': [{ type: Input$1 },],
        'focusOnClose': [{ type: Input$1 },],
        'focusTrap': [{ type: Input$1 },],
        'headerText': [{ type: Input$1 },],
        'scrollLock': [{ type: Input$1 },],
        'touchUi': [{ type: Input$1 },],
        'onBeforeClose': [{ type: Output },],
        'onBeforeShow': [{ type: Output },],
        'onCancel': [{ type: Output },],
        'onClose': [{ type: Output },],
        'onFill': [{ type: Output },],
        'onMarkupReady': [{ type: Output },],
        'onPosition': [{ type: Output },],
        'onShow': [{ type: Output },],
    };
    return MbscFrameBase;
}(MbscControlBase));
var MbscScrollerBase = (function (_super) {
    __extends(MbscScrollerBase, _super);
    function MbscScrollerBase(initialElement, zone, control, _inputService, view) {
        var _this = _super.call(this, initialElement, zone, control, _inputService, view) || this;
        _this.onWheelChange = new EventEmitter();
        _this.onSet = new EventEmitter();
        _this.onItemTap = new EventEmitter();
        _this.onClear = new EventEmitter();
        return _this;
    }
    MbscScrollerBase.decorators = [
        { type: Directive, args: [{ selector: '[mbsc-s-b]' },] },
    ];
    MbscScrollerBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, },
        { type: MbscInputService, },
        { type: ViewContainerRef, },
    ]; };
    MbscScrollerBase.propDecorators = {
        'circular': [{ type: Input$1 },],
        'height': [{ type: Input$1 },],
        'layout': [{ type: Input$1 },],
        'maxWidth': [{ type: Input$1 },],
        'minWidth': [{ type: Input$1 },],
        'multiline': [{ type: Input$1 },],
        'readonly': [{ type: Input$1 },],
        'rows': [{ type: Input$1 },],
        'showLabel': [{ type: Input$1 },],
        'showScrollArrows': [{ type: Input$1 },],
        'wheels': [{ type: Input$1 },],
        'width': [{ type: Input$1 },],
        'validate': [{ type: Input$1 },],
        'cancelText': [{ type: Input$1 },],
        'clearText': [{ type: Input$1 },],
        'selectedText': [{ type: Input$1 },],
        'setText': [{ type: Input$1 },],
        'formatValue': [{ type: Input$1 },],
        'parseValue': [{ type: Input$1 },],
        'onWheelChange': [{ type: Output, args: ['onChange',] },],
        'onSet': [{ type: Output },],
        'onItemTap': [{ type: Output },],
        'onClear': [{ type: Output },],
    };
    return MbscScrollerBase;
}(MbscFrameBase));
var MbscBaseModule = (function () {
    function MbscBaseModule() {
    }
    MbscBaseModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    declarations: [MbscBase, MbscValueBase, MbscCloneBase, MbscControlBase],
                },] },
    ];
    MbscBaseModule.ctorParameters = function () { return []; };
    return MbscBaseModule;
}());
function deepEqualsArray(a1, a2) {
    if (a1 === a2) {
        return true;
    }
    else if (!a1 || !a2 || a1.length !== a2.length) {
        return false;
    }
    else {
        for (var i = 0; i < a1.length; i++) {
            if (a1[i] !== a2[i]) {
                return false;
            }
        }
        return true;
    }
}
function emptyOrTrue(val) {
    return (typeof (val) === 'string' && (val === 'true' || val === '')) || !!val;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var wrapClass = 'mbsc-input-wrap';
var events = ['touchend', 'touchcancel', 'mousedown', 'mousemove', 'mouseup', 'mouseleave'];
var defaults = {
  tap: hasGhostClick
};
var $active;

function addIcon($control, ic) {
  var icons = {},
      control = $control[0],
      $parent = $control.parent(),
      errorMsg = $parent.find('.mbsc-err-msg'),
      align = $control.attr('data-icon-align') || 'left',
      icon = $control.attr('data-icon');

  if ($parent.hasClass(wrapClass)) {
    $parent = $parent.parent();
  } else {
    // Wrap input
    $$1('<span class="' + wrapClass + '"></span>').insertAfter($control).append($control);
  }

  if (errorMsg) {
    $parent.find('.' + wrapClass).append(errorMsg);
  }

  if (icon) {
    if (icon.indexOf('{') !== -1) {
      icons = JSON.parse(icon);
    } else {
      icons[align] = icon;
    }
  }

  if (control.type == 'file') {
    // Set icon
    icons.right = $control.attr('data-icon-upload') || 'upload';
  }

  if (icon || ic) {
    extend$1(icons, ic);
    $parent.addClass((icons.right ? 'mbsc-ic-right ' : '') + (icons.left ? ' mbsc-ic-left' : '')).find('.' + wrapClass).append('<span class="mbsc-input-fill"></span>').append(icons.left ? '<span class="mbsc-input-ic mbsc-left-ic mbsc-ic mbsc-ic-' + icons.left + '"></span>' : '').append(icons.right ? '<span class="mbsc-input-ic mbsc-right-ic mbsc-ic mbsc-ic-' + icons.right + '"></span>' : '');
  }
}

function addIconToggle(that, $parent, $control) {
  var icons = {},
      control = $control[0],
      toggle = $control.attr('data-password-toggle'),
      iconShow = $control.attr('data-icon-show') || 'eye',
      iconHide = $control.attr('data-icon-hide') || 'eye-blocked';

  if (toggle) {
    icons.right = control.type == 'password' ? iconShow : iconHide;
  }

  addIcon($control, icons);

  if (toggle) {
    tap(that, $parent.find('.mbsc-right-ic').addClass('mbsc-input-toggle'), function () {
      if (control.type == "text") {
        control.type = "password";
        $$1(this).addClass('mbsc-ic-' + iconShow).removeClass('mbsc-ic-' + iconHide);
      } else {
        control.type = "text";
        $$1(this).removeClass('mbsc-ic-' + iconShow).addClass('mbsc-ic-' + iconHide);
      }
    });
  }
}

function wrapLabel($parent, type, inputStyle, labelStyle, elm) {
  // Wrap non-empty text nodes in span with mbsc-label class
  if (type == 'segmented') {
    $parent.closest('.mbsc-segmented').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '');
  } else if (type != 'button' && type != 'submit') {
    $parent.addClass('mbsc-control-w').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '').addClass(labelStyle == 'inline' ? 'mbsc-label-inline' : '').addClass(labelStyle == 'stacked' ? 'mbsc-label-stacked' : '').addClass(labelStyle == 'floating' ? 'mbsc-label-floating' : '').addClass(labelStyle == 'floating' && elm.value ? 'mbsc-label-floating-active' : '').find('label').addClass('mbsc-label').each(function (i, v) {
      $$1(v).attr('title', $$1(v).text());
    });
    $parent.contents().filter(function () {
      return this.nodeType == 3 && this.nodeValue && /\S/.test(this.nodeValue);
    }).each(function () {
      $$1('<span class="mbsc-label" title="' + this.textContent.trim() + '"></span>').insertAfter(this).append(this);
    });
  }
}

function getRipple(theme) {
  var ripple = mobiscroll.themes.form[theme];
  return ripple && ripple.addRipple ? ripple : null;
}

function getAttr($elm, attr, def) {
  var v = $elm.attr(attr);
  return v === undefined || v === '' ? def : v;
}

function getCssClass(s) {
  var theme = getThemeName(s);
  var baseTheme = mobiscroll.themes.form[theme].baseTheme;
  return 'mbsc-' + theme + (baseTheme ? ' mbsc-' + baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');
}

var FormControl =
/*#__PURE__*/
function () {
  function FormControl(elm, settings) {
    var _this = this;

    var s = extend$1({}, defaults, mobiscroll.settings, settings);
    var $elm = $$1(elm);
    var $p = $elm.parent();
    var $parent = $p.hasClass('mbsc-input-wrap') ? $p.parent() : $p; // Check for inline mobiscroll components

    var $frame = $elm.next().hasClass('mbsc-fr') ? $elm.next() : null;
    var type = getControlType($elm);
    var inputStyle = getAttr($elm, 'data-input-style', s.inputStyle);
    var labelStyle = getAttr($elm, 'data-label-style', s.labelStyle);

    if (elm.mbscInst) {
      elm.mbscInst.destroy();
    }

    if ($frame) {
      $frame.insertAfter($parent);
    }

    s.theme = getThemeName(s);

    if (s.rtl === undefined && s.lang && mobiscroll.i18n[s.lang]) {
      s.rtl = mobiscroll.i18n[s.lang].rtl;
    }

    wrapLabel($parent, type, inputStyle, labelStyle, elm);
    $elm.addClass('mbsc-control'); // Attach events

    this._handle = this._handle.bind(this); // Prevent 300ms click latency

    events.forEach(function (ev) {
      $elm.on(ev, _this._handle);
    }); // Touch events are added separately, needs to be passive listener

    listen(elm, 'touchstart', this._handle, {
      passive: true
    });
    listen(elm, 'touchmove', this._handle, {
      passive: true
    });
    this.settings = s;
    this._type = type;
    this._elm = elm;
    this._$elm = $elm;
    this._$parent = $parent;
    this._$frame = $frame;
    this._ripple = getRipple(s.theme);
    this._isFloating = labelStyle == 'floating' || $parent.hasClass('mbsc-label-floating');
    this.cssClass = getCssClass(s);
    this.getClassElm().addClass(this.cssClass);
    elm.mbscInst = this;
  }

  var _proto = FormControl.prototype;

  _proto.getClassElm = function getClassElm() {
    return this._$parent;
  };

  _proto.destroy = function destroy() {
    var _this2 = this;

    var $elm = this._$elm;
    var elm = this._elm;
    $elm.removeClass('mbsc-control');
    this.getClassElm().removeClass(this.cssClass);
    events.forEach(function (ev) {
      $elm.off(ev, _this2._handle);
    });
    unlisten(elm, 'touchstart', this._handle, {
      passive: true
    });
    unlisten(elm, 'touchmove', this._handle, {
      passive: true
    });
    delete elm.mbscInst;
  };

  _proto.option = function option(s) {
    extend$1(this.settings, s);
    var classElm = this.getClassElm();

    if (this.cssClass) {
      classElm.removeClass(this.cssClass);
    }

    this.cssClass = getCssClass(this.settings);
    classElm.addClass(this.cssClass);
    this._ripple = getRipple(this.settings.theme);
  };

  _proto._handle = function _handle(ev) {
    switch (ev.type) {
      case 'touchstart':
      case 'mousedown':
        this._onStart(ev);

        break;

      case 'touchmove':
      case 'mousemove':
        this._onMove(ev);

        break;

      case 'touchend':
      case 'touchcancel':
      case 'mouseup':
      case 'mouseleave':
        this._onEnd(ev);

        break;
    }
  };

  _proto._addRipple = function _addRipple(ev) {
    if (this._ripple && this._$rippleElm) {
      this._ripple.addRipple(this._$rippleElm, ev);
    }
  };

  _proto._removeRipple = function _removeRipple() {
    if (this._ripple && this._$rippleElm) {
      this._ripple.removeRipple();
    }
  };

  _proto._onStart = function _onStart(ev) {
    var elm = this._elm;

    if (testTouch(ev, elm)) {
      this._startX = getCoord(ev, 'X');
      this._startY = getCoord(ev, 'Y');

      if ($active) {
        $active.removeClass('mbsc-active');
      }

      if (!elm.disabled) {
        this._isActive = true;
        $active = this._$elm;
        $active.addClass('mbsc-active');

        this._addRipple(ev);
      }
    }

    if (ev.type == 'touchstart') {
      this._$elm.closest('.mbsc-no-touch').removeClass('mbsc-no-touch');
    }
  };

  _proto._onMove = function _onMove(ev) {
    // If movement is more than 9px, don't fire the click event handler
    if (this._isActive && Math.abs(getCoord(ev, 'X') - this._startX) > 9 || Math.abs(getCoord(ev, 'Y') - this._startY) > 9) {
      this._$elm.removeClass('mbsc-active');

      this._removeRipple();

      this._isActive = false;
    }
  };

  _proto._onEnd = function _onEnd(ev) {
    var _this3 = this;

    var control = this._elm;
    var type = this._type;

    if (this._isActive && this.settings.tap && ev.type == 'touchend' && !control.readOnly) {
      activateControl(control, type, ev);
    }

    if (this._isActive) {
      setTimeout(function () {
        _this3._$elm.removeClass('mbsc-active');

        _this3._removeRipple();
      }, 100);
    }

    this._isActive = false;
    $active = null;
  };

  return FormControl;
}();
mobiscroll.themes.form.mobiscroll = {};

var events$1 = ['focus', 'change', 'blur', 'animationstart'];
var Input =
/*#__PURE__*/
function (_FormControl) {
  _inheritsLoose(Input, _FormControl);

  function Input(elm, settings) {
    var _this;

    _this = _FormControl.call(this, elm, settings) || this;
    var $elm = _this._$elm;
    var $parent = _this._$parent;
    var $dummy = $parent.find('.mbsc-select-input, .mbsc-color-input');
    addIconToggle(_assertThisInitialized(_this), $parent, $elm);
    _this._checkLabel = _this._checkLabel.bind(_assertThisInitialized(_this));
    _this._mouseDown = _this._mouseDown.bind(_assertThisInitialized(_this));
    _this._setText = _this._setText.bind(_assertThisInitialized(_this));

    if (elm.type == 'file') {
      // Copy attributes and create dummy input
      var $existing = $parent.find('.mbsc-file-input');
      _this._$input = $existing.length ? $existing : $$1('<input type="text" class="' + ($elm.attr('class') || '') + ' mbsc-file-input" placeholder="' + ($elm.attr('placeholder') || '') + '"/>').insertAfter($elm); // Copy value on file upload

      $elm.on('change', _this._setText);
    }

    $parent.addClass('mbsc-input').on('mousedown', _this._mouseDown); // Attach events

    events$1.forEach(function (ev) {
      $elm.on(ev, _this._checkLabel);
    }); // Move the dummy input after the element for correct styling

    if ($dummy.length) {
      $elm.after($dummy);

      if ($dummy.hasClass('mbsc-select-input')) {
        _this._delm = $dummy[0];

        _this.refresh();
      }
    }

    return _this;
  }

  var _proto = Input.prototype;

  _proto._setText = function _setText(ev) {
    var files = ev.target.files;
    var names = [];

    for (var i = 0; i < files.length; ++i) {
      names.push(files[i].name);
    }

    this._$input.val(names);
  };

  _proto._checkLabel = function _checkLabel(ev) {
    if (this._isFloating) {
      // In case of select we need to check the dummy element
      var elm = this._delm || this._elm; // In case of autofill in webkit browsers the animationstart event will fire 
      // due to the empty animation added in the css,
      // because there's no other event in case of the initial autofill

      if (elm.value || document.activeElement === elm || ev && (ev.type == 'focus' || ev.type == 'animationstart' && this._$elm.is('*:-webkit-autofill'))) {
        this._$parent.addClass('mbsc-label-floating-active');
      } else {
        this._$parent.removeClass('mbsc-label-floating-active');
      }
    }
  };

  _proto._mouseDown = function _mouseDown(ev) {
    // Will prevent floating label animation when loosing focus only for a brief moment
    if (document.activeElement === this._elm && ev.target !== this._elm) {
      ev.preventDefault();
    }
  };

  _proto.refresh = function refresh() {
    this._checkLabel();
  };

  _proto.destroy = function destroy() {
    var _this2 = this;

    _FormControl.prototype.destroy.call(this);

    this._$parent.off('mousedown', this._mouseDown).removeClass('mbsc-ic-left mbsc-ic-right').find('.mbsc-input-ic').remove();

    this._$parent.find('.mbsc-input-fill').remove();

    events$1.forEach(function (ev) {
      _this2._$elm.off(ev, _this2._checkLabel);
    });

    this._$elm.off('change', this._setText);
  };

  return Input;
}(FormControl); // Init mbsc-input elements on page load

autoInit('[mbsc-input]', Input);

var MbscFormBase = (function (_super) {
    __extends(MbscFormBase, _super);
    function MbscFormBase(hostElem, _formService, zone) {
        var _this = _super.call(this, hostElem, zone) || this;
        _this._formService = _formService;
        _this.disabled = false;
        return _this;
    }
    MbscFormBase.prototype.ngOnInit = function () {
        this._inheritedOptions = this._formService ? this._formService.options : {};
    };
    MbscFormBase.decorators = [
        { type: Directive, args: [{ selector: '[mbsc-f-b]' },] },
    ];
    MbscFormBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, },
        { type: NgZone, },
    ]; };
    MbscFormBase.propDecorators = {
        'color': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'disabled': [{ type: Input$1 },],
        'name': [{ type: Input$1 },],
        '_initElem': [{ type: ViewChild, args: ['initElement', { static: false },] },],
    };
    return MbscFormBase;
}(MbscBase));
var MbscFormValueBase = (function (_super) {
    __extends(MbscFormValueBase, _super);
    function MbscFormValueBase(hostElem, _formService, _inputService, _control, zone) {
        var _this = _super.call(this, hostElem, _formService, zone) || this;
        _this._control = _control;
        _this.onChange = function () { };
        _this.onTouch = function () { };
        _this.errorMessage = '';
        _this.valueChangeEmitter = new EventEmitter();
        if (_control && (!_inputService || !_inputService.isControlSet)) {
            if (_control.valueAccessor && _control.valueAccessor.oldAccessor !== undefined) {
                _control.valueAccessor.oldAccessor = _this;
            }
            else {
                _control.valueAccessor = _this;
            }
        }
        return _this;
    }
    Object.defineProperty(MbscFormValueBase.prototype, "readonly", {
        set: function (val) {
            this._readonly = emptyOrTrue(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscFormValueBase.prototype, "innerValue", {
        get: function () {
            return this._value;
        },
        set: function (v) {
            this._value = v;
            this.onChange(v);
            this.valueChangeEmitter.emit(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscFormValueBase.prototype, "value", {
        set: function (v) {
            this._value = v;
            this.refresh();
        },
        enumerable: true,
        configurable: true
    });
    MbscFormValueBase.prototype.registerOnChange = function (fn) {
        this.onChange = fn;
    };
    MbscFormValueBase.prototype.registerOnTouched = function (fn) {
        this.onTouch = fn;
    };
    MbscFormValueBase.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
    };
    MbscFormValueBase.prototype.writeValue = function (v) {
        this._value = v;
        this.refresh();
    };
    MbscFormValueBase.prototype.refresh = function () {
        var _this = this;
        if (this.instance && this.instance.refresh) {
            setTimeout(function () {
                _this.instance.refresh();
            });
        }
        else {
            this._needRefresh = true;
        }
    };
    MbscFormValueBase.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        if (this._needRefresh) {
            this.refresh();
        }
    };
    MbscFormValueBase.decorators = [
        { type: Directive, args: [{ selector: '[mbsc-fv-b]' },] },
    ];
    MbscFormValueBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: NgControl, },
        { type: NgZone, },
    ]; };
    MbscFormValueBase.propDecorators = {
        'readonly': [{ type: Input$1 },],
        'value': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'valueChangeEmitter': [{ type: Output, args: ['valueChange',] },],
    };
    return MbscFormValueBase;
}(MbscFormBase));
var MbscInputBase = (function (_super) {
    __extends(MbscInputBase, _super);
    function MbscInputBase(initialElem, _formService, _inputService, _control, zone) {
        var _this = _super.call(this, initialElem, _formService, _inputService, _control, zone) || this;
        _this.type = 'text';
        _this.placeholder = '';
        return _this;
    }
    MbscInputBase.decorators = [
        { type: Directive, args: [{ selector: '[mbsc-i-b]' },] },
    ];
    MbscInputBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: NgControl, },
        { type: NgZone, },
    ]; };
    MbscInputBase.propDecorators = {
        'autocomplete': [{ type: Input$1 },],
        'autocapitalize': [{ type: Input$1 },],
        'autocorrect': [{ type: Input$1 },],
        'spellcheck': [{ type: Input$1 },],
        'autofocus': [{ type: Input$1 },],
        'minlength': [{ type: Input$1 },],
        'maxlength': [{ type: Input$1 },],
        'required': [{ type: Input$1 },],
        'icon': [{ type: Input$1 },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'type': [{ type: Input$1 },],
        'passwordToggle': [{ type: Input$1, args: ['password-toggle',] },],
        'iconShow': [{ type: Input$1, args: ['icon-show',] },],
        'iconHide': [{ type: Input$1, args: ['icon-hide',] },],
        'iconUpload': [{ type: Input$1, args: ['icon-upload',] },],
        'inputStyle': [{ type: Input$1, args: ['input-style',] },],
        'labelStyle': [{ type: Input$1, args: ['label-style',] },],
        'placeholder': [{ type: Input$1 },],
    };
    return MbscInputBase;
}(MbscFormValueBase));
var MbscInput = (function (_super) {
    __extends(MbscInput, _super);
    function MbscInput(initialElem, _formService, _inputService, _control, zone) {
        var _this = _super.call(this, initialElem, _formService, _inputService, _control, zone) || this;
        _this._inputService = _inputService;
        _this.controlNg = true;
        _this.dropdown = false;
        _inputService.input = _this;
        return _this;
    }
    MbscInput.prototype.initControl = function () {
        var _this = this;
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Input(this._initElem.nativeElement, options);
        setTimeout(function () {
            _this.instance.refresh();
        });
    };
    MbscInput.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-input',
                    host: {
                        '[class.mbsc-control-ng]': 'controlNg',
                        '[class.mbsc-err]': 'error'
                    },
                    template: "\n        <label\n            [class.mbsc-err]=\"error\" [class.mbsc-select]=\"dropdown\"\n            [class.mbsc-input-box]=\"inputStyle == 'box'\"\n            [class.mbsc-input-outline]=\"inputStyle == 'outline'\"\n            [class.mbsc-label-stacked]=\"labelStyle == 'stacked'\"\n            [class.mbsc-label-inline]=\"labelStyle == 'inline'\"\n            [class.mbsc-label-floating]=\"labelStyle == 'floating'\"\n        >\n            <ng-content></ng-content>\n            <span class=\"mbsc-input-wrap\">\n                <input #initElement [type]=\"type\" [placeholder]=\"placeholder\" [(ngModel)]=\"innerValue\" (blur)=\"onTouch($event)\"\n                    [attr.name]=\"name\"\n                    [attr.data-icon]=\"icon ? icon : null\"\n                    [attr.data-icon-align]=\"iconAlign ? iconAlign : null\"\n                    [attr.data-password-toggle]=\"passwordToggle ? 'true': null\"\n                    [attr.data-icon-show]=\"iconShow ? iconShow : null\"\n                    [attr.data-icon-hide]=\"iconHide ? iconHide : null\"\n                    [attr.data-icon-upload]=\"iconUpload ? iconUpload : null\"\n                    [attr.min]=\"min\"\n                    [attr.max]=\"max\"\n                    [attr.minlength]=\"minlength\"\n                    [attr.maxlength]=\"maxlength\"\n                    [attr.autocomplete]=\"autocomplete\"\n                    [attr.autocapitalize]=\"autocapitalize\"\n                    [attr.autocorrect]=\"autocorrect\"\n                    [attr.spellcheck]=\"spellcheck\"\n                    [attr.autofocus]=\"autofocus\"\n                    [attr.step]=\"step\"\n                    [attr.pattern]=\"pattern\"\n                    [attr.required]=\"required\"\n                    [attr.accept]=\"accept\"\n                    [attr.multiple]=\"multiple\"\n                    [disabled]=\"disabled\"\n                    [readonly]=\"_readonly\" />\n                <span *ngIf=\"dropdown\" class=\"mbsc-select-ic mbsc-ic mbsc-ic-arrow-down5\"></span>\n                <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n            </span>\n        </label>\n    ",
                    providers: [MbscInputService]
                },] },
    ];
    MbscInput.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    MbscInput.propDecorators = {
        'min': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'step': [{ type: Input$1 },],
        'pattern': [{ type: Input$1 },],
        'accept': [{ type: Input$1 },],
        'multiple': [{ type: Input$1 },],
        'controlNg': [{ type: Input$1 },],
        'dropdown': [{ type: Input$1 },],
    };
    return MbscInput;
}(MbscInputBase));
var MbscInputModule = (function () {
    function MbscInputModule() {
    }
    MbscInputModule.decorators = [
        { type: NgModule, args: [{
                    imports: [FormsModule, CommonModule, MbscBaseModule],
                    declarations: [MbscInput, MbscInputBase, MbscFormBase, MbscFormValueBase],
                    exports: [MbscInput]
                },] },
    ];
    MbscInputModule.ctorParameters = function () { return []; };
    return MbscInputModule;
}());

var Button =
/*#__PURE__*/
function (_FormControl) {
  _inheritsLoose(Button, _FormControl);

  function Button(elm, settings) {
    var _this;

    _this = _FormControl.call(this, elm, settings) || this;
    var $elm = _this._$elm;
    var hasIcon = $elm.attr('data-icon');
    $elm.addClass('mbsc-btn mbsc-no-touch').find('.mbsc-btn-ic').remove();

    if (hasIcon) {
      $elm.prepend('<span class="mbsc-btn-ic mbsc-ic mbsc-ic-' + hasIcon + '"></span>');

      if ($elm.text() === "") {
        $elm.addClass('mbsc-btn-icon-only');
      }
    }

    _this._$rippleElm = $elm;
    return _this;
  }

  var _proto = Button.prototype;

  _proto.getClassElm = function getClassElm() {
    return this._$elm;
  };

  return Button;
}(FormControl); // Init mbsc-button elements on page load

autoInit('[mbsc-button]', Button);

var CheckBox =
/*#__PURE__*/
function (_FormControl) {
  _inheritsLoose(CheckBox, _FormControl);

  function CheckBox(elm, settings) {
    var _this;

    _this = _FormControl.call(this, elm, settings) || this;

    _this._$parent.prepend(_this._$elm).addClass('mbsc-checkbox mbsc-control-w').find('.mbsc-checkbox-box').remove();

    _this._$elm.after('<span class="mbsc-checkbox-box"></span>');

    return _this;
  }

  return CheckBox;
}(FormControl); // Init mbsc-checkbox elements on page load

autoInit('[mbsc-checkbox]', CheckBox);

var Radio =
/*#__PURE__*/
function (_FormControl) {
  _inheritsLoose(Radio, _FormControl);

  function Radio(elm, settings) {
    var _this;

    _this = _FormControl.call(this, elm, settings) || this;

    _this._$parent.addClass('mbsc-radio mbsc-control-w').find('.mbsc-radio-box').remove();

    _this._$elm.after('<span class="mbsc-radio-box"><span></span></span>');

    return _this;
  }

  return Radio;
}(FormControl); // Init mbsc-radio elements on page load

autoInit('[mbsc-radio]', Radio);

var Select =
/*#__PURE__*/
function (_Input) {
  _inheritsLoose(Select, _Input);

  function Select(elm, settings) {
    var _this;

    _this = _Input.call(this, elm, settings) || this;
    var $elm = _this._$elm;
    var $parent = _this._$parent;
    var $existing = $parent.find('.mbsc-select-input');
    var $input = $existing.length ? $existing : $$1('<input tabindex="-1" class="mbsc-select-input mbsc-control" readonly>');
    _this._$input = $input;
    _this._delm = $input[0];
    _this._setText = _this._setText.bind(_assertThisInitialized(_this));
    $parent.addClass('mbsc-select' + (_this._$frame ? ' mbsc-select-inline' : ''));
    $elm.after($input);
    $input.after('<span class="mbsc-select-ic mbsc-ic mbsc-ic-arrow-down5"></span>'); // Update dummy input text on change

    $elm.on('change', _this._setText);

    _this._setText();

    return _this;
  }

  var _proto = Select.prototype;

  _proto.destroy = function destroy() {
    _Input.prototype.destroy.call(this);

    this._$parent.find('.mbsc-select-ic').remove();

    this._$elm.off('change', this._setText);
  };

  _proto._setText = function _setText() {
    var elm = this._elm;
    var $elm = $$1(elm); // Check if select and mobiscroll select was not initialized

    if ($elm.is('select') && !$elm.hasClass('mbsc-comp')) {
      this._$input.val(elm.selectedIndex != -1 ? elm.options[elm.selectedIndex].text : '');
    } // Check floating label


    this.refresh();
  };

  return Select;
}(Input); // Init mbsc-select elements on page load

autoInit('[mbsc-dropdown]', Select);

var events$2 = ['change', 'keydown', 'input', 'scroll'];
var sizeDebounce;

function sizeTextAreas() {
  clearTimeout(sizeDebounce);
  sizeDebounce = setTimeout(function () {
    $$1('textarea.mbsc-control').each(function () {
      sizeTextArea(this);
    });
  }, 100);
}

function sizeTextArea(control) {
  var height,
      lineNr,
      line,
      rowNr = $$1(control).attr('rows') || 6;

  if (control.offsetHeight) {
    control.style.height = '';
    line = control.scrollHeight - control.offsetHeight;
    height = control.offsetHeight + (line > 0 ? line : 0);
    lineNr = Math.round(height / 24);

    if (lineNr > rowNr) {
      //control.scrollTop = height;
      height = 24 * rowNr + (height - lineNr * 24);
      $$1(control).addClass('mbsc-textarea-scroll');
    } else {
      $$1(control).removeClass('mbsc-textarea-scroll');
    }

    if (height) {
      control.style.height = height + 'px';
    }
  }
}

function scrollTextArea(elm) {
  var $elm = $$1(elm);

  if (!$elm.hasClass('mbsc-textarea-scroll')) {
    var line = elm.scrollHeight - elm.offsetHeight,
        height = elm.offsetHeight + line,
        lineNr = Math.round(height / 24),
        rowNr = $elm.attr('rows') || 6;

    if (lineNr <= rowNr) {
      elm.scrollTop = 0;
      elm.style.height = height + 'px';
    }
  }
}

if (isBrowser) {
  // Set height of textareas on viewport size changes
  $$1(window).on('resize orientationchange', sizeTextAreas);
}

var TextArea =
/*#__PURE__*/
function (_Input) {
  _inheritsLoose(TextArea, _Input);

  function TextArea(elm, settings) {
    var _this;

    _this = _Input.call(this, elm, settings) || this;

    _this._$parent.addClass('mbsc-textarea');

    events$2.forEach(function (ev) {
      _this._$elm.on(ev, _this._handle);
    });
    sizeTextArea(elm);
    return _this;
  }

  var _proto = TextArea.prototype;

  _proto.destroy = function destroy() {
    var _this2 = this;

    _Input.prototype.destroy.call(this);

    events$2.forEach(function (ev) {
      _this2._$elm.off(ev, _this2._handle);
    });
  };

  _proto.refresh = function refresh() {
    _Input.prototype.refresh.call(this);

    clearTimeout(this._debounce);
    sizeTextArea(this._elm);
  };

  _proto._handle = function _handle(ev) {
    _Input.prototype._handle.call(this, ev);

    switch (ev.type) {
      case 'change':
        sizeTextArea(this._elm);
        break;

      case 'keydown':
      case 'input':
        this._onInput(ev);

        break;

      case 'scroll':
        scrollTextArea(this._elm);
    }
  };

  _proto._onInput = function _onInput() {
    var _this3 = this;

    clearTimeout(this._debounce);
    this._debounce = setTimeout(function () {
      sizeTextArea(_this3._elm);
    }, 100);
  };

  return TextArea;
}(Input);

autoInit('[mbsc-textarea]', TextArea);

var SegmentedItem =
/*#__PURE__*/
function (_FormControl) {
  _inheritsLoose(SegmentedItem, _FormControl);

  function SegmentedItem(elm, settings) {
    var _this;

    _this = _FormControl.call(this, elm, settings) || this;
    var $segmentCont;
    var $segment;
    var $elm = _this._$elm;
    var $parent = _this._$parent;

    if (!$parent.hasClass('mbsc-segmented-item-ready')) {
      $segmentCont = $$1('<div class="mbsc-segmented mbsc-segmented-group mbsc-no-touch"></div>');
      $parent.after($segmentCont);
      $parent.parent().find('input[name="' + $elm.attr('name') + '"]').each(function () {
        var $input = $$1(this);
        $segment = $input.parent().addClass('mbsc-segmented-item mbsc-segmented-item-ready');
        $$1('<span class="mbsc-segmented-content">' + ($input.attr('data-icon') ? '<span class="mbsc-ic mbsc-ic-' + $input.attr('data-icon') + '"></span>' : '') + '</span>').append($segment.contents()).appendTo($segment);
        $segment.prepend($input);
        $segmentCont.append($segment);
      });
    }

    _this._$rippleElm = $elm.next();
    return _this;
  }

  var _proto = SegmentedItem.prototype;

  _proto.getClassElm = function getClassElm() {
    return this._$elm.closest('.mbsc-segmented');
  };

  return SegmentedItem;
}(FormControl); // Init mbsc-segmented elements on page load

autoInit('[mbsc-segmented]', SegmentedItem);

function createStepper($elm, action, delay, isReadOnly, stopProp, ripple) {
  var $btn,
      changed,
      index,
      running,
      source,
      startX,
      startY,
      step,
      timer,
      check = isReadOnly || noop;

  function onBtnStart(ev) {
    var proceed;
    $btn = $$1(ev.currentTarget);
    step = +$btn.attr('data-step');
    index = +$btn.attr('data-index');
    changed = true;

    if (stopProp) {
      ev.stopPropagation();
    }

    if (ev.type == 'touchstart') {
      $btn.closest('.mbsc-no-touch').removeClass('mbsc-no-touch');
    }

    if (ev.type == 'mousedown') {
      // Prevent focus
      ev.preventDefault();
    }

    if (ev.type != 'keydown') {
      //e.preventDefault();
      startX = getCoord(ev, 'X');
      startY = getCoord(ev, 'Y');
      proceed = testTouch(ev, this);
    } else {
      proceed = ev.keyCode === 32;
    }

    if (!running && proceed && !$btn.hasClass('mbsc-disabled')) {
      if (start(index, step, ev)) {
        $btn.addClass('mbsc-active');

        if (ripple) {
          ripple.addRipple($btn.find('.mbsc-segmented-content'), ev);
        }
      }

      if (ev.type == 'mousedown') {
        $$1(document).on('mousemove', onBtnMove).on('mouseup', onBtnEnd);
      }
    }
  }

  function onBtnMove(ev) {
    if (Math.abs(startX - getCoord(ev, 'X')) > 7 || Math.abs(startY - getCoord(ev, 'Y')) > 7) {
      changed = true;
      stop();
    }
  }

  function onBtnEnd(ev) {
    if (ev.type == 'touchend') {
      // Prevents iOS scroll on double tap
      ev.preventDefault();
    }

    stop();

    if (ev.type == 'mouseup') {
      $$1(document).off('mousemove', onBtnMove).off('mouseup', onBtnEnd);
    }
  }

  function stop() {
    running = false;
    clearInterval(timer);

    if ($btn) {
      $btn.removeClass('mbsc-active');

      if (ripple) {
        setTimeout(function () {
          ripple.removeRipple();
        }, 100);
      }
    }
  }

  function start(i, st, ev) {
    if (!running && !check(i)) {
      index = i;
      step = st;
      source = ev;
      running = true;
      changed = false;
      setTimeout(tick, 100);
    }

    return running;
  }

  function tick() {
    if ($btn && $btn.hasClass('mbsc-disabled')) {
      stop();
      return;
    }

    if (running || !changed) {
      changed = true;
      action(index, step, source, tick);
    }

    if (running && delay) {
      clearInterval(timer);
      timer = setInterval(function () {
        action(index, step, source);
      }, delay);
    }
  }

  function destroy() {
    $elm.each(function (i, el) {
      unlisten(el, 'touchstart', onBtnStart, {
        passive: true
      });
      unlisten(el, 'mousedown', onBtnStart);
      unlisten(el, 'keydown', onBtnStart);
      unlisten(el, 'touchmove', onBtnMove, {
        passive: true
      });
      unlisten(el, 'touchend', onBtnEnd);
      unlisten(el, 'touchcancel', onBtnEnd);
      unlisten(el, 'keyup', onBtnEnd);
    });
  }

  $elm.each(function (i, el) {
    listen(el, 'touchstart', onBtnStart, {
      passive: true
    });
    listen(el, 'mousedown', onBtnStart);
    listen(el, 'keydown', onBtnStart);
    listen(el, 'touchmove', onBtnMove, {
      passive: true
    });
    listen(el, 'touchend', onBtnEnd);
    listen(el, 'touchcancel', onBtnEnd);
    listen(el, 'keyup', onBtnEnd);
  });
  return {
    start: start,
    stop: stop,
    destroy: destroy
  };
}

var Stepper = function Stepper(control, settings) {
  var $btnPlus,
      $btnMinus,
      $controls,
      cssClass = '',
      displayValue,
      max,
      min,
      inputStyle,
      ripple,
      scale,
      step,
      stepper,
      s,
      theme,
      val,
      that = this,
      $control = $$1(control),
      ready,
      $parent,
      old = val;

  function onChange() {
    var v;

    if (!control.disabled) {
      v = parseFloat($$1(this).val());
      setValue(isNaN(v) ? val : v);
    }
  }

  function checkDisabled() {
    return control.disabled;
  }

  function stepValue(index, dir) {
    setValue(val + dir * step);
  }

  function setValue(v, fill, change) {
    old = val;

    if (fill === undefined) {
      fill = true;
    }

    if (change === undefined) {
      change = fill;
    }

    val = round(v);
    $controls.removeClass('mbsc-disabled');

    if (fill) {
      $control.val(val);
    }

    if (val == min) {
      $btnMinus.addClass('mbsc-disabled');
    }

    if (val == max) {
      $btnPlus.addClass('mbsc-disabled');
    }

    if (val !== old && change) {
      $control.trigger('change');
    }
  }

  function getAttr(attr, def, str) {
    var v = $control.attr(attr);
    return v === undefined || v === '' ? def : str ? v : +v;
  }

  function round(v) {
    return +Math.min(max, Math.max(Math.round(v / step) * step, min)).toFixed(scale);
  } // Call the parent constructor


  Base.call(this, control, settings, true);
  /* TRIALFUNC */

  that.getVal = function () {
    var v = parseFloat($control.val());
    v = isNaN(v) ? val : v;
    return round(v);
  };

  that.setVal = function (v, fill, change) {
    v = parseFloat(v);
    setValue(isNaN(v) ? val : v, fill, change);
  };

  that._init = function () {
    ready = $control.parent().hasClass('mbsc-stepper');
    $parent = ready ? $control.closest('.mbsc-stepper-cont') : $control.parent();
    s = that.settings;
    min = settings.min === undefined ? getAttr('min', s.min) : settings.min;
    max = settings.max === undefined ? getAttr('max', s.max) : settings.max;
    step = settings.step === undefined ? getAttr('step', s.step) : settings.step;
    scale = Math.abs(step) < 1 ? (step + '').split('.')[1].length : 0;
    inputStyle = settings.inputStyle === undefined ? getAttr('data-input-style', s.inputStyle, true) : settings.inputStyle;
    displayValue = $control.attr('data-val') || s.val;
    val = round(+control.value || 0);
    theme = mobiscroll.themes.form[s.theme];
    ripple = theme && theme.addRipple ? theme : null;

    if (!ready) {
      $parent.addClass('mbsc-stepper-cont mbsc-no-touch mbsc-control-w').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '').append('<span class="mbsc-segmented mbsc-stepper' + '"></span>').find('.mbsc-stepper').append('<span class="mbsc-segmented-item mbsc-stepper-control mbsc-stepper-minus ' + (val == min ? 'mbsc-disabled' : '') + '" data-step="-1" tabindex="0"><span class="mbsc-segmented-content"><span class="mbsc-ic mbsc-ic-minus"></span></span></span>').append('<span class="mbsc-segmented-item mbsc-stepper-control mbsc-stepper-plus ' + (val == max ? 'mbsc-disabled' : '') + '"  data-step="1" tabindex="0"><span class="mbsc-segmented-content"> <span class="mbsc-ic mbsc-ic-plus"></span></span></span>').prepend($control);
    }

    if (cssClass) {
      $parent.removeClass(cssClass).find('.mbsc-segmented').removeClass(cssClass);
    }

    cssClass = 'mbsc-' + s.theme + (theme.baseTheme ? ' mbsc-' + theme.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');
    $parent.addClass(cssClass).find('.mbsc-segmented').addClass(cssClass);
    $btnMinus = $$1('.mbsc-stepper-minus', $parent);
    $btnPlus = $$1('.mbsc-stepper-plus', $parent);
    $controls = $$1('.mbsc-stepper-control', $parent);

    if (!ready) {
      if (displayValue == 'left') {
        $parent.addClass('mbsc-stepper-val-left');
        $control.after('<span class="mbsc-segmented-item"><span class="mbsc-segmented-content"></span></span>');
      } else if (displayValue == 'right') {
        $parent.addClass('mbsc-stepper-val-right');
        $btnPlus.after('<span class="mbsc-segmented-item"><span class="mbsc-segmented-content"></span></span>');
      } else {
        $btnMinus.after('<span class="mbsc-segmented-item"><span class="mbsc-segmented-content mbsc-stepper-val"></span></span>');
      }
    }

    if (!stepper) {
      $control.on('change', onChange);
      stepper = createStepper($controls, stepValue, 150, checkDisabled, false, ripple);
    }

    $control.val(val).attr('data-role', 'stepper').attr('min', min).attr('max', max).attr('step', step).addClass('mbsc-control');
    control.mbscInst = that;
  };

  that._destroy = function () {
    $control.removeClass('mbsc-control').off('change', onChange);
    stepper.destroy();
    delete control.mbscInst;
  };

  that.init();
};
Stepper.prototype = {
  _class: 'stepper',
  _hasDef: true,
  _hasTheme: true,
  _hasLang: true,
  _defaults: {
    min: 0,
    max: 100,
    step: 1
  }
};
classes.Stepper = Stepper; // Init mbsc-stepper elements on page load

autoInit('[mbsc-stepper]', Stepper);

var ProgressBase = function ProgressBase(elm, settings, inherit) {
  var $elm,
      $parent,
      cssClass,
      s,
      that = this; // Call the parent constructor

  Base.call(this, elm, settings, true);
  that.__init = noop;
  that.__destroy = noop;

  that._init = function () {
    var wasInit;
    s = that.settings;
    $elm = $$1(elm); // Check if the element was already initialized

    wasInit = !!$parent;
    $parent = $elm.parent();
    $parent = $parent.hasClass('mbsc-input-wrap') ? $parent.parent() : $parent;
    that._$parent = $parent;

    if (cssClass) {
      $parent.removeClass(cssClass);
    }

    cssClass = that._css + ' mbsc-progress-w mbsc-control-w ' + getCssClass(s);
    $parent.addClass(cssClass);
    $elm.addClass('mbsc-control');

    that.__init();

    if (!wasInit) {
      that._attachChange();
    } // Show initial value


    that.refresh();
    elm.mbscInst = that;
  };

  that._destroy = function () {
    that.__destroy();

    $parent.removeClass(cssClass);
    $elm.removeClass('mbsc-control');
    delete elm.mbscInst;
  };

  if (!inherit) {
    that.init();
  }
};

var SliderBase = function SliderBase(elm, settings, inherit) {
  var $elm,
      $handle,
      $handleCont,
      $handles,
      $listeners,
      $parent,
      $track,
      action,
      base,
      changed,
      diffX,
      diffY,
      diff,
      endX,
      endY,
      handleIndex,
      isHover,
      isPressed,
      isRtl,
      live,
      max,
      min,
      moved,
      multiple,
      oldValue,
      step,
      s,
      scale,
      startX,
      startY,
      stepDecimal,
      timer,
      totalWidth,
      value,
      that = this,
      lastUpdate = new Date();

  function onStart(ev) {
    if (ev.type === 'mousedown') {
      ev.preventDefault();
    }

    if (testTouch(ev, this) && (!action || isHover) && !elm.disabled && !elm.readOnly
    /* TRIALCOND */
    ) {
        if (s.stopProp) {
          ev.stopPropagation();
        }

        action = true;
        moved = false;
        changed = false;
        startX = getCoord(ev, 'X');
        startY = getCoord(ev, 'Y');
        endX = startX;
        $track.removeClass('mbsc-progress-anim');
        $handle = multiple ? $$1('.mbsc-slider-handle', this) : $handles;

        if ($handleCont) {
          $handleCont.removeClass('mbsc-handle-curr');
        }

        $handleCont = $handle.parent().addClass('mbsc-active mbsc-handle-curr');
        $elm.addClass('mbsc-active');
        handleIndex = +$handle.attr('data-index');
        totalWidth = $track[0].offsetWidth;
        diff = $track[0].getBoundingClientRect().left;

        if (ev.type === 'mousedown') {
          isPressed = true;
          $$1(document).on('mousemove', onMove).on('mouseup', onEnd);
        }

        if (ev.type === 'mouseenter') {
          isHover = true;
          $$1(document).on('mousemove', onMove);
        }
      }
  }

  function onMove(ev) {
    if (action) {
      endX = getCoord(ev, 'X');
      endY = getCoord(ev, 'Y');
      diffX = endX - startX;
      diffY = endY - startY;

      if (Math.abs(diffX) > 5) {
        moved = true;
      }

      if (moved || isPressed || isHover) {
        if (Math.abs(lastUpdate - new Date()) > 50) {
          lastUpdate = new Date();
          updateSlider(endX, s.round, live && (!isHover || isPressed));
        }
      }

      if (moved) {
        ev.preventDefault();
      } else if (Math.abs(diffY) > 7 && ev.type == 'touchmove') {
        cleanUp();
      }
    }
  }

  function onEnd(ev) {
    if (action) {
      ev.preventDefault();

      if (!multiple) {
        $track.addClass('mbsc-progress-anim');
      }

      if (isHover && !isPressed) {
        updateValue(value[handleIndex], handleIndex, false, false, true);
      } else {
        updateSlider(endX, true, true);
      }

      if (!moved && !changed) {
        if (ev.type == 'touchend') {
          // Prevent ghost click
          preventClick();
        }

        that._onTap(value[handleIndex]);
      }

      if (ev.type == 'mouseup') {
        isPressed = false;
      }

      if (ev.type == 'mouseleave') {
        isHover = false;
      }

      if (!isHover) {
        cleanUp();
      }
    }
  }

  function onCancel() {
    if (action) {
      cleanUp();
    }
  }

  function onChange() {
    var v = that._readValue($$1(this)),
        i = +$$1(this).attr('data-index');

    if (v !== value[i]) {
      value[i] = v;
      oldValue[i] = v;
      updateValue(v, i);
    }
  }

  function onClick(ev) {
    // Prevent propagating click to label
    ev.stopPropagation();
  }

  function onLabelClick(ev) {
    // Prevent change on label click for swithes
    ev.preventDefault();
  }

  function onKeyDown(ev) {
    var dir;

    if (!elm.disabled) {
      switch (ev.keyCode) {
        case 38:
        case 39:
          dir = 1;
          break;

        case 40:
        case 37:
          dir = -1;
          break;
      }

      if (dir) {
        ev.preventDefault();

        if (!timer) {
          handleIndex = +$$1(this).attr('data-index');
          updateValue(value[handleIndex] + step * dir, handleIndex, true);
          timer = setInterval(function () {
            updateValue(value[handleIndex] + step * dir, handleIndex, true);
          }, 200);
        }
      }
    }
  }

  function onKeyUp(ev) {
    ev.preventDefault();
    clearInterval(timer);
    timer = null;
  }

  function cleanUp() {
    action = false;
    $handleCont.removeClass('mbsc-active');
    $elm.removeClass('mbsc-active'); // Detach document events

    $$1(document).off('mousemove', onMove).off('mouseup', onEnd);
  }

  function updateSlider(pos, round, fill) {
    var percent = round ? Math.min(Math[that._rounding || 'round'](Math.max((pos - diff) * 100 / totalWidth, 0) / scale / step) * step * 100 / (max - min + base), 100) : Math.max(0, Math.min((pos - diff) * 100 / totalWidth, 100));

    if (isRtl) {
      percent = 100 - percent;
    }

    updateValue(Math.round((min - base + percent / scale) * stepDecimal) / stepDecimal, handleIndex, fill, percent);
  }

  function updateValue(v, index, fill, percent, refresh, change) {
    var $handle = $handles.eq(index),
        $handleCont = $handle.parent();
    v = Math.min(max, Math.max(v, min));

    if (change === undefined) {
      change = fill;
    }

    if (that._update) {
      v = that._update(v, value, index, percent, multiple, refresh, $handleCont);
    } else {
      $handleCont.css({
        left: isRtl ? 'auto' : (percent || getPercent(v, min, max)) + '%',
        right: isRtl ? (percent || getPercent(v, min, max)) + '%' : 'auto'
      });
    }

    if (v > min) {
      $handleCont.removeClass('mbsc-slider-start');
    } else if (value[index] > min || refresh) {
      $handleCont.addClass('mbsc-slider-start');
    } // Store new value


    if (fill) {
      value[index] = v;
    } // Check if value changed


    if (fill && oldValue[index] != v) {
      changed = true;
      oldValue[index] = v; // Set new value to the input

      that._fillValue(v, index, change);
    }

    $handle.attr('aria-valuenow', v);
  } // Call the parent constructor


  ProgressBase.call(this, elm, settings, true);
  that._onTap = noop;
  that.___init = noop;
  that.___destroy = noop;

  that._attachChange = function () {
    $elm.on(s.changeEvent, onChange);
  };

  that.__init = function () {
    var wasInit;

    if ($handles) {
      wasInit = true;
      $handles.parent().remove();
    }

    that.___init();

    $parent = that._$parent;
    $track = that._$track;
    $elm = $parent.find('input');
    s = that.settings;
    min = that._min;
    max = that._max;
    base = that._base || 0;
    step = that._step;
    live = that._live;
    stepDecimal = step % 1 !== 0 ? 100 / (+(step % 1).toFixed(2) * 100) : 1;
    scale = 100 / (max - min + base) || 100;
    multiple = $elm.length > 1;
    isRtl = s.rtl;
    value = [];
    oldValue = []; // Read values

    $elm.each(function (i) {
      value[i] = that._readValue($$1(this));
      $$1(this).attr('data-index', i);
    });
    $handles = $parent.find('.mbsc-slider-handle');
    $listeners = $parent.find(multiple ? '.mbsc-slider-handle-cont' : '.mbsc-progress-cont'); // Attach events

    $handles.on('keydown', onKeyDown).on('keyup', onKeyUp).on('blur', onKeyUp);
    $listeners.each(function (i, listener) {
      listen(listener, 'touchstart', onStart, {
        passive: true
      });
      listen(listener, 'mousedown', onStart);
      listen(listener, 'touchend', onEnd);
      listen(listener, 'touchcancel', onEnd);
      listen(listener, 'pointercancel', onCancel);

      if (s.hover) {
        listen(listener, 'mouseenter', onStart);
        listen(listener, 'mouseleave', onEnd);
      }
    });

    if (!wasInit) {
      $elm.on('click', onClick);
      $parent.on('click', onLabelClick); // Attach to document to avoid non-passive listener warnings

      listen(document, 'touchmove', onMove, {
        passive: false
      });
    }
  };

  that.__destroy = function () {
    $parent.off('click', onLabelClick);
    $elm.off(s.changeEvent, onChange).off('click', onClick);
    $handles.off('keydown', onKeyDown).off('keyup', onKeyUp).off('blur', onKeyUp);
    $listeners.each(function (i, listener) {
      unlisten(listener, 'touchstart', onStart, {
        passive: true
      });
      unlisten(listener, 'mousedown', onStart);
      unlisten(listener, 'touchend', onEnd);
      unlisten(listener, 'touchcancel', onEnd);
      unlisten(listener, 'pointercancel', onCancel);
      unlisten(listener, 'mouseenter', onStart);
      unlisten(listener, 'mouseleave', onEnd);
      unlisten(document, 'touchmove', onMove, {
        passive: false
      });
    });

    that.___destroy();
  };

  that.refresh = function () {
    $elm.each(function (i) {
      updateValue(that._readValue($$1(this)), i, true, false, true, false);
    });
  };

  that.getVal = function () {
    return multiple ? value.slice(0) : value[0];
  };

  that.setVal = that._setVal = function (val, fill, change) {
    if (!$$1.isArray(val)) {
      val = [val];
    }

    $$1.each(val, function (i, v) {
      value[i] = v;
    });
    $$1.each(val, function (i, v) {
      updateValue(v, i, true, false, true, change);
    });
  };

  if (!inherit) {
    that.init();
  }
};

var Switch = function Switch(elm, settings) {
  var $elm,
      $parent,
      s,
      formControl,
      that = this;
  settings = settings || {};
  extend$1(settings, {
    changeEvent: 'click',
    round: false
  }); // Call the parent constructor

  SliderBase.call(this, elm, settings, true);

  that._readValue = function () {
    return elm.checked ? 1 : 0;
  };

  that._fillValue = function (v, index, change) {
    $elm.prop('checked', !!v);

    if (change) {
      $elm.trigger('change');
    }
  };

  that._onTap = function (v) {
    that._setVal(v ? 0 : 1);
  };

  that.___init = function () {
    s = that.settings;
    $elm = $$1(elm);
    $parent = $elm.parent();
    $parent.find('.mbsc-switch-track').remove();
    $parent.prepend($elm);
    $elm.attr('data-role', 'switch').after('<span class="mbsc-progress-cont mbsc-switch-track">' + '<span class="mbsc-progress-track mbsc-progress-anim">' + '<span class="mbsc-slider-handle-cont">' + '<span class="mbsc-slider-handle mbsc-switch-handle" data-index="0">' + '<span class="mbsc-switch-txt-off">' + s.offText + '</span>' + '<span class="mbsc-switch-txt-on">' + s.onText + '</span>' + '</span></span></span></span>');

    if (formControl) {
      formControl.destroy();
    }

    formControl = new FormControl(elm, s);
    that._$track = $parent.find('.mbsc-progress-track');
    that._min = 0;
    that._max = 1;
    that._step = 1;
  };

  that.___destroy = function () {
    formControl.destroy();
  };

  that.getVal = function () {
    return elm.checked;
  };

  that.setVal = function (val, fill, change) {
    that._setVal(val ? 1 : 0, fill, change);
  };

  that.init();
};
Switch.prototype = {
  _class: 'switch',
  _css: 'mbsc-switch',
  _hasTheme: true,
  _hasLang: true,
  _hasDef: true,
  _defaults: {
    stopProp: true,
    offText: 'Off',
    onText: 'On'
  }
};
classes.Switch = Switch; // Init mbsc-switch elements on page load

autoInit('[mbsc-switch]', Switch);

// eslint-disable-next-line no-unused-vars
var Progress = function Progress(elm, settings, inherit) {
  var $display,
      $elm,
      $parent,
      $progress,
      $target,
      $track,
      min,
      max,
      inputStyle,
      labelStyle,
      s,
      template,
      value,
      valueText,
      that = this;

  function onChange() {
    var v = getAttr('value', min);

    if (v !== value) {
      updateValue(v);
    }
  }

  function getAttr(attr, def, str) {
    var v = $elm.attr(attr);
    return v === undefined || v === '' ? def : str ? v : +v;
  }

  function updateValue(v, refresh, fill, change) {
    v =
    /* TRIALCONDREV */
    Math.min(max, Math.max(v, min));
    $progress.css('width', (v - min) * 100 / (max - min) + '%');

    if (fill === undefined) {
      fill = true;
    }

    if (change === undefined) {
      change = fill;
    }

    if (v !== value || refresh) {
      // Display value
      that._display(v);
    }

    if (v !== value) {
      // Set new value
      value = v; // Put new value in the progress element

      if (fill) {
        $elm.attr('value', value);
      } // Trigger change on the element


      if (change) {
        $elm.trigger('change');
      }
    }
  } // Call the parent constructor


  ProgressBase.call(this, elm, settings, true);

  that._display = function (v) {
    valueText = template && s.returnAffix ? template.replace(/\{value\}/, v).replace(/\{max\}/, max) : v;

    if ($target) {
      $target.html(valueText);
    }

    if ($display) {
      $display.html(valueText);
    }
  };

  that._attachChange = function () {
    $elm.on('change', onChange);
  };

  that.__init = function () {
    var displayValue, i, stepLabels, wasInit;
    s = that.settings;
    $elm = $$1(elm); // Check if the element was already initialized

    wasInit = !!$parent;
    $parent = that._$parent; // Read settings from data attributes or settings object

    min = that._min = settings.min === undefined ? getAttr('min', s.min) : settings.min;
    max = that._max = settings.max === undefined ? getAttr('max', s.max) : settings.max;
    inputStyle = settings.inputStyle === undefined ? getAttr('data-input-style', s.inputStyle, true) : settings.inputStyle;
    labelStyle = settings.labelStyle === undefined ? getAttr('data-label-style', s.labelStyle, true) : settings.labelStyle;
    value = getAttr('value', min);
    displayValue = $elm.attr('data-val') || s.val;
    stepLabels = $elm.attr('data-step-labels');
    stepLabels = stepLabels ? JSON.parse(stepLabels) : s.stepLabels;
    template = $elm.attr('data-template') || (max == 100 && !s.template ? '{value}%' : s.template);

    if (!wasInit) {
      wrapLabel($parent, null, inputStyle, labelStyle, elm);
      addIcon($elm); // Generate track and progress

      $parent.find('.mbsc-input-wrap').append('<span class="mbsc-progress-cont"><span class="mbsc-progress-track mbsc-progress-anim"><span class="mbsc-progress-bar"></span></span></span>');
      $progress = that._$progress = $parent.find('.mbsc-progress-bar');
      $track = that._$track = $parent.find('.mbsc-progress-track');
    } else {
      if (displayValue) {
        $display.remove();
        $parent.removeClass('mbsc-progress-value-' + (displayValue == 'right' ? 'right' : 'left'));
      }

      if (stepLabels) {
        $$1('.mbsc-progress-step-label', $track).remove();
      }
    } // Set attributes


    $elm.attr('min', min).attr('max', max); // Generate value container on left or right side

    if (displayValue) {
      $display = $$1('<span class="mbsc-progress-value"></span>');
      $parent.addClass('mbsc-progress-value-' + (displayValue == 'right' ? 'right' : 'left')).find('.mbsc-input-wrap').append($display);
    } // Generate step labels


    if (stepLabels) {
      for (i = 0; i < stepLabels.length; ++i) {
        $track.append('<span class="mbsc-progress-step-label" style="' + (s.rtl ? 'right' : 'left') + ': ' + (stepLabels[i] - min) * 100 / (max - min) + '%" >' + stepLabels[i] + '</span>');
      }
    }

    $target = $$1($elm.attr('data-target') || s.target);
  };

  that.__destroy = function () {
    $parent.removeClass('mbsc-ic-left mbsc-ic-right').find('.mbsc-progress-cont').remove();
    $parent.find('.mbsc-input-ic').remove();
    $elm.off('change', onChange);
  };

  that.refresh = function () {
    updateValue(getAttr('value', min), true, false);
  };

  that.getVal = function () {
    return value;
  };

  that.setVal = function (v, fill, change) {
    updateValue(v, true, fill, change);
  };

  if (!inherit) {
    that.init();
  }
};
Progress.prototype = {
  _class: 'progress',
  _css: 'mbsc-progress',
  _hasTheme: true,
  _hasLang: true,
  _hasDef: true,
  _defaults: {
    min: 0,
    max: 100,
    returnAffix: true
  }
};
classes.Progress = Progress; // Init mbsc-progress elements on page load

autoInit('[mbsc-progress]', Progress);

var Slider = function Slider(elm, settings, inherit) {
  var $elm,
      $parent,
      $progress,
      $tooltips,
      $track,
      hasProgress,
      hasTooltip,
      isRange,
      isRtl,
      max,
      min,
      step,
      s,
      that = this; // Call the parent constructor

  Progress.call(this, elm, settings, true);
  var progressInit = that.__init,
      progressDestroy = that.__destroy;
  SliderBase.call(this, elm, settings, true);
  var sliderInit = that.__init,
      sliderDestroy = that.__destroy; // ---

  that.__init = function () {
    progressInit();
    sliderInit();
  };

  that.__destroy = function () {
    progressDestroy();
    sliderDestroy();
  };

  that._update = function (v, value, index, percent, multiple, refresh, $handleCont) {
    if (isRange) {
      if (index === 0) {
        v = Math.min(v, value[1]);
        $progress.css({
          width: getPercent(value[1], min, max) - getPercent(v, min, max) + '%',
          left: isRtl ? 'auto' : getPercent(v, min, max) + '%',
          right: isRtl ? getPercent(v, min, max) + '%' : 'auto'
        });
      } else {
        v = Math.max(v, value[0]);
        $progress.css({
          width: getPercent(v, min, max) - getPercent(value[0], min, max) + '%'
        });
      }
    } else if (multiple || !hasProgress) {
      $handleCont.css({
        left: isRtl ? 'auto' : (percent || getPercent(v, min, max)) + '%',
        right: isRtl ? (percent || getPercent(v, min, max)) + '%' : 'auto'
      });
    } else {
      $progress.css('width', (percent || getPercent(v, min, max)) + '%');
    }

    if (hasTooltip) {
      $tooltips.eq(index).html(v);
    } // Display value in the specified container(s)


    if (!multiple && (value[index] != v || refresh)) {
      that._display(v);
    } // Return validated value


    return v;
  };

  that._readValue = function ($elm) {
    return +$elm.val();
  };

  that._fillValue = function (v, index, change) {
    $elm.eq(index).val(v);

    if (change) {
      $elm.eq(index).trigger('change');
    }
  };

  that._markupReady = function () {
    var i, stepNr;

    if (hasTooltip) {
      $parent.addClass('mbsc-slider-has-tooltip');
    } // Generate step marks


    if (step != 1) {
      stepNr = (max - min) / step;

      for (i = 0; i <= stepNr; ++i) {
        $track.append('<span class="mbsc-slider-step" style="' + (isRtl ? 'right' : 'left') + ':' + 100 / stepNr * i + '%"></span>');
      }
    } // Generate slider handles


    $elm.each(function (i, elm) {
      var value = +elm.value;

      if (elm.type == 'range') {
        // Set min / max / step properties for all inputs
        $$1(elm).attr('min', min).attr('max', max).attr('step', step);
      }

      (hasProgress ? $progress : $track).append('<span class="mbsc-slider-handle-cont' + (isRange && !i ? ' mbsc-slider-handle-left' : '') + (isRange && !i && value > (max - min) / 2 ? ' mbsc-handle-curr' : '') + '">' + '<span tabindex="0" class="mbsc-slider-handle" aria-valuemin="' + min + '" aria-valuemax="' + max + '" data-index="' + i + '"></span>' + (hasTooltip ? '<span class="mbsc-slider-tooltip"></span>' : '') + '</span>');
    });
    $tooltips = $parent.find('.mbsc-slider-tooltip');
  };

  that.___init = function () {
    if ($parent) {
      $parent.removeClass('mbsc-slider-has-tooltip');

      if (step != 1) {
        $$1('.mbsc-slider-step', $track).remove();
      }
    }

    $parent = that._$parent;
    $track = that._$track;
    $progress = that._$progress;
    $elm = $parent.find('input');
    s = that.settings;
    min = that._min;
    max = that._max;
    that._step = step = settings.step === undefined ? +$elm.attr('step') || s.step : settings.step;
    that._live = getBoolAttr('data-live', s.live, $elm);
    hasTooltip = getBoolAttr('data-tooltip', s.tooltip, $elm);
    hasProgress = getBoolAttr('data-highlight', s.highlight, $elm) && $elm.length < 3;
    isRange = hasProgress && $elm.length == 2;
    isRtl = s.rtl;

    that._markupReady();
  };

  if (!inherit) {
    that.init();
  }
};
Slider.prototype = {
  _class: 'progress',
  _css: 'mbsc-progress mbsc-slider',
  _hasTheme: true,
  _hasLang: true,
  _hasDef: true,
  _defaults: {
    changeEvent: 'change',
    stopProp: true,
    min: 0,
    max: 100,
    step: 1,
    live: true,
    highlight: true,
    round: true,
    returnAffix: true
  }
};
classes.Slider = Slider; // Init mbsc-slider elements on page load

autoInit('[mbsc-slider]', Slider);

var Rating = function Rating(elm, settings, inherit) {
  var $progress,
      $track,
      max,
      min,
      empty,
      filled,
      s,
      that = this,
      $elm = $$1(elm); // Call the parent constructor

  Slider.call(this, elm, settings, true);

  that._update = function (v, value, index, percent, multiple, refresh) {
    $progress.css('width', getPercent(v, 0, max) + '%'); // Display value in the specified container(s)

    if (!multiple && (value[index] != v || refresh)) {
      that._display(v);
    } // Return validated value


    return v;
  };

  that._markupReady = function () {
    var i,
        emptyString = '',
        filledString = '';
    $track = that._$track;
    $progress = that._$progress;
    s = that.settings;
    min = that._min;
    max = that._max;
    that._base = min;
    that._rounding = s.rtl ? 'floor' : 'ceil';
    empty = $elm.attr('data-empty') || s.empty;
    filled = $elm.attr('data-filled') || s.filled;

    for (i = 0; i < max; ++i) {
      emptyString += '<span class="mbsc-ic mbsc-ic-' + empty + '"></span>';
      filledString += '<span class="mbsc-ic mbsc-ic-' + filled + '"></span>';
    }

    $track.html(emptyString);
    $track.append($progress);
    $progress.html(filledString);
    $track.append('<span class="mbsc-rating-handle-cont' + '">' + '<span tabindex="0" class="mbsc-slider-handle" aria-valuemin="' + min + '" aria-valuemax="' + max + '" data-index="0"></span>' + '</span>');
  };

  if (!inherit) {
    that.init();
  }
};
Rating.prototype = {
  _class: 'progress',
  _css: 'mbsc-progress mbsc-rating',
  _hasTheme: true,
  _hasLang: true,
  _hasDef: true,
  _defaults: {
    changeEvent: 'change',
    stopProp: true,
    min: 1,
    max: 5,
    step: 1,
    live: true,
    round: true,
    hover: true,
    highlight: true,
    returnAffix: true,
    empty: 'star',
    filled: 'star3'
  }
};
classes.Rating = Rating; // Init mbsc-rating elements on page load

autoInit('[mbsc-rating]', Rating);

var nr = 1;
var CollapsibleBase =
/*#__PURE__*/
function () {
  function CollapsibleBase(elm, settings) {
    var _this = this;

    var content;
    var $header;
    var $content;
    var $elm = $$1(elm);
    this.settings = settings;
    this._isOpen = settings.isOpen || false;
    $elm.addClass('mbsc-collapsible ' + (this._isOpen ? 'mbsc-collapsible-open' : ''));

    if ($elm.hasClass('mbsc-card')) {
      // card enhance
      $header = $elm.find('.mbsc-card-header').eq(0).addClass('mbsc-collapsible-header');
      $content = $elm.find('.mbsc-card-content').eq(0).addClass('mbsc-collapsible-content');
    } else if ($elm.hasClass('mbsc-form-group') || $elm.hasClass('mbsc-form-group-inset')) {
      // form group enhance
      $header = $elm.find('.mbsc-form-group-title').eq(0).addClass('mbsc-collapsible-header');
      $content = $elm.find('.mbsc-form-group-content').eq(0).addClass('mbsc-collapsible-content');
    } else {
      // if it is used independently
      $header = $elm.find('.mbsc-collapsible-header').eq(0);
      $content = $elm.find('.mbsc-collapsible-content').eq(0);
    }

    content = $content[0];

    if (content && !content.id) {
      content.id = 'mbsc-collapsible-' + nr++;
    }

    if ($header.length && content) {
      var $collapsibleIcon = $$1('<span class="mbsc-collapsible-icon mbsc-ic mbsc-ic-arrow-down5"></span>');
      tap(this, $header, function () {
        _this.collapse();
      });
      $header.attr('role', 'button').attr('aria-expanded', this._isOpen).attr('aria-controls', content.id).attr('tabindex', '0').on('mousedown', this.onMouseDown).on('keydown', this.onKeyDown).append($collapsibleIcon);
    }

    elm.mbscInst = this;
    this._$header = $header;
    this._$content = $content;
    this._$elm = $elm;
    this._$accordionParent = $elm.parent('[mbsc-accordion], mbsc-accordion, .mbsc-accordion');
    this.show = this.show.bind(this);
    this.hide = this.hide.bind(this);
    this.toggle = this.toggle.bind(this);
    this.onKeyDown = this.onKeyDown.bind(this);
    this.onMouseDown = this.onMouseDown.bind(this);
  }

  var _proto = CollapsibleBase.prototype;

  _proto.collapse = function collapse(show) {
    var $elm = this._$elm;
    var $content = this._$content;

    var removeHeight = function removeHeight() {
      $content.off('transitionend', removeHeight).css('height', '');
    };

    if (show === undefined) {
      show = !this._isOpen;
    }

    if (show && this._isOpen || !show && !this._isOpen || !$content.length) {
      return;
    }

    if (show) {
      if (hasTransition) {
        $content.on('transitionend', removeHeight).css('height', $content[0].scrollHeight);
      }

      $elm.addClass('mbsc-collapsible-open');
    } else {
      if (hasTransition) {
        $content.css('height', getComputedStyle($content[0]).height);
      }

      setTimeout(function () {
        $content.css('height', 0);
        $elm.removeClass('mbsc-collapsible-open');
      }, 50);
    }

    if (show && this._$accordionParent) {
      this._$accordionParent.find('.mbsc-collapsible-open').each(function () {
        if (this !== $elm[0]) {
          this.mbscInst.hide();
        }
      });
    }

    this._isOpen = show;

    this._$header.attr('aria-expanded', this._isOpen);
  };

  _proto.show = function show() {
    this.collapse(true);
  };

  _proto.hide = function hide() {
    this.collapse(false);
  };

  _proto.toggle = function toggle() {
    this.collapse();
  };

  _proto.destroy = function destroy() {
    this._$elm.removeClass('mbsc-collapsible mbsc-collapsible-open');

    this._$content.removeClass('mbsc-collapsible-content');

    this._$header.removeClass('mbsc-collapsible-header').off('mousedown', this.onMouseDown).off('keydown', this.onKeyDown).find('.mbsc-collapsible-icon').remove();

    tapOff(this._$header);
  };

  _proto.onKeyDown = function onKeyDown(ev) {
    if (ev.which === 32 || ev.keyCode == 13) {
      //space or enter 
      ev.preventDefault();
      this.collapse();
    }
  };

  _proto.onMouseDown = function onMouseDown(ev) {
    // prevent focus on mouse down
    ev.preventDefault();
  };

  return CollapsibleBase;
}();
classes.CollapsibleBase = CollapsibleBase;

var id$1 = 0;

function initControls($ctx, controls, s, shallow) {
  $$1('input,select,textarea,progress,button', $ctx).each(function () {
    var control = this,
        $control = $$1(control),
        //$parent = $control.parent(),
    type = getControlType($control); // Skip elements with data-enhance="false"

    if ($control.attr('data-enhance') != 'false'
    /* TRIALCOND */
    ) {
        if ($control.hasClass('mbsc-control')) {
          if (control.mbscInst) {
            control.mbscInst.option({
              theme: s.theme,
              lang: s.lang,
              rtl: s.rtl,
              onText: s.onText,
              offText: s.offText,
              stopProp: s.stopProp
            });
          }
        } else {
          if (!control.id) {
            control.id = 'mbsc-form-control-' + ++id$1;
          }

          switch (type) {
            case 'button':
            case 'submit':
              controls[control.id] = new Button(control, {
                theme: s.theme,
                rtl: s.rtl,
                tap: s.tap
              });
              break;

            case 'switch':
              controls[control.id] = new Switch(control, {
                theme: s.theme,
                lang: s.lang,
                rtl: s.rtl,
                tap: s.tap,
                onText: s.onText,
                offText: s.offText,
                stopProp: s.stopProp
              });
              break;

            case 'checkbox':
              controls[control.id] = new CheckBox(control, {
                tap: s.tap,
                theme: s.theme,
                rtl: s.rtl
              });
              break;

            case 'range':
              if (!$$1(control).parent().hasClass('mbsc-slider')) {
                controls[control.id] = new Slider(control, {
                  theme: s.theme,
                  lang: s.lang,
                  rtl: s.rtl,
                  stopProp: s.stopProp,
                  labelStyle: s.labelStyle
                });
              }

              break;

            case 'rating':
              controls[control.id] = new Rating(control, {
                theme: s.theme,
                lang: s.lang,
                rtl: s.rtl,
                stopProp: s.stopProp
              });
              break;

            case 'progress':
              controls[control.id] = new Progress(control, {
                theme: s.theme,
                lang: s.lang,
                rtl: s.rtl,
                labelStyle: s.labelStyle
              });
              break;

            case 'radio':
              controls[control.id] = new Radio(control, {
                tap: s.tap,
                theme: s.theme,
                rtl: s.rtl
              });
              break;

            case 'select':
            case 'select-one':
            case 'select-multiple':
              controls[control.id] = new Select(control, {
                tap: s.tap,
                inputStyle: s.inputStyle,
                labelStyle: s.labelStyle,
                theme: s.theme,
                rtl: s.rtl
              });
              break;

            case 'textarea':
              controls[control.id] = new TextArea(control, {
                tap: s.tap,
                inputStyle: s.inputStyle,
                labelStyle: s.labelStyle,
                theme: s.theme,
                rtl: s.rtl
              });
              break;

            case 'segmented':
              controls[control.id] = new SegmentedItem(control, {
                theme: s.theme,
                rtl: s.rtl,
                tap: s.tap,
                inputStyle: s.inputStyle
              });
              break;

            case 'stepper':
              controls[control.id] = new Stepper(control, {
                theme: s.theme,
                rtl: s.rtl
              });
              break;

            case 'hidden':
              return;

            default:
              controls[control.id] = new Input(control, {
                tap: s.tap,
                inputStyle: s.inputStyle,
                labelStyle: s.labelStyle,
                theme: s.theme,
                rtl: s.rtl
              });
              break;
          }
        }
      }
  });
  $$1('[data-collapsible]:not(.mbsc-collapsible)', $ctx).each(function () {
    var control = this,
        $control = $$1(control),
        isOpen = $control.attr('data-open');

    if (!control.id) {
      control.id = 'mbsc-form-control-' + ++id$1;
    }

    controls[control.id] = new CollapsibleBase(control, {
      isOpen: isOpen !== undefined && isOpen != 'false'
    });
    instances[control.id] = controls[control.id];
  }); // Set initial height for textareas

  if (!shallow) {
    sizeTextAreas();
  }
}

var innerStyle = 'position:absolute;left:0;top:0;';
var style = innerStyle + 'right:0;bottom:0;overflow:hidden;z-index:-1;';
var markup = '<div style="' + style + '"><div style="' + innerStyle + '"></div></div>' + '<div style="' + style + '"><div style="' + innerStyle + 'width:200%;height:200%;"></div></div>';
var observer;
var count = 0;
function resizeObserver(el, callback, zone) {
  function reset() {
    expandChild.style.width = '100000px';
    expandChild.style.height = '100000px';
    expand.scrollLeft = 100000;
    expand.scrollTop = 100000;
    shrink.scrollLeft = 100000;
    shrink.scrollTop = 100000;
  }

  function checkHidden() {
    var now = new Date();
    hiddenRafId = 0;

    if (!stopCheck) {
      if (now - lastCheck > 200 && !expand.scrollTop && !expand.scrollLeft) {
        lastCheck = now;
        reset();
      }

      if (!hiddenRafId) {
        hiddenRafId = raf(checkHidden);
      }
    }
  }

  function onScroll() {
    if (!rafId) {
      rafId = raf(onResize);
    }
  }

  function onResize() {
    rafId = 0;
    reset();
    callback();
  }

  var expand;
  var expandChild;
  var helper;
  var hiddenRafId;
  var rafId;
  var shrink;
  var stopCheck;
  var lastCheck = 0; //let isHidden = true;

  if (window.ResizeObserver) {
    if (!observer) {
      observer = new ResizeObserver(function (entries) {
        for (var _iterator = entries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var entry = _ref;

          entry.target.__mbscResize();
        }
      });
    }

    count++;
    el.__mbscResize = callback;
    observer.observe(el);
  } else {
    helper = document.createElement('div');
    helper.innerHTML = markup;
    helper.dir = 'ltr'; // Need this to work in rtl as well;

    shrink = helper.childNodes[1];
    expand = helper.childNodes[0];
    expandChild = expand.childNodes[0];
    el.appendChild(helper);
    expand.addEventListener('scroll', onScroll);
    shrink.addEventListener('scroll', onScroll);

    if (zone) {
      zone.runOutsideAngular(function () {
        raf(checkHidden);
      });
    } else {
      raf(checkHidden);
    }
  }

  return {
    detach: function detach() {
      if (observer) {
        count--;
        observer.unobserve(el);

        if (!count) {
          observer = null;
        }
      } else {
        el.removeChild(helper);
        stopCheck = true;
      }
    }
  };
}

var $activeElm,
    preventShow,
    themes = mobiscroll.themes,
    needsFixed = /(iphone|ipod)/i.test(userAgent) && majorVersion >= 7,
    isAndroid = os == 'android',
    isIOS = os == 'ios',
    isIOS8 = isIOS && majorVersion == 8,
    halfBorder = isIOS && majorVersion > 7,
    prevdef = function prevdef(ev) {
  ev.preventDefault();
};

var EDITABLE = 'input,select,textarea,button';
var ALLOW_ENTER = 'textarea,button,input[type="button"],input[type="submit"]';
var FOCUSABLE = EDITABLE + ',[tabindex="0"]';
var Frame = function Frame(el, settings, inherit) {
  var //$ariaDiv,
  $ctx,
      $header,
      $lock,
      $markup,
      $overlay,
      $persp,
      $popup,
      $wnd,
      $wrapper,
      buttons,
      btn,
      ctx,
      doAnim,
      hasContext,
      isModal,
      isInserted,
      isPointer,
      markup,
      modalWidth,
      modalHeight,
      needsDimensions,
      needsLock,
      observer,
      overlay,
      popup,
      posDebounce,
      prevInst,
      s,
      scrollLock,
      touched,
      trigger,
      wndWidth,
      wndHeight,
      that = this,
      $elm = $$1(el),
      elmList = [],
      lastFocus = new Date();

  function onBtnStart(ev) {
    // Need this to prevent opening of sidemenus or similar
    if (s.stopProp) {
      ev.stopPropagation();
    }

    var b = closest(this, ev.target, '.mbsc-fr-btn-e');

    if (!b) {
      return;
    } // Can't call preventDefault here, it kills page scroll


    if (btn) {
      btn.removeClass('mbsc-active');
    }

    btn = $$1(b); // Active button

    if (!btn.hasClass('mbsc-disabled') && !btn.hasClass('mbsc-fr-btn-nhl')) {
      btn.addClass('mbsc-active');
    }

    if (ev.type === 'mousedown') {
      $$1(document).on('mouseup', onBtnEnd);
    }
  }

  function onBtnEnd(ev) {
    if (btn) {
      btn.removeClass('mbsc-active');
      btn = null;
    }

    if (ev.type === 'mouseup') {
      $$1(document).off('mouseup', onBtnEnd);
    }
  }

  function onScroll(ev) {
    if (scrollLock && markup.contains(ev.target)) {
      ev.preventDefault();
    }
  }

  function onWndKeyDown(ev) {
    if (mobiscroll.activeInstance == that) {
      if (ev.keyCode == 13 && (!$$1(ev.target).is(ALLOW_ENTER) || ev.shiftKey)) {
        that.select();
      } else if (ev.keyCode == 27) {
        that.cancel();
      }
    }
  }

  function onShow(prevFocus) {
    if (!prevFocus && !isAndroid && that._activeElm) {
      //overlay.focus();
      lastFocus = new Date();

      that._activeElm.focus();
    } //that.ariaMessage(s.ariaMessage);

  }

  function onHide(prevAnim) {
    var $activeEl = $activeElm,
        focus = s.focusOnClose;

    that._markupRemove();

    $markup.remove();

    if (isModal) {
      ctx.mbscModals--;

      if (s.scrollLock) {
        ctx.mbscLock--;
      }

      if (!ctx.mbscLock) {
        $lock.removeClass('mbsc-fr-lock');
      }

      if (needsLock) {
        ctx.mbscIOSLock--;

        if (!ctx.mbscIOSLock) {
          $lock.removeClass('mbsc-fr-lock-ios');
          $ctx.css({
            top: '',
            left: ''
          });
          $wnd.scrollLeft(ctx.mbscScrollLeft);
          $wnd.scrollTop(ctx.mbscScrollTop);
        }
      } // The follwing should be done only if no other
      // instance was opened during the hide animation


      if (!ctx.mbscModals) {
        $lock.removeClass('mbsc-fr-lock-ctx');
      }

      if (!ctx.mbscModals || prevInst) {
        // Put focus back to the last active element
        if (!prevAnim) {
          if (!$activeEl) {
            $activeEl = $elm;
          }

          setTimeout(function () {
            if (focus === undefined || focus === true) {
              preventShow = true;
              $activeEl[0].focus();
            } else if (focus) {
              $$1(focus)[0].focus();
            }
          }, 200);
        }
      }
    }

    prevInst = undefined;
    isInserted = false;
    trigger('onHide');
  }

  function onPosition() {
    clearTimeout(posDebounce);
    posDebounce = setTimeout(function () {
      if (that.position(true)) {
        // Trigger reflow, needed on iOS safari, when orientation is changed
        popup.style.visibility = 'hidden';
        popup.offsetHeight;
        popup.style.visibility = '';
      }
    }, 200);
  }

  function onFocus(ev) {
    if (mobiscroll.activeInstance == that && ev.target.nodeType && !overlay.contains(ev.target) && new Date() - lastFocus > 100) {
      lastFocus = new Date();

      that._activeElm.focus();
    }
  }

  function insertMarkup(prevAnim, prevFocus) {
    function onAnimEnd() {
      $markup.off(animEnd, onAnimEnd).removeClass('mbsc-anim-in mbsc-anim-trans mbsc-anim-trans-' + doAnim).find('.mbsc-fr-popup').removeClass('mbsc-anim-' + doAnim);
      onShow(prevFocus);
    }

    function onOverlayStart(ev) {
      if (!target && ev.target == overlay) {
        target = true;
        moved = false;
        startX = getCoord(ev, 'X');
        startY = getCoord(ev, 'Y');
      }
    }

    function onOverlayMove(ev) {
      if (target && !moved && (Math.abs(getCoord(ev, 'X') - startX) > 9 || Math.abs(getCoord(ev, 'Y') - startY) > 9)) {
        moved = true;
      }
    } // Might be not visible if immediately hidden


    if (!that._isVisible) {
      return;
    } // Show


    if (isModal) {
      $markup.appendTo($ctx);
    } else if ($elm.is('div') && !that._hasContent) {
      // Insert inside the element on which was initialized
      $elm.empty().append($markup);
    } else {
      // Insert after the element
      if ($elm.hasClass('mbsc-control')) {
        var $wrap = $elm.closest('.mbsc-control-w');
        $markup.insertAfter($wrap);

        if ($wrap.hasClass('mbsc-select')) {
          $wrap.addClass('mbsc-select-inline');
        }
      } else {
        $markup.insertAfter($elm);
      }
    }

    isInserted = true;

    that._markupInserted($markup);

    trigger('onMarkupInserted', {
      target: markup
    });

    if (isModal && s.closeOnOverlayTap) {
      var moved, target, startX, startY;
      listen(overlay, 'touchstart', onOverlayStart, {
        passive: true
      });
      listen(overlay, 'touchmove', onOverlayMove, {
        passive: true
      });
      $overlay.on('mousedown', onOverlayStart).on('mousemove', onOverlayMove).on('touchcancel', function () {
        target = false;
      }).on('touchend click', function (ev) {
        if (target && !moved) {
          that.cancel();

          if (ev.type == 'touchend') {
            preventClick();
          }
        }

        target = false;
      });
    }

    $markup.on('mousedown', '.mbsc-btn-e,.mbsc-fr-btn-e', prevdef).on('keydown', '.mbsc-fr-btn-e', function (ev) {
      if (ev.keyCode == 32) {
        // Space
        ev.preventDefault();
        ev.stopPropagation();
        this.click();
      }
    }).on('keydown', function (ev) {
      // Trap focus inside modal
      if (ev.keyCode == 32 && !$$1(ev.target).is(EDITABLE)) {
        // Prevent page scroll on space press
        ev.preventDefault();
      } else if (ev.keyCode == 9 && isModal && s.focusTrap) {
        // Tab
        var $focusable = $markup.find(FOCUSABLE).filter(function () {
          return this.offsetWidth > 0 || this.offsetHeight > 0;
        }),
            index = $focusable.index($$1(':focus', $markup)),
            i = $focusable.length - 1,
            target = 0;

        if (ev.shiftKey) {
          i = 0;
          target = -1;
        }

        if (index === i) {
          $focusable.eq(target)[0].focus();
          ev.preventDefault();
        }
      }
    }).on('touchend', '.mbsc-fr-btn-e', onBtnEnd);
    listen(markup, 'touchstart', onBtnStart, {
      passive: true
    });
    listen(markup, 'mousedown', onBtnStart); // Need event capture for this

    listen(markup, 'touchstart', function () {
      if (!touched) {
        touched = true;
        $ctx.find('.mbsc-no-touch').removeClass('mbsc-no-touch');
      }
    }, {
      passive: true,
      capture: true
    }); // Init buttons

    $$1.each(buttons, function (i, b) {
      that.tap($$1('.mbsc-fr-btn' + i, $markup), function (ev) {
        b = isString(b) ? that.buttons[b] : b;
        (isString(b.handler) ? that.handlers[b.handler] : b.handler).call(this, ev, that);
      }, true);
    });

    that._attachEvents($markup); // Set position


    if (that.position() === false) {
      return;
    }

    if (isModal || that._checkSize) {
      observer = resizeObserver(markup, onPosition, s.zone);
    }

    if (isModal) {
      $markup.removeClass('mbsc-fr-pos');

      if (doAnim && !prevAnim) {
        $markup.addClass('mbsc-anim-in mbsc-anim-trans mbsc-anim-trans-' + doAnim).on(animEnd, onAnimEnd).find('.mbsc-fr-popup').addClass('mbsc-anim-' + doAnim);
      } else {
        onShow(prevFocus);
      }
    }

    trigger('onShow', {
      target: markup,
      valueText: that._tempValue
    });
  }

  function show(beforeShow, $elm) {
    if (that._isVisible) {
      return;
    }

    if (beforeShow) {
      beforeShow();
    }

    if (that.show() !== false) {
      $activeElm = $elm;
    }
  }

  function set() {
    that._fillValue();

    trigger('onSet', {
      valueText: that._value
    });
  }

  function cancel() {
    trigger('onCancel', {
      valueText: that._value
    });
  }

  function clear() {
    that.setVal(null, true);
  } // Call the parent constructor


  Base.call(this, el, settings, true);
  /**
   * Positions the scroller on the screen.
   */

  that.position = function (check) {
    var anchor,
        anchorWidth,
        anchorHeight,
        anchorPos,
        anchorTop,
        anchorLeft,
        arrow,
        arrowWidth,
        arrowHeight,
        docHeight,
        docWidth,
        isWrapped,
        newHeight,
        newWidth,
        oldHeight,
        oldWidth,
        width,
        top,
        left,
        css = {},
        scrollLeft = 0,
        scrollTop = 0,
        minWidth = 0,
        totalWidth = 0;

    if (!isInserted) {
      return false;
    }

    oldWidth = wndWidth;
    oldHeight = wndHeight;
    newHeight = Math.min(markup.offsetHeight, hasContext ? Infinity : window.innerHeight);
    newWidth = Math.min(markup.offsetWidth, hasContext ? Infinity : window.innerWidth);

    if (!newWidth || !newHeight || wndWidth === newWidth && wndHeight === newHeight && check) {
      return;
    }

    if (that._checkResp(newWidth)) {
      return false;
    }

    wndWidth = newWidth;
    wndHeight = newHeight;

    if (that._isFullScreen || /top|bottom/.test(s.display)) {
      // Set width, if document is larger than viewport, needs to be set before onPosition (for calendar)
      $popup.width(newWidth);
    } else if (isModal) {
      // Reset width
      $wrapper.width('');
    }

    that._position($markup); // Call position for nested mobiscroll components
    // $('.mbsc-comp', $markup).each(function () {
    //     var inst = instances[this.id];
    //     if (inst && inst !== that && inst.position) {
    //         inst.position();
    //     }
    // });


    if (!that._isFullScreen && /center|bubble/.test(s.display)) {
      $$1('.mbsc-w-p', $markup).each(function () {
        // Need fractional values here, so offsetWidth is not ok
        width = this.getBoundingClientRect().width;
        totalWidth += width;
        minWidth = width > minWidth ? width : minWidth;
      });
      isWrapped = totalWidth > newWidth - 16 || s.tabs === true;
      $wrapper.css({
        'width': that._isLiquid ? Math.min(s.maxPopupWidth, newWidth - 16) : Math.ceil(isWrapped ? minWidth : totalWidth),
        'white-space': isWrapped ? '' : 'nowrap'
      });
    }

    if (trigger('onPosition', {
      target: markup,
      popup: popup,
      hasTabs: isWrapped,
      oldWidth: oldWidth,
      oldHeight: oldHeight,
      windowWidth: newWidth,
      windowHeight: newHeight
    }) === false || !isModal) {
      return;
    }

    if (needsDimensions) {
      scrollLeft = $wnd.scrollLeft();
      scrollTop = $wnd.scrollTop();

      if (wndWidth) {
        $persp.css({
          width: '',
          height: ''
        });
      }
    }

    modalWidth = popup.offsetWidth;
    modalHeight = popup.offsetHeight;
    scrollLock = modalHeight <= newHeight && modalWidth <= newWidth;

    if (s.display == 'center') {
      left = Math.max(0, scrollLeft + (newWidth - modalWidth) / 2);
      top = Math.max(0, scrollTop + (newHeight - modalHeight) / 2);
    } else if (s.display == 'bubble') {
      anchor = s.anchor === undefined ? $elm : $$1(s.anchor);
      arrow = $$1('.mbsc-fr-arr-i', $markup)[0];
      anchorPos = anchor.offset();
      anchorTop = anchorPos.top + (hasContext ? scrollTop - $ctx.offset().top : 0);
      anchorLeft = anchorPos.left + (hasContext ? scrollLeft - $ctx.offset().left : 0);
      anchorWidth = anchor[0].offsetWidth;
      anchorHeight = anchor[0].offsetHeight;
      arrowWidth = arrow.offsetWidth;
      arrowHeight = arrow.offsetHeight; // Horizontal positioning

      left = constrain(anchorLeft - (modalWidth - anchorWidth) / 2, scrollLeft + 3, scrollLeft + newWidth - modalWidth - 3); // Vertical positioning
      // Below the input

      top = anchorTop + anchorHeight + arrowHeight / 2;

      if (top + modalHeight + 8 > scrollTop + newHeight && anchorTop - modalHeight - arrowHeight / 2 > scrollTop) {
        $popup.removeClass('mbsc-fr-bubble-bottom').addClass('mbsc-fr-bubble-top'); // Above the input

        top = anchorTop - modalHeight - arrowHeight / 2;
      } else {
        $popup.removeClass('mbsc-fr-bubble-top').addClass('mbsc-fr-bubble-bottom');
      } // Set arrow position


      $$1('.mbsc-fr-arr', $markup).css({
        left: constrain(anchorLeft + anchorWidth / 2 - (left + (modalWidth - arrowWidth) / 2), 0, arrowWidth)
      }); // Lock scroll only if popup is entirely in the viewport

      scrollLock = top > scrollTop && left > scrollLeft && top + modalHeight <= scrollTop + newHeight && left + modalWidth <= scrollLeft + newWidth;
    } else {
      left = scrollLeft;
      top = s.display == 'top' ? scrollTop : Math.max(0, scrollTop + newHeight - modalHeight);
    }

    if (needsDimensions) {
      // If top + modal height > doc height, increase doc height
      docHeight = Math.max(top + modalHeight, hasContext ? ctx.scrollHeight : $$1(document).height());
      docWidth = Math.max(left + modalWidth, hasContext ? ctx.scrollWidth : $$1(document).width());
      $persp.css({
        width: docWidth,
        height: docHeight
      }); // Check if scroll needed

      if (s.scroll && s.display == 'bubble' && (top + modalHeight + 8 > scrollTop + newHeight || anchorTop > scrollTop + newHeight || anchorTop + anchorHeight < scrollTop)) {
        $wnd.scrollTop(Math.min(anchorTop, top + modalHeight - newHeight + 8, docHeight - newHeight));
      }
    }

    css.top = Math.floor(top);
    css.left = Math.floor(left);
    $popup.css(css);
    return true;
  };
  /**
   * Show mobiscroll on focus and click event of the parameter.
   * @param {HTMLElement} elm - Events will be attached to this element.
   * @param {Function} [beforeShow=undefined] - Optional function to execute before showing mobiscroll.
   */


  that.attachShow = function (elm, beforeShow) {
    var $label,
        $elm = $$1(elm).off('.mbsc'),
        readOnly = $elm.prop('readonly');
    tapOff($elm);

    if (s.display !== 'inline') {
      if ((s.showOnFocus || s.showOnTap) && $elm.is('input,select')) {
        $elm.prop('readonly', true).on('mousedown.mbsc', function (ev) {
          // Prevent input to get focus on tap (virtual keyboard pops up on some devices)
          ev.preventDefault();
        }).on('focus.mbsc', function () {
          if (that._isVisible) {
            // Don't allow input focus if mobiscroll is being opened
            this.blur();
          }
        });
        $label = $$1('label[for="' + $elm.attr('id') + '"]');

        if (!$label.length) {
          $label = $elm.closest('label');
        }
      }

      if (!$elm.is('select')) {
        if (s.showOnFocus) {
          $elm.on('focus.mbsc', function () {
            if (!preventShow) {
              show(beforeShow, $elm);
            } else {
              preventShow = false;
            }
          });
        }

        if (s.showOnTap) {
          $elm.on('keydown.mbsc', function (ev) {
            if (ev.keyCode == 32 || ev.keyCode == 13) {
              // Space or Enter
              ev.preventDefault();
              ev.stopPropagation();
              show(beforeShow, $elm);
            }
          });
          that.tap($elm, function (ev) {
            if (ev.isMbscTap) {
              touched = true;
            }

            show(beforeShow, $elm);
          });

          if ($label && $label.length) {
            tapOff($label);
            that.tap($label, function (ev) {
              ev.preventDefault();

              if (ev.target !== $elm[0]) {
                show(beforeShow, $elm);
              }
            });
          }
        }
      }

      elmList.push({
        readOnly: readOnly,
        el: $elm,
        lbl: $label
      });
    }
  };
  /**
   * Set button handler.
   */


  that.select = function () {
    if (isModal) {
      that.hide(false, 'set', false, set);
    } else {
      set();
    }
  };
  /**
   * Cancel and hide the scroller instance.
   */


  that.cancel = function () {
    if (isModal) {
      that.hide(false, 'cancel', false, cancel);
    } else {
      cancel();
    }
  };
  /**
   * Clear button handler.
   */


  that.clear = function () {
    that._clearValue();

    trigger('onClear');

    if (isModal && that._isVisible && !that.live) {
      that.hide(false, 'clear', false, clear);
    } else {
      clear();
    }
  };
  /**
   * Enables the scroller and the associated input.
   */


  that.enable = function () {
    s.disabled = false;
    $$1.each(elmList, function (i, v) {
      if (v.el.is('input,select')) {
        v.el[0].disabled = false;
      }
    });
  };
  /**
   * Disables the scroller and the associated input.
   */


  that.disable = function () {
    s.disabled = true;
    $$1.each(elmList, function (i, v) {
      if (v.el.is('input,select')) {
        v.el[0].disabled = true;
      }
    });
  };
  /**
   * Shows the scroller instance.
   * @param {Boolean} prevAnim - Prevent animation if true
   * @param {Boolean} prevFocus - Prevent focusing if true
   */


  that.show = function (prevAnim, prevFocus) {
    var hasButtons, html, scrollLeft, scrollTop;

    if (s.disabled || that._isVisible) {
      return;
    } // Parse value from input


    that._readValue();

    if (trigger('onBeforeShow') === false) {
      return false;
    }

    $activeElm = null;
    doAnim = s.animate;
    buttons = s.buttons || [];
    needsDimensions = hasContext || s.display == 'bubble';
    needsLock = needsFixed && !needsDimensions && s.scrollLock;
    hasButtons = buttons.length > 0; //touched = false;

    if (doAnim !== false) {
      if (s.display == 'top') {
        doAnim = doAnim || 'slidedown';
      } else if (s.display == 'bottom') {
        doAnim = doAnim || 'slideup';
      } else if (s.display == 'center' || s.display == 'bubble') {
        doAnim = doAnim || 'pop';
      }
    }

    if (isModal) {
      wndWidth = 0;
      wndHeight = 0;

      if (needsLock && !$lock.hasClass('mbsc-fr-lock-ios')) {
        //$lock.scrollTop(0);
        ctx.mbscScrollTop = scrollTop = Math.max(0, $wnd.scrollTop());
        ctx.mbscScrollLeft = scrollLeft = Math.max(0, $wnd.scrollLeft());
        $ctx.css({
          top: -scrollTop + 'px',
          left: -scrollLeft + 'px'
        });
      }

      $lock.addClass((s.scrollLock ? 'mbsc-fr-lock' : '') + (needsLock ? ' mbsc-fr-lock-ios' : '') + (hasContext ? ' mbsc-fr-lock-ctx' : '')); // Hide virtual keyboard

      if ($$1(document.activeElement).is('input,textarea')) {
        document.activeElement.blur();
      } // Save active instance to previous


      prevInst = mobiscroll.activeInstance; // Set active instance

      mobiscroll.activeInstance = that; // Keep track of modals opened per context

      ctx.mbscModals = (ctx.mbscModals || 0) + 1;

      if (needsLock) {
        ctx.mbscIOSLock = (ctx.mbscIOSLock || 0) + 1;
      }

      if (s.scrollLock) {
        ctx.mbscLock = (ctx.mbscLock || 0) + 1;
      }
    } // Create wheels containers


    html = '<div lang="' + s.lang + '" class="mbsc-fr mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + ' mbsc-fr-' + s.display + ' ' + (s.cssClass || '') + ' ' + (s.compClass || '') + (that._isLiquid ? ' mbsc-fr-liq' : '') + (isModal ? ' mbsc-fr-pos' + (s.showOverlay ? '' : ' mbsc-fr-no-overlay') : '') + (isPointer ? ' mbsc-fr-pointer' : '') + (halfBorder ? ' mbsc-fr-hb' : '') + (touched ? '' : ' mbsc-no-touch') + (needsLock ? ' mbsc-platform-ios' : '') + (hasButtons ? buttons.length >= 3 ? ' mbsc-fr-btn-block ' : '' : ' mbsc-fr-nobtn') + '">' + (isModal ? '<div class="mbsc-fr-persp">' + (s.showOverlay ? '<div class="mbsc-fr-overlay"></div>' : '') + // Overlay
    '<div role="dialog" class="mbsc-fr-scroll">' : '') + '<div class="mbsc-fr-popup' + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr') + (s.headerText ? ' mbsc-fr-has-hdr' : '') + '">' + ( // Popup
    s.display === 'bubble' ? '<div class="mbsc-fr-arr-w"><div class="mbsc-fr-arr-i"><div class="mbsc-fr-arr"></div></div></div>' : '') + ( // Bubble arrow
    isModal ? '<div class="mbsc-fr-focus" tabindex="-1"></div>' : '') + '<div class="mbsc-fr-w">' + ( // Popup content
    //'<div aria-live="assertive" class="mbsc-fr-aria mbsc-fr-hdn"></div>' +
    s.headerText ? '<div class="mbsc-fr-hdr">' + (isString(s.headerText) ? s.headerText : '') + '</div>' : '') + // Header
    '<div class="mbsc-fr-c">'; // Wheel group container

    html += that._generateContent();
    html += '</div>';

    if (hasButtons) {
      var b,
          i,
          j,
          l = buttons.length;
      html += '<div class="mbsc-fr-btn-cont">';

      for (i = 0; i < buttons.length; i++) {
        j = s.btnReverse ? l - i - 1 : i;
        b = buttons[j];
        b = isString(b) ? that.buttons[b] : b;

        if (b.handler === 'set') {
          b.parentClass = 'mbsc-fr-btn-s';
        }

        if (b.handler === 'cancel') {
          b.parentClass = 'mbsc-fr-btn-c';
        }

        html += '<div' + (s.btnWidth ? ' style="width:' + 100 / buttons.length + '%"' : '') + ' class="mbsc-fr-btn-w ' + (b.parentClass || '') + '">' + '<div tabindex="0" role="button" class="mbsc-fr-btn' + j + ' mbsc-fr-btn-e ' + (b.cssClass === undefined ? s.btnClass : b.cssClass) + (b.icon ? ' mbsc-ic mbsc-ic-' + b.icon : '') + '">' + (b.text || '') + '</div></div>';
      }

      html += '</div>';
    }

    html += '</div></div></div></div>' + (isModal ? '</div></div>' : '');
    $markup = $$1(html);
    $persp = $$1('.mbsc-fr-persp', $markup);
    $overlay = $$1('.mbsc-fr-scroll', $markup);
    $wrapper = $$1('.mbsc-fr-w', $markup);
    $popup = $$1('.mbsc-fr-popup', $markup);
    $header = $$1('.mbsc-fr-hdr', $markup); //$ariaDiv = $('.mbsc-fr-aria', $markup);

    markup = $markup[0];
    overlay = $overlay[0];
    popup = $popup[0];
    that._activeElm = $$1('.mbsc-fr-focus', $markup)[0];
    that._markup = $markup;
    that._isVisible = true;
    that.markup = markup;

    that._markupReady($markup);

    trigger('onMarkupReady', {
      target: markup
    }); // Attach events

    if (isModal) {
      // Enter / ESC
      $$1(window).on('keydown', onWndKeyDown); // Prevent scroll if not specified otherwise

      if (s.scrollLock) {
        listen(document, 'touchmove', onScroll, {
          passive: false
        });
        listen(document, 'mousewheel', onScroll, {
          passive: false
        });
        listen(document, 'wheel', onScroll, {
          passive: false
        });
      }

      if (s.focusTrap) {
        $wnd.on('focusin', onFocus);
      }
    }

    if (isModal) {
      // Wait for the toolbar and addressbar to appear on iOS
      setTimeout(function () {
        insertMarkup(prevAnim, prevFocus);
      }, needsLock ? 100 : 0);
    } else {
      insertMarkup(prevAnim, prevFocus);
    }
  };
  /**
   * Hides the scroller instance.
   */


  that.hide = function (prevAnim, btn, force, callback) {
    function onAnimEnd() {
      $markup.off(animEnd, onAnimEnd);
      onHide(prevAnim);
    } // If onClose handler returns false, prevent hide


    if (!that._isVisible || !force && !that._isValid && btn == 'set' || !force && trigger('onBeforeClose', {
      valueText: that._tempValue,
      button: btn
    }) === false) {
      return false;
    }

    that._isVisible = false;

    if (observer) {
      observer.detach();
      observer = null;
    }

    if (isModal) {
      if ($$1(document.activeElement).is('input,textarea') && popup.contains(document.activeElement)) {
        document.activeElement.blur();
      }

      if (mobiscroll.activeInstance == that) {
        mobiscroll.activeInstance = prevInst;
      }

      $$1(window).off('keydown', onWndKeyDown);
      $wnd.off('focusin', onFocus);
      unlisten(document, 'touchmove', onScroll, {
        passive: false
      });
      unlisten(document, 'mousewheel', onScroll, {
        passive: false
      });
      unlisten(document, 'wheel', onScroll, {
        passive: false
      });
    } // Hide wheels and overlay


    if ($markup) {
      if (isModal && isInserted && doAnim && !prevAnim) {
        $markup.addClass('mbsc-anim-out mbsc-anim-trans mbsc-anim-trans-' + doAnim).on(animEnd, onAnimEnd).find('.mbsc-fr-popup').addClass('mbsc-anim-' + doAnim);
      } else {
        onHide(prevAnim);
      }

      that._detachEvents($markup);
    }

    if (callback) {
      callback();
    } // For validation


    $elm.trigger('blur');
    trigger('onClose', {
      valueText: that._value
    });
  }; // that.ariaMessage = function (txt) {
  //     $ariaDiv.html('');
  //     setTimeout(function () {
  //         $ariaDiv.html(txt);
  //     }, 100);
  // };

  /**
   * Return true if the scroller is currently visible.
   */


  that.isVisible = function () {
    return that._isVisible;
  }; // Protected functions to override


  that.setVal = noop;
  that.getVal = noop;
  that._generateContent = noop;
  that._attachEvents = noop;
  that._detachEvents = noop;
  that._readValue = noop;
  that._clearValue = noop;
  that._fillValue = noop;
  that._markupReady = noop;
  that._markupInserted = noop;
  that._markupRemove = noop;
  that._position = noop;
  that.__processSettings = noop;
  that.__init = noop;
  that.__destroy = noop; // Generic frame functions

  /**
   * Destroys the mobiscroll instance.
   */

  that._destroy = function () {
    // Force hide without animation
    that.hide(true, false, true);
    $elm.off('.mbsc');
    tapOff($elm); // Remove all events from elements

    $$1.each(elmList, function (i, v) {
      v.el.off('.mbsc').prop('readonly', v.readOnly);
      tapOff(v.el);

      if (v.lbl) {
        v.lbl.off('.mbsc');
        tapOff(v.lbl);
      }
    });

    that.__destroy();
  };

  that._updateHeader = function () {
    var t = s.headerText,
        txt = t ? typeof t === 'function' ? t.call(el, that._tempValue) : t.replace(/\{value\}/i, that._tempValue) : '';
    $header.html(txt || '&nbsp;');
  };

  that._getRespCont = function () {
    hasContext = s.context != 'body';
    $wnd = $$1(hasContext ? s.context : window);
    return s.display == 'inline' ? $elm.is('div') ? $elm : $elm.parent() : $wnd;
  };

  that._processSettings = function (resp) {
    var b, i;

    that.__processSettings(resp);

    isPointer = !s.touchUi;

    if (isPointer) {
      s.display = resp.display || settings.display || 'bubble';
      s.buttons = resp.buttons || settings.buttons || [];
      s.showOverlay = resp.showOverlay || settings.showOverlay || false;
    } // Add default buttons


    s.buttons = s.buttons || (s.display !== 'inline' ? ['cancel', 'set'] : []); // Hide header text in inline mode by default

    s.headerText = s.headerText === undefined ? s.display !== 'inline' ? '{value}' : false : s.headerText;
    buttons = s.buttons || [];
    isModal = s.display !== 'inline';
    $ctx = $$1(s.context);
    $lock = hasContext ? $ctx : $$1('body,html');
    ctx = $ctx[0];
    that.live = true; // If no set button is found, live mode is activated

    for (i = 0; i < buttons.length; i++) {
      b = buttons[i];

      if (b == 'ok' || b == 'set' || b.handler == 'set') {
        that.live = false;
      }
    }

    that.buttons.set = {
      text: s.setText,
      icon: s.setIcon,
      handler: 'set'
    };
    that.buttons.cancel = {
      text: s.cancelText,
      icon: s.cancelIcon,
      handler: 'cancel'
    };
    that.buttons.close = {
      text: s.closeText,
      icon: s.closeIcon,
      handler: 'cancel'
    };
    that.buttons.clear = {
      text: s.clearText,
      icon: s.clearIcon,
      handler: 'clear'
    };
    that._isInput = $elm.is('input');
  };
  /**
   * Scroller initialization.
   */


  that._init = function (newSettings) {
    var wasVisible = that._isVisible,
        wasReady = wasVisible && !$markup.hasClass('mbsc-fr-pos');

    if (wasVisible) {
      that.hide(true, false, true);
    } // Unbind all events (if re-init)


    $elm.off('.mbsc');
    tapOff($elm);

    that.__init(newSettings);

    that._isLiquid = s.layout == 'liquid';

    if (isModal) {
      that._readValue();

      if (!that._hasContent && !s.skipShow) {
        that.attachShow($elm);
      }

      if (wasVisible) {
        that.show(wasReady);
      }
    } else {
      that.show();
    }

    $elm.removeClass('mbsc-cloak').filter('input, select, textarea').on('change.mbsc', function () {
      if (!that._preventChange) {
        that.setVal($elm.val(), true, false);
      }

      that._preventChange = false;
    });
  };

  that.buttons = {};
  that.handlers = {
    set: that.select,
    cancel: that.cancel,
    clear: that.clear
  };
  that._value = null;
  that._isValid = true;
  that._isVisible = false; // Constructor

  s = that.settings;
  trigger = that.trigger;

  if (!inherit) {
    that.init();
  }
};
Frame.prototype._defaults = {
  // Localization
  lang: 'en',
  setText: 'Set',
  selectedText: '{count} selected',
  closeText: 'Close',
  cancelText: 'Cancel',
  clearText: 'Clear',
  // Options
  context: 'body',
  maxPopupWidth: 600,
  disabled: false,
  closeOnOverlayTap: true,
  showOnFocus: isAndroid || isIOS,
  // Needed for ion-input
  showOnTap: true,
  display: 'center',
  scroll: true,
  scrollLock: true,
  showOverlay: true,
  tap: true,
  touchUi: true,
  btnClass: 'mbsc-fr-btn',
  btnWidth: true,
  focusTrap: true,
  focusOnClose: !isIOS8 // Temporary for iOS8

};
classes.Frame = Frame;
themes.frame.mobiscroll = {
  headerText: false,
  btnWidth: false
};
themes.scroller.mobiscroll = extend$1({}, themes.frame.mobiscroll, {
  rows: 5,
  showLabel: false,
  selectedLineBorder: 1,
  weekDays: 'min',
  checkIcon: 'ion-ios7-checkmark-empty',
  btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
  btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',
  btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
  btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5'
});

if (isBrowser) {
  // Prevent re-show on window focus
  $$1(window).on('focus', function () {
    if ($activeElm) {
      preventShow = true;
    }
  });
}

var Popup = function Popup(el, settings, inherit) {
  function addContent($m) {
    /* TRIAL */
    if (!$$1('.mbsc-fr-c', $m).hasClass('mbsc-wdg-c')
    /* TRIALCOND */
    ) {
        $$1('.mbsc-fr-c', $m).addClass('mbsc-wdg-c').append($elm.show());

        if (!$$1('.mbsc-w-p', $m).length) {
          $$1('.mbsc-fr-c', $m).addClass('mbsc-w-p');
        }
      }
  }

  var s,
      $prev,
      $elm = $$1(el),
      that = this; // Call the parent constructor

  Frame.call(this, el, settings, true);
  /* TRIALFUNC */

  that._generateContent = function () {
    return '';
  };

  that._markupReady = function ($m) {
    if (s.display != 'inline') {
      addContent($m);
    }
  };

  that._markupInserted = function ($m) {
    if (s.display == 'inline') {
      addContent($m);
    }

    $m.trigger('mbsc-enhance', [{
      theme: s.theme,
      lang: s.lang
    }]);
  };

  that._markupRemove = function () {
    $elm.hide();

    if ($prev && $prev.parent().length) {
      $prev.after($elm);
    }
  };

  that.__processSettings = function () {
    s = that.settings;
    that.buttons.ok = {
      text: s.okText,
      icon: s.okIcon,
      handler: 'set'
    };
    s.buttons = s.buttons || (s.display == 'inline' ? [] : ['ok']);

    if (!$prev && $elm.parent().length) {
      $prev = $$1(document.createComment('popup'));
      $elm.before($prev);
    }

    $elm.hide();
  }; // Constructor


  if (!inherit) {
    that.init();
  }
};
Popup.prototype = {
  _hasDef: true,
  _hasTheme: true,
  _hasContent: true,
  _hasLang: true,
  _responsive: true,
  _class: 'popup',
  _defaults: extend$1({}, Frame.prototype._defaults, {
    compClass: 'mbsc-wdg',
    okText: 'OK',
    headerText: false
  })
};
classes.Popup = Popup;
classes.Widget = Popup;
mobiscroll.themes.popup = mobiscroll.themes.frame;

var hasPromise = isBrowser && !!window.Promise;
var popupQueue = [];
var notificationQueue = [];
var activeNotification;

function showPopup(popup) {
  if (!popupQueue.length) {
    popup.show();
  }

  popupQueue.push(popup);
}

function showNotification(notification) {
  var isAny = notificationQueue.length;
  notificationQueue.push(notification); // Only show notification if no popup is visible
  // otherwise postpone it until popup is closed

  if (!popupQueue.length) {
    // If there's a visible notification, hide it.
    // The notification will be shown after hide animation is complete
    if (isAny) {
      notificationQueue[0].hide();
    } else {
      // Prevent focus on show for notifications
      notification.show(false, true);
    }
  }
}

function getSettings(queue, settings, resolve, more) {
  //const active = mobiscroll.activeInstance;
  return extend$1({
    display: settings.display || 'center',
    cssClass: 'mbsc-alert',
    okText: settings.okText,
    cancelText: settings.cancelText,
    context: settings.context,
    theme: settings.theme,
    closeOnOverlayTap: false,
    onBeforeClose: function onBeforeClose() {
      queue.shift();
    },
    onHide: function onHide(ev, inst) {
      //mobiscroll.activeInstance = active;
      if (resolve) {
        resolve(inst._resolve);
      }

      if (settings.callback) {
        settings.callback(inst._resolve);
      }

      if (inst) {
        inst.destroy();
      } // Show next


      if (popupQueue.length) {
        popupQueue[0].show();
      } else if (notificationQueue.length) {
        // Prevent focus on show for notifications
        notificationQueue[0].show(false, true);
      }
    }
  }, more);
}

function getMessage(settings) {
  return (settings.title ? '<h2>' + settings.title + '</h2>' : '') + '<p>' + (settings.message || '') + '</p>';
}

function showAlert(popup, settings, resolve) {
  var inst = new Popup(popup, getSettings(popupQueue, settings, resolve));
  showPopup(inst);
}

function showConfirm(popup, settings, resolve) {
  var inst = new Popup(popup, getSettings(popupQueue, settings, resolve, {
    buttons: ['cancel', 'ok'],
    onSet: function onSet() {
      inst._resolve = true;
    }
  }));
  inst._resolve = false;
  showPopup(inst);
}

function showPrompt(popup, settings, resolve) {
  var input, label;
  var inst = new Popup(popup, getSettings(popupQueue, settings, resolve, {
    buttons: ['cancel', 'ok'],
    onMarkupReady: function onMarkupReady(event, inst) {
      var s = inst.settings;
      label = inst._markup.find('label');
      label.addClass('mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : ''));
      input = inst._markup.find('input')[0];
      setTimeout(function () {
        input.focus();
        input.setSelectionRange(0, input.value.length);
      }, 300);
    },
    onSet: function onSet() {
      inst._resolve = input.value;
    }
  }));
  inst._resolve = null;
  showPopup(inst);
}

function showSnackbar(popup, settings, resolve, cssClass, animation) {
  var notificationTimer;
  var inst = new Popup(popup, getSettings(notificationQueue, settings, resolve, {
    display: settings.display || 'bottom',
    animate: animation,
    cssClass: (cssClass || 'mbsc-snackbar') + (settings.color ? ' mbsc-' + settings.color : ''),
    scrollLock: false,
    focusTrap: false,
    buttons: [],
    onMarkupReady: function onMarkupReady(event, inst) {
      var s = inst.settings;

      var button = inst._markup.find('button');

      button.addClass('mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : ''));
    },
    onShow: function onShow(ev, inst) {
      activeNotification = inst;

      if (settings.duration !== false) {
        notificationTimer = setTimeout(function () {
          if (inst) {
            inst.hide();
          }
        }, settings.duration || 3000);
      }

      if (settings.button) {
        inst.tap($$1('.mbsc-snackbar-btn', ev.target), function () {
          inst.hide();

          if (settings.button.action) {
            settings.button.action.call(this);
          }
        });
      }
    },
    onClose: function onClose() {
      activeNotification = null;
      clearTimeout(notificationTimer);
    }
  }));
  showNotification(inst);
}

function showToast(popup, settings, resolve) {
  showSnackbar(popup, settings, resolve, 'mbsc-toast', 'fade');
}

function show(func, popup, settings) {
  var p;

  if (hasPromise) {
    p = new Promise(function (resolve) {
      func(popup, settings, resolve);
    });
  } else {
    func(popup, settings);
  }

  return p;
}

mobiscroll.alert = function (settings) {
  var popup = document.createElement('div');
  popup.innerHTML = getMessage(settings);
  return show(showAlert, popup, settings);
};

mobiscroll.confirm = function (settings) {
  var popup = document.createElement('div');
  popup.innerHTML = getMessage(settings);
  return show(showConfirm, popup, settings);
};

mobiscroll.prompt = function (settings) {
  var popup = document.createElement('div');
  popup.innerHTML = getMessage(settings) + '<label class="mbsc-input">' + (settings.label ? '<span class="mbsc-label">' + settings.label + '</span>' : '') + '<input class="mbsc-control" tabindex="0" type="' + (settings.inputType || 'text') + '" placeholder="' + (settings.placeholder || '') + '" value="' + (settings.value || '') + '">' + '</label>';
  return show(showPrompt, popup, settings);
};

mobiscroll.snackbar = function (settings) {
  var popup = document.createElement('div'),
      btn = settings.button;
  popup.innerHTML = '<div class="mbsc-snackbar-cont"><div class="mbsc-snackbar-msg">' + (settings.message || '') + '</div>' + (btn ? '<button class="mbsc-snackbar-btn mbsc-btn mbsc-btn-flat">' + (btn.icon ? '<span class="mbsc-ic ' + (btn.text ? 'mbsc-btn-ic ' : '') + 'mbsc-ic-' + btn.icon + '"></span>' : '') + (btn.text || '') + '</button>' : '') + '</div>';
  return show(showSnackbar, popup, settings);
};

mobiscroll.toast = function (settings) {
  var popup = document.createElement('div');
  popup.innerHTML = '<div class="mbsc-toast-msg">' + (settings.message || '') + '</div>';
  return show(showToast, popup, settings);
};

mobiscroll.notification = {
  dismiss: function dismiss() {
    if (activeNotification) {
      activeNotification.hide();
    }
  }
};

var halfBorder$1 = os == 'ios' && majorVersion > 7;
var Form = function Form(el, settings) {
  var s,
      cssClass = '',
      $ctx = $$1(el),
      controls = {},
      that = this;

  function touched() {
    $ctx.removeClass('mbsc-no-touch');
  } // Call the parent constructor


  Base.call(this, el, settings, true);

  that.refresh = function (shallow) {
    if (s.enhance) {
      initControls($ctx, controls, s, shallow);
    }
  };
  /**
   * Form initialization.
   */


  that._init = function () {
    if (!mobiscroll.themes.form[s.theme]) {
      s.theme = 'mobiscroll';
    }

    if (!$ctx.hasClass('mbsc-form')) {
      $ctx.show();
      listen($ctx[0], 'touchstart', touched, {
        passive: true
      });
    }

    if (cssClass) {
      $ctx.removeClass(cssClass);
    } // --- TRIAL SERVER CODE START ---


    cssClass = 'mbsc-form mbsc-no-touch mbsc-' + s.theme + (halfBorder$1 ? ' mbsc-form-hb' : '') + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr') + (s.inputStyle == 'box' ? ' mbsc-form-box' : '') + (s.inputStyle == 'outline' ? ' mbsc-form-outline' : ''); // --- TRIAL SERVER CODE END ---

    $ctx.addClass(cssClass).removeClass('mbsc-cloak');
    that.refresh();
  };
  /**
   * Destroys the mobiscroll instance.
   */


  that._destroy = function () {
    $ctx.removeClass(cssClass);
    unlisten($ctx[0], 'touchstart', touched, {
      passive: true
    });

    for (var id in controls) {
      controls[id].destroy();
    }
  };
  /**
   * Object with the underlying form control instances
   * keys are the element id's
   */


  that.controls = controls; // Constructor

  s = that.settings;
  that.init();
}; // Extend defaults

Form.prototype = {
  _hasDef: true,
  _hasTheme: true,
  _hasLang: true,
  _class: 'form',
  _defaults: {
    tap: hasGhostClick,
    stopProp: true,
    rtl: false,
    enhance: true
  }
};
classes.Form = Form; // Init mbsc-form elements on page load

autoInit('[mbsc-enhance],[mbsc-form]', Form, true);

var MbscForm = (function (_super) {
    __extends(MbscForm, _super);
    function MbscForm(initialElem, _formService, zone) {
        var _this = _super.call(this, initialElem, zone) || this;
        _this._formService = _formService;
        _this.enhance = false;
        return _this;
    }
    MbscForm.prototype.ngOnInit = function () {
        this.optionsObj = extend$1({}, this.options, this.inlineOptionsObj);
        this._formService.options = this.optionsObj;
    };
    MbscForm.prototype.initControl = function () {
        var opt = this.options;
        if (opt && opt.enhance === undefined) {
            opt.enhance = false;
        }
        var options = extend$1({}, opt, this.inlineOptionsObj);
        this.instance = new Form(this.rootElem.nativeElement, options);
    };
    MbscForm.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-form',
                    template: "<div #rootElement><ng-content></ng-content></div>",
                    providers: [MbscOptionsService],
                    exportAs: 'mobiscroll'
                },] },
    ];
    MbscForm.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, },
        { type: NgZone, },
    ]; };
    MbscForm.propDecorators = {
        'options': [{ type: Input$1, args: ['options',] },],
        'enhance': [{ type: Input$1 },],
        'context': [{ type: Input$1 },],
        'inputStyle': [{ type: Input$1, args: ['input-style',] },],
        'labelStyle': [{ type: Input$1, args: ['label-style',] },],
        'rootElem': [{ type: ViewChild, args: ['rootElement', { static: false },] },],
    };
    return MbscForm;
}(MbscBase));
var MbscTextarea = (function (_super) {
    __extends(MbscTextarea, _super);
    function MbscTextarea(initialElem, _formService, _inputService, _control, zone) {
        var _this = _super.call(this, initialElem, _formService, _inputService, _control, zone) || this;
        _this._inputService = _inputService;
        _inputService.input = _this;
        return _this;
    }
    MbscTextarea.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new TextArea(this._initElem.nativeElement, options);
    };
    MbscTextarea.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-textarea',
                    host: { 'class': 'mbsc-control-ng' },
                    template: "\n            <label \n                [class.mbsc-err]=\"error\"\n                [class.mbsc-input-box]=\"inputStyle == 'box'\"\n                [class.mbsc-input-outline]=\"inputStyle == 'outline'\"\n                [class.mbsc-label-stacked]=\"labelStyle == 'stacked'\"\n                [class.mbsc-label-inline]=\"labelStyle == 'inline'\"\n                [class.mbsc-label-floating]=\"labelStyle == 'floating'\"\n            >\n            <ng-content></ng-content>\n            <span class=\"mbsc-input-wrap\">\n                <textarea #initElement [placeholder]=\"placeholder\" [(ngModel)]=\"innerValue\" (blur)=\"onTouch($event)\"\n                    [attr.name]=\"name\"\n                    [attr.rows]=\"rows\"\n                    [attr.wrap]=\"wrap\"\n                    [attr.minlength]=\"minlength\"\n                    [attr.maxlength]=\"maxlength\"\n                    [attr.autocomplete]=\"autocomplete\" \n                    [attr.autocapitalize]=\"autocapitalize\"\n                    [attr.autocorrect]=\"autocorrect\"\n                    [attr.spellcheck]=\"spellcheck\"\n                    [attr.autofocus]=\"autofocus\"\n                    [attr.required]=\"required\"\n                    [attr.data-icon]=\"icon ? icon : null\"\n                    [attr.data-icon-align]=\"iconAlign ? iconAlign : null\"\n                    [disabled]=\"disabled\"\n                    [readonly]=\"_readonly\"></textarea>\n                <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n            </span>\n        </label>\n    ",
                    providers: [MbscInputService]
                },] },
    ];
    MbscTextarea.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    MbscTextarea.propDecorators = {
        'rows': [{ type: Input$1 },],
        'wrap': [{ type: Input$1 },],
    };
    return MbscTextarea;
}(MbscInputBase));
var MbscDropdown = (function (_super) {
    __extends(MbscDropdown, _super);
    function MbscDropdown(hostElem, formService, _inputService, control, zone) {
        var _this = _super.call(this, hostElem, formService, _inputService, control, zone) || this;
        _this._inputService = _inputService;
        _inputService.input = _this;
        return _this;
    }
    Object.defineProperty(MbscDropdown.prototype, "value", {
        set: function (v) {
            var _this = this;
            this._value = v;
            setTimeout(function () {
                _this.instance._setText();
            });
        },
        enumerable: true,
        configurable: true
    });
    MbscDropdown.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Select(this._initElem.nativeElement, options);
        var that = this;
        setTimeout(function () {
            that.instance._setText();
        });
    };
    MbscDropdown.prototype.writeValue = function (v) {
        this._value = v;
        if (this.instance) {
            var that_1 = this;
            setTimeout(function () {
                that_1.instance._setText();
            });
        }
    };
    MbscDropdown.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-dropdown',
                    host: { 'class': 'mbsc-control-ng' },
                    template: "\n            <label \n                [class.mbsc-err]=\"error\"\n                [class.mbsc-input-box]=\"inputStyle == 'box'\"\n                [class.mbsc-input-outline]=\"inputStyle == 'outline'\"\n                [class.mbsc-label-stacked]=\"labelStyle == 'stacked'\"\n                [class.mbsc-label-inline]=\"labelStyle == 'inline'\"\n                [class.mbsc-label-floating]=\"labelStyle == 'floating'\"\n            >\n            {{label}}\n            <span class=\"mbsc-input-wrap\">\n                <select #initElement\n                    [(ngModel)]=\"innerValue\" \n                    [attr.name]=\"name\"\n                    [attr.data-icon]=\"icon ? icon : null\"\n                    [attr.data-icon-align]=\"iconAlign ? iconAlign : null\"\n                    [disabled]=\"disabled\"\n                    (blur)=\"onTouch($event)\">\n                    <ng-content></ng-content>\n                </select>\n                <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n            </span>\n        </label>\n    ",
                    providers: [MbscInputService]
                },] },
    ];
    MbscDropdown.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    MbscDropdown.propDecorators = {
        'label': [{ type: Input$1 },],
        'icon': [{ type: Input$1 },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'value': [{ type: Input$1 },],
        'inputStyle': [{ type: Input$1, args: ['input-style',] },],
        'labelStyle': [{ type: Input$1, args: ['label-style',] },],
    };
    return MbscDropdown;
}(MbscFormValueBase));
var MbscButton = (function (_super) {
    __extends(MbscButton, _super);
    function MbscButton(hostElem, formService, zone) {
        var _this = _super.call(this, hostElem, formService, zone) || this;
        _this._flat = false;
        _this._block = false;
        _this._outline = false;
        _this._classesObj = {};
        _this.type = 'button';
        return _this;
    }
    Object.defineProperty(MbscButton.prototype, "cssClasses", {
        get: function () {
            for (var k in this._classesObj) {
                delete this._classesObj[k];
            }
            this._classesObj['mbsc-btn-flat'] = this._flat;
            this._classesObj['mbsc-btn-block'] = this._block;
            this._classesObj['mbsc-btn-outline'] = this._outline;
            if (this.classes) {
                var cssClasses = this.classes.split(' ');
                if (cssClasses.length) {
                    for (var i = 0; i < cssClasses.length; i++) {
                        if (cssClasses[i]) {
                            this._classesObj[cssClasses[i]] = true;
                        }
                    }
                }
            }
            if (this.color) {
                this._classesObj['mbsc-btn-' + this.color] = true;
            }
            return this._classesObj;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscButton.prototype, "flat", {
        set: function (val) {
            this._flat = emptyOrTrue(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscButton.prototype, "block", {
        set: function (val) {
            this._block = emptyOrTrue(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscButton.prototype, "outline", {
        set: function (val) {
            this._outline = emptyOrTrue(val);
        },
        enumerable: true,
        configurable: true
    });
    MbscButton.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Button(this._initElem.nativeElement, options);
    };
    MbscButton.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-button',
                    template: "\n        <button #initElement \n            [type]=\"type\"\n            [ngClass]=\"cssClasses\"\n            [attr.name]=\"name\"\n            [attr.data-icon]=\"icon ? icon : null\"\n            [disabled]=\"disabled\">\n            <ng-content></ng-content>\n        </button>\n    ",
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    MbscButton.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    MbscButton.propDecorators = {
        'classes': [{ type: Input$1, args: ['class',] },],
        'type': [{ type: Input$1 },],
        'icon': [{ type: Input$1 },],
        'flat': [{ type: Input$1 },],
        'block': [{ type: Input$1 },],
        'outline': [{ type: Input$1 },],
    };
    return MbscButton;
}(MbscFormBase));
var MbscCheckbox = (function (_super) {
    __extends(MbscCheckbox, _super);
    function MbscCheckbox(hostElem, cdr, formService, _inputService, control, zone) {
        var _this = _super.call(this, hostElem, formService, _inputService, control, zone) || this;
        _this.cdr = cdr;
        _this._colorClass = {};
        return _this;
    }
    Object.defineProperty(MbscCheckbox.prototype, "colorClass", {
        get: function () {
            for (var k in this._colorClass) {
                delete this._colorClass[k];
            }
            if (this.color) {
                this._colorClass['mbsc-checkbox-' + this.color] = true;
            }
            if (this.error) {
                this._colorClass['mbsc-err'] = true;
            }
            return this._colorClass;
        },
        enumerable: true,
        configurable: true
    });
    MbscCheckbox.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new CheckBox(this._initElem.nativeElement, options);
    };
    MbscCheckbox.prototype.writeValue = function (v) {
        this._value = v;
        this.cdr.detectChanges();
    };
    MbscCheckbox.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-checkbox',
                    host: { 'class': 'mbsc-control-ng' },
                    template: "\n        <label [ngClass]=\"colorClass\">\n            <input #initElement \n                type=\"checkbox\"\n                [attr.name]=\"name\"\n                [disabled]=\"disabled\"\n                [attr.data-label-style]=\"labelStyle\"\n                [attr.data-input-style]=\"inputStyle\"\n                [(ngModel)]=\"innerValue\"\n                (blur)=\"onTouch($event)\" />\n            <ng-content></ng-content>\n            <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n        </label>\n    ",
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    MbscCheckbox.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: ChangeDetectorRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    MbscCheckbox.propDecorators = {
        'color': [{ type: Input$1 },],
        'inputStyle': [{ type: Input$1, args: ['input-style',] },],
        'labelStyle': [{ type: Input$1, args: ['label-style',] },],
    };
    return MbscCheckbox;
}(MbscFormValueBase));
var MbscSwitch = (function (_super) {
    __extends(MbscSwitch, _super);
    function MbscSwitch(hostElem, zone, _formService, control) {
        var _this = _super.call(this, hostElem, zone, control, null, null) || this;
        _this._formService = _formService;
        _this.disabled = false;
        _this.onChangeEmitter = new EventEmitter();
        _this._colorClass = {};
        return _this;
    }
    Object.defineProperty(MbscSwitch.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscSwitch.prototype, "colorClass", {
        get: function () {
            for (var k in this._colorClass) {
                delete this._colorClass[k];
            }
            if (this.color) {
                this._colorClass['mbsc-switch-' + this.color] = true;
            }
            if (this.error) {
                this._colorClass['mbsc-err'] = true;
            }
            return this._colorClass;
        },
        enumerable: true,
        configurable: true
    });
    MbscSwitch.prototype.setNewValue = function (v) {
        if (this.instance) {
            if (this.instance.getVal() !== v) {
                this.instance.setVal(v, true, false);
            }
        }
    };
    MbscSwitch.prototype.ngOnInit = function () {
        this._inheritedOptions = this._formService ? this._formService.options : {};
        _super.prototype.ngOnInit.call(this);
    };
    MbscSwitch.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Switch(this._initElem.nativeElement, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscSwitch.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-switch',
                    host: { 'class': 'mbsc-control-ng' },
                    template: "\n        <label [ngClass]=\"colorClass\">\n            <ng-content></ng-content>\n            <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n            <input #initElement \n                type=\"checkbox\"\n                data-role=\"switch\"\n                [attr.name]=\"name\"\n                [attr.data-label-style]=\"labelStyle\"\n                [attr.data-input-style]=\"inputStyle\"\n                [disabled]=\"disabled\"\n                (blur)=\"onTouch($event)\" />\n        </label>\n    ",
                    exportAs: 'mobiscroll',
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    MbscSwitch.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: NgControl, decorators: [{ type: Optional },] },
    ]; };
    MbscSwitch.propDecorators = {
        'options': [{ type: Input$1, args: ['options',] },],
        'disabled': [{ type: Input$1 },],
        'name': [{ type: Input$1 },],
        'color': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'value': [{ type: Input$1, args: ['value',] },],
        'onChangeEmitter': [{ type: Output, args: ['valueChange',] },],
        '_initElem': [{ type: ViewChild, args: ['initElement', { static: false },] },],
    };
    return MbscSwitch;
}(MbscControlBase));
var MbscStepper = (function (_super) {
    __extends(MbscStepper, _super);
    function MbscStepper(hostElement, zone, _formService, control) {
        var _this = _super.call(this, hostElement, zone, control, null, null) || this;
        _this._formService = _formService;
        _this.min = undefined;
        _this.max = undefined;
        _this.step = undefined;
        _this.val = undefined;
        _this.disabled = false;
        _this._colorClass = {};
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscStepper.prototype, "readonly", {
        set: function (val) {
            this._readonly = emptyOrTrue(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscStepper.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscStepper.prototype, "colorClass", {
        get: function () {
            for (var k in this._colorClass) {
                delete this._colorClass[k];
            }
            if (this.color) {
                this._colorClass['mbsc-stepper-' + this.color] = true;
            }
            return this._colorClass;
        },
        enumerable: true,
        configurable: true
    });
    MbscStepper.prototype.setNewValue = function (v) {
        if (this.instance && this.instance.getVal() !== v) {
            this.instance.setVal(v, true, false);
        }
    };
    MbscStepper.prototype.ngOnInit = function () {
        this._inheritedOptions = this._formService ? this._formService.options : {};
        _super.prototype.ngOnInit.call(this);
    };
    MbscStepper.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Stepper(this._initElem.nativeElement, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscStepper.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-stepper',
                    host: { 'class': 'mbsc-control-ng' },
                    template: "\n        <div [ngClass]=\"colorClass\">\n            <ng-content></ng-content>\n            <input #initElement\n                data-role=\"stepper\"\n                [attr.name]=\"name\"\n                [attr.min]=\"min !== undefined ? min : null\"\n                [attr.max]=\"max !== undefined ? max : null\"\n                [attr.step]=\"step !== undefined ? step : null\"\n                [attr.data-val]=\"val ? val : null\"\n                [attr.data-label-style]=\"labelStyle\"\n                [attr.data-input-style]=\"inputStyle\"\n                [disabled]=\"disabled\" \n                [readonly]=\"_readonly\"/>\n        </div>\n    ",
                    exportAs: 'mobiscroll',
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    MbscStepper.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: NgControl, decorators: [{ type: Optional },] },
    ]; };
    MbscStepper.propDecorators = {
        'readonly': [{ type: Input$1 },],
        'options': [{ type: Input$1, args: ['options',] },],
        'value': [{ type: Input$1 },],
        'name': [{ type: Input$1 },],
        'min': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'step': [{ type: Input$1 },],
        'val': [{ type: Input$1 },],
        'disabled': [{ type: Input$1 },],
        'color': [{ type: Input$1 },],
        'onChangeEmitter': [{ type: Output, args: ['valueChange',] },],
        '_initElem': [{ type: ViewChild, args: ['initElement', { static: false },] },],
    };
    return MbscStepper;
}(MbscControlBase));
var MbscProgress = (function (_super) {
    __extends(MbscProgress, _super);
    function MbscProgress(hostElement, zone, _formService, control) {
        var _this = _super.call(this, hostElement, zone, control, null, null) || this;
        _this._formService = _formService;
        _this.max = undefined;
        _this.icon = undefined;
        _this.iconAlign = undefined;
        _this.val = undefined;
        _this.disabled = false;
        _this._colorClass = {};
        return _this;
    }
    Object.defineProperty(MbscProgress.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscProgress.prototype, "dataStepLabels", {
        get: function () {
            if (typeof (this.stepLabels) === 'string') {
                return this.stepLabels;
            }
            else {
                return null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscProgress.prototype, "colorClass", {
        get: function () {
            for (var k in this._colorClass) {
                delete this._colorClass[k];
            }
            if (this.color) {
                this._colorClass['mbsc-progress-' + this.color] = true;
            }
            return this._colorClass;
        },
        enumerable: true,
        configurable: true
    });
    MbscProgress.prototype.setNewValue = function (v) {
        if (this.instance && this.instance.getVal() !== v) {
            this.instance.setVal(v, true, false);
        }
    };
    MbscProgress.prototype.ngOnInit = function () {
        this._inheritedOptions = this._formService ? this._formService.options : {};
        _super.prototype.ngOnInit.call(this);
    };
    MbscProgress.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Progress(this._initElem.nativeElement, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscProgress.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-progress',
                    host: { 'class': 'mbsc-control-ng' },
                    template: "\n        <label [ngClass]=\"colorClass\">\n            <ng-content></ng-content>\n            <progress #initElement\n                [attr.data-step-labels]=\"dataStepLabels\"\n                [attr.data-icon]=\"icon ? icon : null\"\n                [attr.data-icon-align]=\"iconAlign ? iconAlign : null\"\n                [attr.data-label-style]=\"labelStyle\"\n                [attr.data-input-style]=\"inputStyle\"\n                [attr.max]=\"max !== undefined ? max : null\"\n                [attr.data-val]=\"val !== undefined ? val : null\"\n            >\n            </progress>\n        </label>\n    ",
                    exportAs: 'mobiscroll',
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    MbscProgress.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: NgControl, decorators: [{ type: Optional },] },
    ]; };
    MbscProgress.propDecorators = {
        'options': [{ type: Input$1, args: ['options',] },],
        'value': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'icon': [{ type: Input$1 },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'val': [{ type: Input$1 },],
        'disabled': [{ type: Input$1 },],
        'stepLabels': [{ type: Input$1, args: ['step-labels',] },],
        'color': [{ type: Input$1 },],
        '_initElem': [{ type: ViewChild, args: ['initElement', { static: false },] },],
    };
    return MbscProgress;
}(MbscControlBase));
var groupName = 1;
var MbscRadioService = (function () {
    function MbscRadioService() {
        this._lastValue = null;
        this._valueObservable = new Observable();
    }
    Object.defineProperty(MbscRadioService.prototype, "name", {
        get: function () {
            if (!this._name) {
                this._name = 'mbsc-radio-group-' + (groupName++);
            }
            return this._name;
        },
        set: function (n) {
            this._name = n;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscRadioService.prototype, "multiSelect", {
        get: function () {
            return this._multiSelect;
        },
        set: function (v) {
            this._multiSelect = v;
        },
        enumerable: true,
        configurable: true
    });
    MbscRadioService.prototype.onValueChanged = function () {
        return this._valueObservable;
    };
    MbscRadioService.prototype.changeValue = function (v) {
        this._valueObservable.next(v);
        this._lastValue = v;
    };
    Object.defineProperty(MbscRadioService.prototype, "getLastValue", {
        get: function () {
            return this._lastValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscRadioService.prototype, "color", {
        get: function () {
            return this._color;
        },
        set: function (v) {
            this._color = v;
        },
        enumerable: true,
        configurable: true
    });
    MbscRadioService.decorators = [
        { type: Injectable },
    ];
    MbscRadioService.ctorParameters = function () { return []; };
    return MbscRadioService;
}());
var MbscRadioGroupBase = (function (_super) {
    __extends(MbscRadioGroupBase, _super);
    function MbscRadioGroupBase(hostElement, formService, _inputService, _radioService, control, zone) {
        var _this = _super.call(this, hostElement, formService, _inputService, control, zone) || this;
        _this._radioService = _radioService;
        _this.valueObserver = _this._radioService.onValueChanged().subscribe(function (v) {
            _this.innerValue = v;
            _this.onTouch();
        });
        return _this;
    }
    Object.defineProperty(MbscRadioGroupBase.prototype, "value", {
        set: function (v) {
            this._value = v;
            this._radioService.changeValue(v);
        },
        enumerable: true,
        configurable: true
    });
    MbscRadioGroupBase.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
        if (this.name) {
            this._radioService.name = this.name;
        }
        if (this.color) {
            this._radioService.color = this.color;
        }
    };
    MbscRadioGroupBase.prototype.writeValue = function (v) {
        this._value = v;
        this._radioService.changeValue(v);
    };
    MbscRadioGroupBase.prototype.updateOptions = function () { };
    MbscRadioGroupBase.prototype.ngOnDestroy = function () {
        this._radioService.onValueChanged().unsubscribe(this.valueObserver);
        _super.prototype.ngOnDestroy.call(this);
    };
    MbscRadioGroupBase.decorators = [
        { type: Directive, args: [{ selector: '[mbsc-rg-b]' },] },
    ];
    MbscRadioGroupBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscRadioService, },
        { type: NgControl, },
        { type: NgZone, },
    ]; };
    MbscRadioGroupBase.propDecorators = {
        'name': [{ type: Input$1 },],
        'value': [{ type: Input$1 },],
    };
    return MbscRadioGroupBase;
}(MbscFormValueBase));
var MbscRadioGroup = (function (_super) {
    __extends(MbscRadioGroup, _super);
    function MbscRadioGroup(hostElement, formService, _inputService, radioService, control, zone) {
        return _super.call(this, hostElement, formService, _inputService, radioService, control, zone) || this;
    }
    MbscRadioGroup.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-radio-group',
                    template: "<ng-content></ng-content>",
                    providers: [MbscRadioService]
                },] },
    ];
    MbscRadioGroup.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscRadioService, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    return MbscRadioGroup;
}(MbscRadioGroupBase));
var MbscRadio = (function (_super) {
    __extends(MbscRadio, _super);
    function MbscRadio(hostElement, formService, _radioService, zone) {
        var _this = _super.call(this, hostElement, formService, zone) || this;
        _this._radioService = _radioService;
        _this._colorClass = {};
        var v = _this._radioService.getLastValue;
        if (v !== null) {
            _this.modelValue = v;
        }
        _this.valueObserver = _this._radioService.onValueChanged().subscribe(function (v) {
            _this.modelValue = v;
        });
        return _this;
    }
    Object.defineProperty(MbscRadio.prototype, "checked", {
        get: function () {
            return this.value == this.modelValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscRadio.prototype, "colorClass", {
        get: function () {
            for (var k in this._colorClass) {
                delete this._colorClass[k];
            }
            if (this.color) {
                this._colorClass['mbsc-radio-' + this.color] = true;
            }
            if (this.error) {
                this._colorClass['mbsc-err'] = true;
            }
            return this._colorClass;
        },
        enumerable: true,
        configurable: true
    });
    MbscRadio.prototype.clicked = function (e) {
        this._radioService.changeValue(this.value);
    };
    MbscRadio.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Radio(this._initElem.nativeElement, options);
    };
    MbscRadio.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
        this.name = this._radioService.name;
        this.color = this._radioService.color;
    };
    MbscRadio.prototype.ngOnDestroy = function () {
        this._radioService.onValueChanged().unsubscribe(this.valueObserver);
        _super.prototype.ngOnDestroy.call(this);
    };
    MbscRadio.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-radio',
                    host: { 'class': 'mbsc-control-ng' },
                    template: "\n        <label [ngClass]=\"colorClass\">\n            <input #initElement \n                type=\"radio\" \n                [attr.name]=\"name\" \n                [attr.value]=\"value\"\n                [value]=\"value\" \n                [checked]=\"checked\"\n                [disabled]=\"disabled\"\n                (click)=\"clicked($event)\" />\n            <ng-content></ng-content>\n            <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n        </label>\n    "
                },] },
    ];
    MbscRadio.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscRadioService, },
        { type: NgZone, },
    ]; };
    MbscRadio.propDecorators = {
        'value': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
    };
    return MbscRadio;
}(MbscFormBase));
var MbscSegmentedGroup = (function (_super) {
    __extends(MbscSegmentedGroup, _super);
    function MbscSegmentedGroup(hostElement, formService, _inputService, radioService, control, zone) {
        var _this = _super.call(this, hostElement, formService, _inputService, radioService, control, zone) || this;
        _this.select = 'single';
        return _this;
    }
    Object.defineProperty(MbscSegmentedGroup.prototype, "multiSelect", {
        get: function () {
            return this.select == 'multiple';
        },
        enumerable: true,
        configurable: true
    });
    MbscSegmentedGroup.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
        this._radioService.multiSelect = this.multiSelect;
        if (this.color) {
            this._radioService.color = this.color;
        }
    };
    MbscSegmentedGroup.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-segmented-group',
                    template: "<div class=\"mbsc-segmented mbsc-segmented-group mbsc-no-touch\"><ng-content></ng-content></div>",
                    providers: [MbscRadioService]
                },] },
    ];
    MbscSegmentedGroup.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscRadioService, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    MbscSegmentedGroup.propDecorators = {
        'select': [{ type: Input$1 },],
    };
    return MbscSegmentedGroup;
}(MbscRadioGroupBase));
var MbscSegmented = (function (_super) {
    __extends(MbscSegmented, _super);
    function MbscSegmented(hostElement, formService, _radioService, zone) {
        var _this = _super.call(this, hostElement, formService, zone) || this;
        _this._radioService = _radioService;
        _this.checkedChange = new EventEmitter();
        var v = _this._radioService.getLastValue;
        if (v !== null) {
            _this.modelValue = v;
        }
        _this.valueObserver = _this._radioService.onValueChanged().subscribe(function (v) {
            _this.modelValue = v;
        });
        return _this;
    }
    Object.defineProperty(MbscSegmented.prototype, "isChecked", {
        get: function () {
            if (this.multiSelect) {
                if (this.checked !== undefined) {
                    return this.checked;
                }
                else {
                    return this.modelValue && this.modelValue.includes(this.value);
                }
            }
            else {
                return this.value == this.modelValue;
            }
        },
        enumerable: true,
        configurable: true
    });
    MbscSegmented.prototype.clicked = function (e) {
        if (this.multiSelect && this.checked !== undefined) {
            this.checkedChange.emit(!(!!this.checked));
        }
        else {
            if (this.multiSelect) {
                if (this.modelValue.includes(this.value)) {
                    var i = this.modelValue.indexOf(this.value);
                    this.modelValue.splice(i, 1);
                }
                else {
                    this.modelValue.push(this.value);
                }
                this._radioService.changeValue(this.modelValue);
            }
            else {
                this._radioService.changeValue(this.value);
            }
        }
    };
    Object.defineProperty(MbscSegmented.prototype, "cssClass", {
        get: function () {
            var cl = 'mbsc-segmented-item';
            if (this.color) {
                cl += ' mbsc-segmented-' + this.color;
            }
            return cl;
        },
        enumerable: true,
        configurable: true
    });
    MbscSegmented.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new SegmentedItem(this._initElem.nativeElement, options);
    };
    MbscSegmented.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
        this.name = this._radioService.name;
        this.multiSelect = this._radioService.multiSelect;
        this.color = this._radioService.color;
    };
    MbscSegmented.prototype.ngOnDestroy = function () {
        this._radioService.onValueChanged().unsubscribe(this.valueObserver);
        _super.prototype.ngOnDestroy.call(this);
    };
    MbscSegmented.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-segmented',
                    host: { '[class]': 'cssClass' },
                    template: "\n        <label class=\"mbsc-segmented-item-ready\">\n            <input #initElement \n                data-role=\"segmented\"\n                [type]=\"multiSelect ? 'checkbox' : 'radio'\" \n                [value]=\"value\" \n                [checked]=\"isChecked\"\n                [disabled]=\"disabled\"\n                [attr.name]=\"name\" \n                [attr.value]=\"value\"\n                [attr.data-icon]=\"icon ? icon : null\"\n                (click)=\"clicked($event)\" />\n            <span class=\"mbsc-segmented-content\">\n                <span *ngIf=\"icon\" class=\"{{'mbsc-ic mbsc-ic-' + icon }}\"></span>\n                <ng-content></ng-content>\n            </span>\n        </label>\n    "
                },] },
    ];
    MbscSegmented.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscRadioService, },
        { type: NgZone, },
    ]; };
    MbscSegmented.propDecorators = {
        'icon': [{ type: Input$1 },],
        'value': [{ type: Input$1 },],
        'checked': [{ type: Input$1 },],
        'checkedChange': [{ type: Output },],
    };
    return MbscSegmented;
}(MbscFormBase));
var MbscSlider = (function (_super) {
    __extends(MbscSlider, _super);
    function MbscSlider(hostElement, _formService, zone, control) {
        var _this = _super.call(this, hostElement, zone, control, null, null) || this;
        _this._formService = _formService;
        _this._dummy = undefined;
        _this._needsTimeout = false;
        _this.disabled = false;
        _this._colorClass = {};
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscSlider.prototype, "isMulti", {
        get: function () {
            return this._lastValue instanceof Array;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscSlider.prototype, "dummyArray", {
        get: function () {
            if (!this._dummy || (this.isMulti && this._lastValue && this._lastValue.length && this._dummy.length !== this._lastValue.length)) {
                this._dummy = Array(this.isMulti ? this._lastValue.length : 1).fill(0).map(function (x, i) { return i; });
            }
            return this._dummy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscSlider.prototype, "dataStepLabels", {
        get: function () {
            if (typeof (this.stepLabels) === 'string') {
                return this.stepLabels;
            }
            else {
                return null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscSlider.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscSlider.prototype, "colorClass", {
        get: function () {
            for (var k in this._colorClass) {
                delete this._colorClass[k];
            }
            if (this.color) {
                this._colorClass['mbsc-slider-' + this.color] = true;
            }
            return this._colorClass;
        },
        enumerable: true,
        configurable: true
    });
    MbscSlider.prototype.reInitialize = function () {
        var _this = this;
        this.instance.destroy();
        this.setElement();
        this.inputElements.forEach(function (input, index) {
            if (index) {
                _this.handleChange(input.nativeElement);
            }
        });
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Slider(this.inputElements.first.nativeElement, options);
    };
    MbscSlider.prototype.setNewValue = function (v) {
        var _this = this;
        this._lastValue = v;
        if (this.instance) {
            var innerValue = this.instance.getVal();
            if (this.isMulti && (!innerValue || innerValue.length != v.length)) {
                setTimeout(function () {
                    _this.reInitialize();
                    _this.instance.setVal(_this._lastValue, true, false);
                });
            }
            else {
                var changed = (this.isMulti && !deepEqualsArray(innerValue, v)) || (!this.isMulti && innerValue !== v);
                if (changed) {
                    this.instance.setVal(v, true, false);
                }
            }
        }
    };
    MbscSlider.prototype.ngOnInit = function () {
        this._inheritedOptions = this._formService ? this._formService.options : {};
        _super.prototype.ngOnInit.call(this);
    };
    MbscSlider.prototype.initControl = function () {
        var _this = this;
        this.inputElements.forEach(function (input, index) {
            if (index) {
                _this.handleChange(input.nativeElement);
            }
        });
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Slider(this.inputElements.first.nativeElement, options);
        if (this.initialValue !== undefined && this.initialValue !== null) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscSlider.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-slider',
                    host: { 'class': 'mbsc-control-ng' },
                    template: "\n        <label [ngClass]=\"colorClass\">\n            <ng-content></ng-content>\n            <input #inputElements *ngFor=\"let v of dummyArray\" \n                type=\"range\"\n                [disabled]=\"disabled\"\n                [attr.value]=\"dummyArray.length > 1 && initialValue ? initialValue[v]: initialValue\"\n                [attr.data-step-labels]=\"dataStepLabels\"\n                [attr.data-template]=\"valueTemplate\"\n                [attr.data-tooltip]=\"tooltip ? 'true' : null\"\n                [attr.data-highlight]=\"highlight\"\n                [attr.data-live]=\"live\"\n                [attr.data-icon]=\"icon ? icon : null\"\n                [attr.data-val]=\"val ? val : null\"\n                [attr.data-label-style]=\"labelStyle\"\n                [attr.data-input-style]=\"inputStyle\"\n                [attr.name]=\"name\"\n                [attr.max]=\"max !== undefined ? max : null\"\n                [attr.min]=\"min !== undefined ? min : null\"\n                [attr.step]=\"step !== undefined ? step : null\"\n                (blur)=\"onTouch($event)\" />\n        </label>\n    ",
                    exportAs: 'mobiscroll'
                },] },
    ];
    MbscSlider.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
    ]; };
    MbscSlider.propDecorators = {
        'options': [{ type: Input$1, args: ['options',] },],
        'name': [{ type: Input$1 },],
        'tooltip': [{ type: Input$1 },],
        'highlight': [{ type: Input$1 },],
        'live': [{ type: Input$1 },],
        'valueTemplate': [{ type: Input$1, args: ['value-template',] },],
        'icon': [{ type: Input$1 },],
        'val': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'min': [{ type: Input$1 },],
        'step': [{ type: Input$1 },],
        'disabled': [{ type: Input$1 },],
        'stepLabels': [{ type: Input$1, args: ['step-labels',] },],
        'value': [{ type: Input$1, args: ['value',] },],
        'color': [{ type: Input$1 },],
        'onChangeEmitter': [{ type: Output, args: ['valueChange',] },],
        'inputElements': [{ type: ViewChildren, args: ['inputElements',] },],
    };
    return MbscSlider;
}(MbscControlBase));
var MbscRating = (function (_super) {
    __extends(MbscRating, _super);
    function MbscRating(hostElem, zone, formService, control) {
        var _this = _super.call(this, hostElem, zone, control, null, null) || this;
        _this.formService = formService;
        _this.min = undefined;
        _this.max = undefined;
        _this.step = undefined;
        _this.disabled = false;
        _this.val = undefined;
        _this.onChangeEmitter = new EventEmitter();
        _this._colorClass = {};
        return _this;
    }
    Object.defineProperty(MbscRating.prototype, "readonly", {
        set: function (val) {
            this._readonly = emptyOrTrue(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscRating.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscRating.prototype, "colorClass", {
        get: function () {
            for (var k in this._colorClass) {
                delete this._colorClass[k];
            }
            if (this.color) {
                this._colorClass['mbsc-rating-' + this.color] = true;
            }
            return this._colorClass;
        },
        enumerable: true,
        configurable: true
    });
    MbscRating.prototype.setNewValue = function (v) {
        if (this.instance) {
            if (this.instance.getVal() !== v) {
                this.instance.setVal(v, true, false);
            }
        }
    };
    MbscRating.prototype.ngOnInit = function () {
        this._inheritedOptions = this.formService ? this.formService.options : {};
        _super.prototype.ngOnInit.call(this);
    };
    MbscRating.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Rating(this.element, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscRating.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-rating',
                    host: { 'class': 'mbsc-control-ng' },
                    template: "<label [ngClass]=\"colorClass\">\n        <ng-content></ng-content>\n        <input type=\"rating\" data-role=\"rating\" \n            [attr.name]=\"name\"\n            [attr.min]=\"min !== undefined ? min : null\"\n            [attr.max]=\"max !== undefined ? max : null\"\n            [attr.step]=\"step !== undefined ? step : null\"\n            [attr.data-val]=\"val ? val : null\"\n            [attr.data-template]=\"template ? template : null\"\n            [attr.data-empty]=\"empty\"\n            [attr.data-filled]=\"filled\"\n            [attr.data-label-style]=\"labelStyle\"\n            [attr.data-input-style]=\"inputStyle\"\n            [disabled]=\"disabled\"\n            [readonly]=\"_readonly\"\n            (blur)=\"onTouch($event)\" />\n    </label>"
                },] },
    ];
    MbscRating.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: NgControl, decorators: [{ type: Optional },] },
    ]; };
    MbscRating.propDecorators = {
        'options': [{ type: Input$1 },],
        'name': [{ type: Input$1 },],
        'min': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'step': [{ type: Input$1 },],
        'disabled': [{ type: Input$1 },],
        'empty': [{ type: Input$1 },],
        'filled': [{ type: Input$1 },],
        'readonly': [{ type: Input$1 },],
        'val': [{ type: Input$1 },],
        'template': [{ type: Input$1 },],
        'value': [{ type: Input$1, args: ['value',] },],
        'onChangeEmitter': [{ type: Output, args: ['valueChange',] },],
        'color': [{ type: Input$1 },],
    };
    return MbscRating;
}(MbscControlBase));
var MbscFormGroup = (function () {
    function MbscFormGroup(initialElem) {
        this.initialElem = initialElem;
        this.collapsible = null;
        this._open = false;
        this.instance = null;
        this.element = null;
        this.element = initialElem;
    }
    Object.defineProperty(MbscFormGroup.prototype, "open", {
        set: function (v) {
            if (this._open != v && this.instance) {
                if (v) {
                    this.instance.show();
                }
                else {
                    this.instance.hide();
                }
            }
            this._open = v;
        },
        enumerable: true,
        configurable: true
    });
    MbscFormGroup.prototype.emptyOrTrue = function (v) {
        return emptyOrTrue(v);
    };
    MbscFormGroup.prototype.ngAfterViewInit = function () {
        if (this.collapsible !== null) {
            this.instance = new CollapsibleBase(this.element.nativeElement, { isOpen: this._open !== false });
        }
    };
    MbscFormGroup.prototype.ngOnDestroy = function () {
        if (this.instance) {
            this.instance.destroy();
        }
    };
    MbscFormGroup.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-form-group',
                    template: '<ng-content></ng-content>',
                    host: {
                        '[class.mbsc-form-group-inset]': 'emptyOrTrue(inset)',
                        '[class.mbsc-form-group]': '!emptyOrTrue(inset)'
                    },
                    styles: [':host { display: block; }']
                },] },
    ];
    MbscFormGroup.ctorParameters = function () { return [
        { type: ElementRef, },
    ]; };
    MbscFormGroup.propDecorators = {
        'collapsible': [{ type: Input$1 },],
        'open': [{ type: Input$1 },],
        'inset': [{ type: Input$1 },],
    };
    return MbscFormGroup;
}());
var MbscFormGroupTitle = (function () {
    function MbscFormGroupTitle() {
    }
    MbscFormGroupTitle.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-form-group-title',
                    template: '<ng-content></ng-content>',
                    host: {
                        '[class.mbsc-form-group-title]': 'true'
                    },
                    styles: [':host { display: block; }']
                },] },
    ];
    MbscFormGroupTitle.ctorParameters = function () { return []; };
    return MbscFormGroupTitle;
}());
var MbscFormGroupContent = (function () {
    function MbscFormGroupContent() {
    }
    MbscFormGroupContent.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-form-group-content',
                    template: '<ng-content></ng-content>',
                    host: {
                        '[class.mbsc-form-group-content]': 'true'
                    },
                    styles: [':host { display: block; }']
                },] },
    ];
    MbscFormGroupContent.ctorParameters = function () { return []; };
    return MbscFormGroupContent;
}());
var MbscAccordion = (function () {
    function MbscAccordion() {
    }
    MbscAccordion.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-accordion',
                    template: '<ng-content></ng-content>',
                    host: {
                        '[class.mbsc-accordion]': 'true'
                    },
                    styles: [':host { display: block; }']
                },] },
    ];
    MbscAccordion.ctorParameters = function () { return []; };
    return MbscAccordion;
}());
var comp = [
    MbscForm,
    MbscTextarea,
    MbscDropdown,
    MbscButton,
    MbscCheckbox,
    MbscSwitch,
    MbscStepper,
    MbscProgress,
    MbscRadioGroup,
    MbscRadioGroupBase,
    MbscRadio,
    MbscSegmentedGroup,
    MbscSegmented,
    MbscSlider,
    MbscRating,
    MbscFormGroup,
    MbscFormGroupTitle,
    MbscFormGroupContent,
    MbscAccordion
];
var MbscFormsModule = (function () {
    function MbscFormsModule() {
    }
    MbscFormsModule.decorators = [
        { type: NgModule, args: [{
                    imports: [FormsModule, CommonModule, MbscBaseModule, MbscInputModule],
                    declarations: comp,
                    exports: [comp, MbscInputModule, MbscInput]
                },] },
    ];
    MbscFormsModule.ctorParameters = function () { return []; };
    return MbscFormsModule;
}());

// ---

var Page = function Page(el, settings) {
  var cssClass = '',
      $elm = $$1(el),
      that = this,
      s = that.settings; // Call the parent constructor

  Base.call(this, el, settings, true);
  /**
   * Page initialization.
   */

  that._init = function () {
    var ctx = s.context,
        $ctx = $$1(ctx),
        $topMenu = $ctx.find('.mbsc-ms-top .mbsc-ms'),
        $bottomMenu = $ctx.find('.mbsc-ms-bottom .mbsc-ms'),
        css = {};

    if (ctx == 'body') {
      $$1('body,html').addClass('mbsc-page-ctx');
    } else {
      $ctx.addClass('mbsc-page-ctx');
    }

    if (cssClass) {
      $elm.removeClass(cssClass);
    }

    if ($topMenu.length) {
      css.paddingTop = $topMenu[0].offsetHeight;
    }

    if ($bottomMenu.length) {
      css.paddingBottom = $bottomMenu[0].offsetHeight;
    }

    cssClass = 'mbsc-page mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');
    $elm.addClass(cssClass).removeClass('mbsc-cloak').css(css);
  };
  /**
   * Destroys the mobiscroll instance.
   */


  that._destroy = function () {
    $elm.removeClass(cssClass);
  }; // Constructor


  s = that.settings;
  that.init();
}; // Extend defaults

Page.prototype = {
  _hasDef: true,
  _hasTheme: true,
  _hasLang: true,
  _class: 'page',
  _defaults: {
    context: 'body'
  }
};
classes.Page = Page;
mobiscroll.themes.page.mobiscroll = {}; // ---
// Page end
// Init mbsc-page elements on page load or when mbsc-enhance event is triggeres

autoInit('[mbsc-page]', Page);

var MbscPage = (function (_super) {
    __extends(MbscPage, _super);
    function MbscPage(hostElement, optionsService, zone) {
        var _this = _super.call(this, hostElement, zone) || this;
        _this.optionsService = optionsService;
        return _this;
    }
    MbscPage.prototype.ngOnInit = function () {
        var optionsObj = extend$1({}, this.options, this.inlineOptionsObj);
        this.optionsService.options = optionsObj;
    };
    MbscPage.prototype.initControl = function () {
        var options = extend$1({}, this.options, this.inlineOptionsObj);
        this.instance = new Page(this.initElem.nativeElement, options);
    };
    MbscPage.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-page',
                    template: '<div #initElement><ng-content></ng-content></div>',
                    providers: [MbscOptionsService],
                    exportAs: 'mobiscroll'
                },] },
    ];
    MbscPage.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, },
        { type: NgZone, },
    ]; };
    MbscPage.propDecorators = {
        'options': [{ type: Input$1 },],
        'context': [{ type: Input$1 },],
        'initElem': [{ type: ViewChild, args: ['initElement', { static: false },] },],
    };
    return MbscPage;
}(MbscBase));
var MbscNote = (function () {
    function MbscNote(initialElem) {
        this.initialElem = initialElem;
        this.color = 'primary';
    }
    Object.defineProperty(MbscNote.prototype, "classNames", {
        get: function () {
            return 'mbsc-note mbsc-note-' + this.color;
        },
        enumerable: true,
        configurable: true
    });
    MbscNote.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-note',
                    template: '<ng-content></ng-content>',
                    host: {
                        '[class]': 'classNames'
                    },
                    styles: [':host { display: block; }']
                },] },
    ];
    MbscNote.ctorParameters = function () { return [
        { type: ElementRef, },
    ]; };
    MbscNote.propDecorators = {
        'color': [{ type: Input$1 },],
    };
    return MbscNote;
}());
var MbscAvatar = (function () {
    function MbscAvatar() {
        this.draggable = false;
    }
    MbscAvatar.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-avatar',
                    template: '<img class="mbsc-avatar" [src]="src" [alt]="alt" [draggable]="draggable" />'
                },] },
    ];
    MbscAvatar.ctorParameters = function () { return []; };
    MbscAvatar.propDecorators = {
        'draggable': [{ type: Input$1 },],
        'src': [{ type: Input$1 },],
        'alt': [{ type: Input$1 },],
    };
    return MbscAvatar;
}());
var MbscPageModule = (function () {
    function MbscPageModule() {
    }
    MbscPageModule.decorators = [
        { type: NgModule, args: [{
                    imports: [MbscBaseModule],
                    declarations: [MbscPage, MbscNote, MbscAvatar],
                    exports: [MbscPage, MbscNote, MbscAvatar]
                },] },
    ];
    MbscPageModule.ctorParameters = function () { return []; };
    return MbscPageModule;
}());

var MbscCommercialComponent = function (_super) {
  __extends(MbscCommercialComponent, _super);

  function MbscCommercialComponent(hostElement, optionsService, zone) {
    var _this = _super.call(this, hostElement, zone) || this;

    _this.optionsService = optionsService;
    _this.mbscOptions = {};
    _this.options = {};
    return _this;
  }

  MbscCommercialComponent.prototype.ngAfterViewInit = function () {
    if (!mobiscroll.alerted) {
      mobiscroll.confirm({
        title: 'Mobiscroll Lite doesn\'t support this functionality.',
        message: 'You can try the full toolset with a free trial. If you\'re having trouble, <a href="mailto:support@mobiscroll.com" target="_top">let us know</a>.',
        okText: 'Start Trial',
        cancelText: 'Ok',
        callback: function callback(startTrial) {
          if (startTrial) {
            window.open("//mobiscroll.com/", '_blank');
          }
        }
      });
      mobiscroll.alerted = true;
    }
  };

  MbscCommercialComponent.decorators = [{
    type: Component,
    args: [{
      selector: "\n    mbsc-calendar, [mbsc-calendar],\n    mbsc-date, [mbsc-date],\n    mbsc-time, [mbsc-time],\n    mbsc-datetime, [mbsc-datetime],\n    mbsc-eventcalendar, [mbsc-eventcalendar],\n    mbsc-card, [mbsc-card], mbsc-card-header, mbsc-card-content, mbsc-card-footer, mbsc-card-title, mbsc-card-subtitle,\n    mbsc-color, [mbsc-color],\n    mbsc-image, [mbsc-image],\n    mbsc-listview, mbsc-listview-item, mbsc-listview-header, mbsc-listview-sublist,\n    mbsc-measurement, [mbsc-measurement], mbsc-temperature, [mbsc-temperature], mbsc-distance, [mbsc-distance], mbsc-speed, [mbsc-speed], mbsc-force, [mbsc-force], mbsc-mass, [mbsc-mass],\n    mbsc-nav-item, mbsc-bottom-nav, mbsc-hamburger-nav, mbsc-tab-nav,\n    mbsc-number, [mbsc-number],\n    mbsc-numpad, [mbsc-numpad], mbsc-numpad-decimal, [mbsc-numpad-decimal], mbsc-numpad-date, [mbsc-numpad-date], mbsc-numpad-time, [mbsc-numpad-time], mbsc-numpad-timespan, [mbsc-numpad-timespan],\n    mbsc-optionlist, mbsc-option-item,\n    mbsc-range, [mbsc-range],\n    mbsc-scroller, [mbsc-scroller],\n    mbsc-scrollview, [mbsc-scrollview], mbsc-scrollview-item, [mbsc-scrollview-item],\n    mbsc-select, [mbsc-select],\n    mbsc-timer, [mbsc-timer],\n    mbsc-timespan, [mbsc-timespan],\n    mbsc-treelist, [mbsc-treelist],\n    mbsc-widget\n    ",
      template: '<ng-content></ng-content>',
      exportAs: 'mobiscroll',
      styles: [':host { display: block }']
    }]
  }];

  MbscCommercialComponent.ctorParameters = function () {
    return [{
      type: ElementRef
    }, {
      type: MbscOptionsService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgZone
    }];
  };

  MbscCommercialComponent.propDecorators = {
    'mbscOptions': [{
      type: Input$1,
      args: ['mbsc-options']
    }],
    'options': [{
      type: Input$1
    }],
    'data': [{
      type: Input$1
    }],
    'mbscData': [{
      type: Input$1,
      args: ['mbsc-data']
    }],
    'initElem': [{
      type: ViewChild,
      args: ['initElement', {
        static: false
      }]
    }]
  };
  return MbscCommercialComponent;
}(MbscBase);

var directives = [MbscForm, MbscRating, MbscPage, MbscNote, MbscAvatar, MbscInput, MbscDropdown, MbscTextarea, MbscButton, MbscCheckbox, MbscSwitch, MbscStepper, MbscProgress, MbscSlider, MbscRadio, MbscRadioGroup, MbscSegmentedGroup, MbscSegmented, MbscCommercialComponent, MbscFormGroup, MbscFormGroupTitle, MbscFormGroupContent];

var MbscModule = function () {
  function MbscModule() {}

  MbscModule.decorators = [{
    type: NgModule,
    args: [{
      imports: [FormsModule, CommonModule, MbscFormsModule, MbscPageModule],
      declarations: [MbscCommercialComponent],
      exports: [directives, MbscCommercialComponent, MbscFormsModule, MbscPageModule]
    }]
  }];

  MbscModule.ctorParameters = function () {
    return [];
  };

  return MbscModule;
}();

// Arabic
mobiscroll.i18n.ar = {
  // Core
  rtl: true,
  // Right to left mode
  setText: 'تعيين',
  cancelText: 'إلغاء',
  clearText: 'مسح',
  selectedText: '{count} المحدد',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['الأحد', 'الاثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة', 'السبت'],
  dayNamesShort: ['أحد', 'اثنين', 'ثلاثاء', 'أربعاء', 'خميس', 'جمعة', 'سبت'],
  dayNamesMin: ['ح', 'ن', 'ث', 'ر', 'خ', 'ج', 'س'],
  dayText: 'يوم',
  hourText: 'ساعات',
  minuteText: 'الدقائق',
  monthNames: ['يناير', 'فبراير', 'مارس', 'ابريل', 'مايو', 'يونيو', 'يوليو', 'أغسطس', 'سبتمبر', 'أكتوبر', 'نوفمبر', 'ديسمبر'],
  monthNamesShort: ['يناير', 'فبراير', 'مارس', 'ابريل', 'مايو', 'يونيو', 'يوليو', 'أغسطس', 'سبتمبر', 'أكتوبر', 'نوفمبر', 'ديسمبر'],
  monthText: 'شهر',
  secText: 'ثواني',
  amText: 'ص',
  pmText: 'م',
  timeFormat: 'hh:ii A',
  yearText: 'عام',
  nowText: 'الآن',
  // Calendar component
  firstDay: 0,
  dateText: 'تاريخ',
  timeText: 'وقت',
  closeText: 'إغلاق',
  todayText: 'اليوم',
  prevMonthText: 'الشهر السابق',
  nextMonthText: 'الشهر القادم',
  prevYearText: 'السنه السابقة',
  nextYearText: 'العام القادم',
  allDayText: 'اليوم كله',
  noEventsText: 'لا توجد احداث',
  // Event calendar
  eventText: 'الحدث',
  eventsText: 'أحداث',
  moreEventsText: 'واحد آخر',
  moreEventsPluralText: 'اثنان آخران {count}',
  // Daterange component
  fromText: 'يبدا',
  toText: 'ينتهي',
  // Measurement components
  wholeText: 'كامل',
  fractionText: 'جزء',
  unitText: 'وحدة',
  // Numpad date
  delimiter: '/',
  // Numpad decimal
  decimalSeparator: '.',
  thousandsSeparator: ',',
  // Timer / Timespan component
  labels: ['سنوات', 'أشهر', 'أيام', 'ساعة', 'دقائق', 'ثواني', ''],
  labelsShort: ['سنوات', 'أشهر', 'أيام', 'ساعة', 'دقائق', 'ثواني', ''],
  // Timer component
  startText: 'بدء',
  stopText: 'إيقاف',
  resetText: 'إعادة ضبط',
  lapText: 'الدورة',
  hideText: 'إخفاء',
  // Forms
  offText: 'إيقاف',
  onText: 'تشغيل',
  // Listview
  backText: 'رجوع',
  undoText: 'تراجع'
};

// Bulgarian
mobiscroll.i18n.bg = {
  // Core
  setText: 'Задаване',
  cancelText: 'Отмяна',
  clearText: 'Изчистване',
  selectedText: '{count} подбран',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Неделя', 'Понеделник', 'Вторник', 'Сряда', 'Четвъртък', 'Петък', 'Събота'],
  dayNamesShort: ['Нед', 'Пон', 'Вто', 'Сря', 'Чет', 'Пет', 'Съб'],
  dayNamesMin: ['Не', 'По', 'Вт', 'Ср', 'Че', 'Пе', 'Съ'],
  dayText: 'ден',
  delimiter: '.',
  hourText: 'час',
  minuteText: 'минута',
  monthNames: ['Януари', 'Февруари', 'Март', 'Април', 'Май', 'Юни', 'Юли', 'Август', 'Септември', 'Октомври', 'Ноември', 'Декември'],
  monthNamesShort: ['Яну', 'Фев', 'Мар', 'Апр', 'Май', 'Юни', 'Юли', 'Авг', 'Сеп', 'Окт', 'Нов', 'Дек'],
  monthText: 'месец',
  secText: 'секунди',
  timeFormat: 'H:ii',
  yearText: 'година',
  nowText: 'Сега',
  pmText: 'pm',
  amText: 'am',
  // Calendar component
  firstDay: 1,
  dateText: 'Дата',
  timeText: 'път',
  todayText: 'днес',
  prevMonthText: 'Предишния месец',
  nextMonthText: 'Следващият месец',
  prevYearText: 'Предходната година',
  nextYearText: 'Следващата година',
  closeText: 'затвори',
  eventText: 'Събитие',
  eventsText: 'Събития',
  allDayText: 'Цял ден',
  noEventsText: 'Няма събития',
  moreEventsText: 'Още {count}',
  // Daterange component
  fromText: 'ОТ',
  toText: 'ДО',
  // Measurement components
  wholeText: 'цяло',
  fractionText: 'фракция',
  unitText: 'единица',
  // Time / Timespan component
  labels: ['Години', 'месеца', 'дни', 'часа', 'минути', 'секунди', ''],
  labelsShort: ['Години', 'месеца', 'дни', 'часа', 'минути', 'секунди', ''],
  // Timer component
  startText: 'Старт',
  stopText: 'Стоп',
  resetText: 'Нулиране',
  lapText: 'Обиколка',
  hideText: 'крия',
  // Listview
  backText: 'връщане',
  undoText: 'ОТМЯНА',
  // Form
  offText: 'ИЗКЛ',
  onText: 'ВКЛ',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Català
mobiscroll.i18n.ca = {
  // Core
  setText: 'Acceptar',
  cancelText: 'Cancel·lar',
  clearText: 'Esborrar',
  selectedText: '{count} seleccionat',
  selectedPluralText: '{count} seleccionats',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Diumenge', 'Dilluns', 'Dimarts', 'Dimecres', 'Dijous', 'Divendres', 'Dissabte'],
  dayNamesShort: ['Dg', 'Dl', 'Dt', 'Dc', 'Dj', 'Dv', 'Ds'],
  dayNamesMin: ['Dg', 'Dl', 'Dt', 'Dc', 'Dj', 'Dv', 'Ds'],
  dayText: 'Dia',
  hourText: 'Hores',
  minuteText: 'Minuts',
  monthNames: ['Gener', 'Febrer', 'Març', 'Abril', 'Maig', 'Juny', 'Juliol', 'Agost', 'Setembre', 'Octubre', 'Novembre', 'Desembre'],
  monthNamesShort: ['Gen', 'Feb', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Oct', 'Nov', 'Des'],
  monthText: 'Mes',
  secText: 'Segons',
  timeFormat: 'HH:ii',
  yearText: 'Any',
  nowText: 'Ara',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Avui',
  // Calendar component
  firstDay: 1,
  dateText: 'Data',
  timeText: 'Temps',
  closeText: 'Tancar',
  allDayText: 'Tot el dia',
  noEventsText: 'Cap esdeveniment',
  eventText: 'Esdeveniments',
  eventsText: 'Esdeveniments',
  moreEventsText: '{count} més',
  // Daterange component
  fromText: 'Iniciar',
  toText: 'Final',
  // Measurement components
  wholeText: 'Sencer',
  fractionText: 'Fracció',
  unitText: 'Unitat',
  // Time / Timespan component
  labels: ['Anys', 'Mesos', 'Dies', 'Hores', 'Minuts', 'Segons', ''],
  labelsShort: ['Anys', 'Mesos', 'Dies', 'Hrs', 'Mins', 'Secs', ''],
  // Timer component
  startText: 'Iniciar',
  stopText: 'Aturar',
  resetText: 'Reiniciar',
  lapText: 'Volta',
  hideText: 'Amagar',
  // Listview
  backText: 'Enrere',
  undoText: 'Desfés',
  // Form
  offText: 'No',
  onText: 'Si'
};

// Cestina
mobiscroll.i18n.cs = {
  // Core
  setText: 'Zadej',
  cancelText: 'Storno',
  clearText: 'Vymazat',
  selectedText: 'Označený: {count}',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Neděle', 'Pondělí', 'Úterý', 'Středa', 'Čtvrtek', 'Pátek', 'Sobota'],
  dayNamesShort: ['Ne', 'Po', 'Út', 'St', 'Čt', 'Pá', 'So'],
  dayNamesMin: ['N', 'P', 'Ú', 'S', 'Č', 'P', 'S'],
  dayText: 'Den',
  hourText: 'Hodiny',
  minuteText: 'Minuty',
  monthNames: ['Leden', 'Únor', 'Březen', 'Duben', 'Květen', 'Červen', 'Červenec', 'Srpen', 'Září', 'Říjen', 'Listopad', 'Prosinec'],
  monthNamesShort: ['Led', 'Úno', 'Bře', 'Dub', 'Kvě', 'Čer', 'Čvc', 'Spr', 'Zář', 'Říj', 'Lis', 'Pro'],
  monthText: 'Měsíc',
  secText: 'Sekundy',
  timeFormat: 'HH:ii',
  yearText: 'Rok',
  nowText: 'Teď',
  amText: 'am',
  pmText: 'pm',
  todayText: 'Dnes',
  // Calendar component
  firstDay: 1,
  dateText: 'Datum',
  timeText: 'Čas',
  closeText: 'Zavřít',
  allDayText: 'Celý den',
  noEventsText: 'Žádné události',
  eventText: 'Událostí',
  eventsText: 'Události',
  moreEventsText: '{count} další',
  // Daterange component
  fromText: 'Začátek',
  toText: 'Konec',
  // Measurement components
  wholeText: 'Celý',
  fractionText: 'Část',
  unitText: 'Jednotka',
  // Time / Timespan component
  labels: ['Roky', 'Měsíce', 'Dny', 'Hodiny', 'Minuty', 'Sekundy', ''],
  labelsShort: ['Rok', 'Měs', 'Dny', 'Hod', 'Min', 'Sec', ''],
  // Timer component
  startText: 'Start',
  stopText: 'Stop',
  resetText: 'Resetovat',
  lapText: 'Etapa',
  hideText: 'Schovat',
  // Listview
  backText: 'Zpět',
  undoText: 'Zpět',
  // Form
  offText: 'O',
  onText: 'I',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Dansk
mobiscroll.i18n.da = {
  // Core
  setText: 'Sæt',
  cancelText: 'Annuller',
  clearText: 'Ryd',
  selectedText: '{count} valgt',
  selectedPluralText: '{count} valgt',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Søndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lørdag'],
  dayNamesShort: ['Søn', 'Man', 'Tir', 'Ons', 'Tor', 'Fre', 'Lør'],
  dayNamesMin: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
  dayText: 'Dag',
  hourText: 'Timer',
  minuteText: 'Minutter',
  monthNames: ['Januar', 'Februar', 'Marts', 'April', 'Maj', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'December'],
  monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Maj', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
  monthText: 'Måned',
  secText: 'Sekunder',
  amText: 'am',
  pmText: 'pm',
  timeFormat: 'HH.ii',
  yearText: 'År',
  nowText: 'Nu',
  todayText: 'I dag',
  // Calendar component
  firstDay: 1,
  dateText: 'Dato',
  timeText: 'Tid',
  closeText: 'Luk',
  allDayText: 'Hele dagen',
  noEventsText: 'Ingen begivenheder',
  eventText: 'Begivenheder',
  eventsText: 'Begivenheder',
  moreEventsText: '{count} mere',
  // Daterange component
  fromText: 'Start',
  toText: 'Slut',
  // Measurement components
  wholeText: 'Hele',
  fractionText: 'Dele',
  unitText: 'Enhed',
  // Time / Timespan component
  labels: ['År', 'Måneder', 'Dage', 'Timer', 'Minutter', 'Sekunder', ''],
  labelsShort: ['År', 'Mdr', 'Dg', 'Timer', 'Min', 'Sek', ''],
  // Timer component
  startText: 'Start',
  stopText: 'Stop',
  resetText: 'Nulstil',
  lapText: 'Omgang',
  hideText: 'Skjul',
  // Forms
  offText: 'Fra',
  onText: 'Til',
  // Listview
  backText: 'Tilbage',
  undoText: 'Fortryd'
};

// Deutsch
mobiscroll.i18n.de = {
  // Core
  setText: 'OK',
  cancelText: 'Abbrechen',
  clearText: 'Löschen',
  selectedText: '{count} ausgewählt',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
  dayNamesShort: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
  dayNamesMin: ['S', 'M', 'D', 'M', 'D', 'F', 'S'],
  dayText: 'Tag',
  delimiter: '.',
  hourText: 'Stunde',
  minuteText: 'Minuten',
  monthNames: ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
  monthNamesShort: ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
  monthText: 'Monat',
  secText: 'Sekunden',
  timeFormat: 'HH:ii',
  yearText: 'Jahr',
  nowText: 'Jetzt',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Heute',
  // Calendar component
  firstDay: 1,
  dateText: 'Datum',
  timeText: 'Zeit',
  closeText: 'Schließen',
  allDayText: 'Ganztägig',
  noEventsText: 'Keine Ereignisse',
  eventText: 'Ereignis',
  eventsText: 'Ereignisse',
  moreEventsText: '{count} weiteres Element',
  moreEventsPluralText: '{count} weitere Elemente',
  // Daterange component
  fromText: 'Von',
  toText: 'Bis',
  // Measurement components
  wholeText: 'Ganze Zahl',
  fractionText: 'Bruchzahl',
  unitText: 'Maßeinheit',
  // Time / Timespan component
  labels: ['Jahre', 'Monate', 'Tage', 'Stunden', 'Minuten', 'Sekunden', ''],
  labelsShort: ['Jahr.', 'Mon.', 'Tag.', 'Std.', 'Min.', 'Sek.', ''],
  // Timer component
  startText: 'Starten',
  stopText: 'Stoppen',
  resetText: 'Zurücksetzen',
  lapText: 'Lap',
  hideText: 'Ausblenden',
  // Listview
  backText: 'Zurück',
  undoText: 'Rückgängig machen',
  // Form
  offText: 'Aus',
  onText: 'Ein',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Greek
mobiscroll.i18n.el = {
  // Core
  setText: 'Ορισμος',
  cancelText: 'Ακυρωση',
  clearText: 'Διαγραφη',
  selectedText: '{count} επιλεγμένα',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Κυριακή', 'Δευτέρα', 'Τρίτη', 'Τετάρτη', 'Πέμπτη', 'Παρασκευή', 'Σάββατο'],
  dayNamesShort: ['Κυρ', 'Δευ', 'Τρι', 'Τετ', 'Πεμ', 'Παρ', 'Σαβ'],
  dayNamesMin: ['Κυ', 'Δε', 'Τρ', 'Τε', 'Πε', 'Πα', 'Σα'],
  dayText: 'ημέρα',
  delimiter: '/',
  hourText: 'ώρα',
  minuteText: 'λεπτό',
  monthNames: ['Ιανουάριος', 'Φεβρουάριος', 'Μάρτιος', 'Απρίλιος', 'Μάιος', 'Ιούνιος', 'Ιούλιος', 'Αύγουστος', 'Σεπτέμβριος', 'Οκτώβριος', 'Νοέμβριος', 'Δεκέμβριος'],
  monthNamesShort: ['Ιαν', 'Φεβ', 'Μαρ', 'Απρ', 'Μαι', 'Ιουν', 'Ιουλ', 'Αυγ', 'Σεπ', 'Οκτ', 'Νοε', 'Δεκ'],
  monthText: 'Μήνας',
  secText: 'δευτερόλεπτα',
  timeFormat: 'H:ii',
  yearText: 'έτος',
  nowText: 'τώρα',
  pmText: 'μμ',
  amText: 'πμ',
  // Calendar component
  firstDay: 1,
  dateText: 'Ημερομηνία',
  timeText: 'φορά',
  todayText: 'Σήμερα',
  prevMonthText: 'Προηγούμενο μήνα',
  nextMonthText: 'Επόμενο μήνα',
  prevYearText: 'Προηγούμενο έτος',
  nextYearText: 'Επόμενο έτος',
  closeText: 'Κλείσιμο',
  eventText: 'Γεγονότα',
  eventsText: 'Γεγονότα',
  allDayText: 'Ολοήμερο',
  noEventsText: 'Δεν υπάρχουν γεγονότα',
  moreEventsText: '{count} ακόμη',
  // Daterange component
  fromText: 'Αρχή',
  toText: 'Τέλος',
  // Measurement components
  wholeText: 'Ολόκληρος',
  fractionText: 'κλάσμα',
  unitText: 'Μονάδα',
  // Time / Timespan component
  labels: ['Χρόνια', 'Μήνες', 'Ημέρες', 'Ωρες', 'Λεπτά', 'δευτερόλεπτα', ''],
  labelsShort: ['Χρόνια', 'Μήνες', 'Ημέρες', 'Ωρες', 'Λεπτά', 'δευτ', ''],
  // Timer component
  startText: '΄Εναρξη',
  stopText: 'Διακοπή',
  resetText: 'Επαναφορά',
  lapText: 'Γύρος',
  hideText: 'κρύβω',
  // Listview
  backText: 'Πίσω',
  undoText: 'Αναιρεση',
  // Form
  offText: 'Ανενεργό',
  onText: 'Ενεργό',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// English (UK)
mobiscroll.i18n['en-GB'] = mobiscroll.i18n['en-UK'] = {
  dateFormat: 'dd/mm/yy',
  timeFormat: 'HH:ii'
};

// Español
mobiscroll.i18n.es = {
  // Core
  setText: 'Aceptar',
  cancelText: 'Cancelar',
  clearText: 'Borrar',
  selectedText: '{count} seleccionado',
  selectedPluralText: '{count} seleccionados',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'],
  dayNamesShort: ['Do', 'Lu', 'Ma', 'Mi', 'Ju', 'Vi', 'Sá'],
  dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
  dayText: 'Día',
  hourText: 'Horas',
  minuteText: 'Minutos',
  monthNames: ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'],
  monthNamesShort: ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'],
  monthText: 'Mes',
  secText: 'Segundos',
  timeFormat: 'HH:ii',
  yearText: 'A&ntilde;o',
  nowText: 'Ahora',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Hoy',
  // Calendar component
  firstDay: 1,
  dateText: 'Fecha',
  timeText: 'Tiempo',
  closeText: 'Cerrar',
  allDayText: 'Todo el día',
  noEventsText: 'No hay eventos',
  eventText: 'Evento',
  eventsText: 'Eventos',
  moreEventsText: '{count} más',
  // Daterange component
  fromText: 'Iniciar',
  toText: 'Final',
  // Measurement components
  wholeText: 'Entero',
  fractionText: 'Fracción',
  unitText: 'Unidad',
  // Time / Timespan component
  labels: ['Años', 'Meses', 'Días', 'Horas', 'Minutos', 'Segundos', ''],
  labelsShort: ['Año', 'Mes', 'Día', 'Hora', 'Min', 'Seg', ''],
  // Timer component
  startText: 'Iniciar',
  stopText: 'Deténgase',
  resetText: 'Reinicializar',
  lapText: 'Lap',
  hideText: 'Esconder',
  // Listview
  backText: 'Atrás',
  undoText: 'Deshacer',
  // Form
  offText: 'No',
  onText: 'Sí',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// فارسی
mobiscroll.i18n.fa = {
  // Core
  setText: 'تاييد',
  cancelText: 'انصراف',
  clearText: 'واضح ',
  selectedText: '{count} منتخب',
  // Datetime component
  calendarSystem: 'jalali',
  dateFormat: 'yy/mm/dd',
  dayNames: ['يکشنبه', 'دوشنبه', 'سه‌شنبه', 'چهارشنبه', 'پنج‌شنبه', 'جمعه', 'شنبه'],
  dayNamesShort: ['ی', 'د', 'س', 'چ', 'پ', 'ج', 'ش'],
  dayNamesMin: ['ی', 'د', 'س', 'چ', 'پ', 'ج', 'ش'],
  dayText: 'روز',
  hourText: 'ساعت',
  minuteText: 'دقيقه',
  monthNames: ['فروردين', 'ارديبهشت', 'خرداد', 'تير', 'مرداد', 'شهريور', 'مهر', 'آبان', 'آذر', 'دی', 'بهمن', 'اسفند'],
  monthNamesShort: ['فروردين', 'ارديبهشت', 'خرداد', 'تير', 'مرداد', 'شهريور', 'مهر', 'آبان', 'آذر', 'دی', 'بهمن', 'اسفند'],
  monthText: 'ماه',
  secText: 'ثانيه',
  timeFormat: 'HH:ii',
  timeWheels: 'iiHH',
  // Need this for correct RTL display
  yearText: 'سال',
  nowText: 'اکنون',
  amText: 'ب',
  pmText: 'ص',
  todayText: 'امروز',
  //getNumber: function (n) {
  //    var i,
  //        nums = ["۰", "۱", "۲", "۳", "۴", "۵", "۶", "۷", "۸", "۹"],
  //        res = '';
  //    n = n + '';
  //    for (i = 0; i < n.length; i++) {
  //        res += nums[+n[i]];
  //    }
  //    return res;
  //},
  // Calendar component
  firstDay: 6,
  rtl: true,
  dateText: 'تاریخ ',
  timeText: 'زمان ',
  closeText: 'نزدیک',
  allDayText: 'تمام روز',
  noEventsText: 'هیچ رویداد',
  eventText: 'رویداد',
  eventsText: 'رویدادها',
  moreEventsText: '{count} مورد دیگر',
  // Daterange component
  fromText: 'شروع ',
  toText: 'پایان',
  // Measurement components
  wholeText: 'تمام',
  fractionText: 'کسر',
  unitText: 'واحد',
  // Time / Timespan component
  labels: ['سال', 'ماه', 'روز', 'ساعت', 'دقیقه', 'ثانیه', ''],
  labelsShort: ['سال', 'ماه', 'روز', 'ساعت', 'دقیقه', 'ثانیه', ''],
  // Timer component
  startText: 'شروع',
  stopText: 'پايان',
  resetText: 'تنظیم مجدد',
  lapText: 'Lap',
  hideText: 'پنهان کردن',
  // Listview
  backText: 'پشت',
  undoText: 'واچیدن'
};

// Suomi
mobiscroll.i18n.fi = {
  // Core
  setText: 'Aseta',
  cancelText: 'Peruuta',
  clearText: 'Tyhjennä',
  selectedText: '{count} valita',
  // Datetime component
  dateFormat: 'd. MM yy',
  dayNames: ['Sunnuntai', 'Maanantai', 'Tiistai', 'Keskiviiko', 'Torstai', 'Perjantai', 'Lauantai'],
  dayNamesShort: ['Su', 'Ma', 'Ti', 'Ke', 'To', 'Pe', 'La'],
  dayNamesMin: ['S', 'M', 'T', 'K', 'T', 'P', 'L'],
  dayText: 'Päivä',
  delimiter: '.',
  hourText: 'Tuntia',
  minuteText: 'Minuutti',
  monthNames: ['Tammikuu', 'Helmikuu', 'Maaliskuu', 'Huhtikuu', 'Toukokuu', 'Kesäkuu', 'Heinäkuu', 'Elokuu', 'Syyskuu', 'Lokakuu', 'Marraskuu', 'Joulukuu'],
  monthNamesShort: ['Tam', 'Hel', 'Maa', 'Huh', 'Tou', 'Kes', 'Hei', 'Elo', 'Syy', 'Lok', 'Mar', 'Jou'],
  monthText: 'Kuukausi',
  secText: 'Sekunda',
  timeFormat: 'H:ii',
  yearText: 'Vuosi',
  nowText: 'Nyt',
  pmText: 'pm',
  amText: 'am',
  // Calendar component
  firstDay: 1,
  dateText: 'Päiväys',
  timeText: 'Aika',
  todayText: 'Tänään',
  prevMonthText: 'Edellinen kuukausi',
  nextMonthText: 'Ensi kuussa',
  prevYearText: 'Edellinen vuosi',
  nextYearText: 'Ensi vuosi',
  closeText: 'Sulje',
  eventText: 'Tapahtumia',
  eventsText: 'Tapahtumia',
  allDayText: 'Koko päivä',
  noEventsText: 'Ei tapahtumia',
  moreEventsText: '{count} muu',
  moreEventsPluralText: '{count} muuta',
  // Daterange component
  fromText: 'Alkaa',
  toText: 'Päättyy',
  // Measurement components
  wholeText: 'Kokonainen',
  fractionText: 'Murtoluku',
  unitText: 'Yksikkö',
  // Time / Timespan component
  labels: ['Vuosi', 'Kuukausi', 'Päivä', 'Tunnin', 'Minuutti', 'sekuntia', ''],
  labelsShort: ['Vuo', 'Kuu', 'Päi', 'Tun', 'Min', 'Sek', ''],
  // Timer component
  startText: 'Käynnistys',
  stopText: 'Seis',
  resetText: 'Aseta uudelleen',
  lapText: 'Kierros',
  hideText: 'Vuota',
  // Listview
  backText: 'Edellinen',
  undoText: 'Kumoa',
  // Form
  offText: 'Pois',
  onText: 'Päällä',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Français
mobiscroll.i18n.fr = {
  // Core
  setText: 'Terminer',
  cancelText: 'Annuler',
  clearText: 'Effacer',
  selectedText: '{count} sélectionné',
  selectedPluralText: '{count} sélectionnés',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'],
  dayNamesShort: ['Dim.', 'Lun.', 'Mar.', 'Mer.', 'Jeu.', 'Ven.', 'Sam.'],
  dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
  dayText: 'Jour',
  monthText: 'Mois',
  monthNames: ['Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'],
  monthNamesShort: ['Janv.', 'Févr.', 'Mars', 'Avril', 'Mai', 'Juin', 'Juil.', 'Août', 'Sept.', 'Oct.', 'Nov.', 'Déc.'],
  hourText: 'Heures',
  minuteText: 'Minutes',
  secText: 'Secondes',
  timeFormat: 'HH:ii',
  yearText: 'Année',
  nowText: 'Maintenant',
  pmText: 'pm',
  amText: 'am',
  todayText: "Aujourd'hui",
  // Calendar component
  firstDay: 1,
  dateText: 'Date',
  timeText: 'Heure',
  closeText: 'Fermer',
  allDayText: 'Toute la journée',
  noEventsText: 'Aucun événement',
  eventText: 'Événement',
  eventsText: 'Événements',
  moreEventsText: '{count} autre',
  moreEventsPluralText: '{count} autres',
  // Daterange component
  fromText: 'Démarrer',
  toText: 'Fin',
  // Measurement components
  wholeText: 'Entier',
  fractionText: 'Fraction',
  unitText: 'Unité',
  // Time / Timespan component
  labels: ['Ans', 'Mois', 'Jours', 'Heures', 'Minutes', 'Secondes', ''],
  labelsShort: ['Ans', 'Mois', 'Jours', 'Hrs', 'Min', 'Sec', ''],
  // Timer component
  startText: 'Démarrer',
  stopText: 'Arrêter',
  resetText: 'Réinitialiser',
  lapText: 'Lap',
  hideText: 'Cachez',
  // Listview
  backText: 'Retour',
  undoText: 'Annuler',
  // Form
  offText: 'Non',
  onText: 'Oui',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Hebrew
mobiscroll.i18n.he = {
  // Core
  rtl: true,
  // Right to left mode
  setText: 'שמירה',
  cancelText: 'ביטול',
  clearText: 'נקה',
  selectedText: '{count} נבחר',
  selectedPluralText: '{count} נבחרו',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['ראשון', 'שני', 'שלישי', 'רביעי', 'חמישי', 'שישי', 'שבת'],
  dayNamesShort: ["א'", "ב'", "ג'", "ד'", "ה'", "ו'", "ש'"],
  dayNamesMin: ['א', 'ב', 'ג', 'ד', 'ה', 'ו', 'ש'],
  dayText: 'יום',
  hourText: 'שעות',
  minuteText: 'דקות',
  monthNames: ['ינואר', 'פברואר', 'מרץ', 'אפריל', 'מאי', 'יוני', 'יולי', 'אוגוסט', 'ספטמבר', 'אוקטובר', 'נובמבר', 'דצמבר'],
  monthNamesShort: ["ינו", "פבר", "מרץ", "אפר", "מאי", "יונ", "יול", "אוג", "ספט", "אוק", "נוב", "דצמ"],
  monthText: 'חודש',
  secText: 'שניות',
  amText: 'am',
  pmText: 'pm',
  timeFormat: 'HH:ii',
  timeWheels: 'iiHH',
  // Need this for correct RTL display
  yearText: 'שנה',
  nowText: 'עכשיו',
  // Calendar component
  firstDay: 0,
  dateText: 'תאריך',
  timeText: 'זמן',
  closeText: 'סגירה',
  todayText: 'היום',
  allDayText: 'כל היום',
  noEventsText: 'אין אירועים',
  // Event calendar
  eventText: 'מִקרֶה',
  eventsText: 'מִקרֶה',
  moreEventsText: 'אירוע אחד נוסף',
  moreEventsPluralText: '{count} אירועים נוספים',
  // Daterange component
  fromText: 'התחלה',
  toText: 'סיום',
  // Measurement components
  wholeText: 'כֹּל',
  fractionText: 'שבריר',
  unitText: 'יחידה',
  // Time / Timespan component
  labels: ['שנים', 'חודשים', 'ימים', 'שעות', 'דקות', 'שניים', ''],
  labelsShort: ['שנים', 'חודשים', 'ימים', 'שעות', 'דקות', 'שניים', ''],
  // Timer component
  startText: 'התחל',
  stopText: 'עצור',
  resetText: 'אתחול',
  lapText: 'הקפה',
  hideText: 'הסתר',
  // Forms
  offText: 'כיבוי',
  onText: 'הפעלה',
  // Listview
  backText: 'חזור',
  undoText: 'ביטול פעולה'
};

// Hindi
mobiscroll.i18n.hi = {
  // Core
  setText: 'सैट करें',
  cancelText: 'रद्द करें',
  clearText: 'साफ़ को',
  selectedText: '{count} चयनित',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['रविवार', 'सोमवार', 'मंगलवार', 'बुधवार', 'गुरुवार', 'शुक्रवार', 'शनिवार'],
  dayNamesShort: ['रवि', 'सोम', 'मंगल', 'बुध', 'गुरु', 'शुक्र', 'शनि'],
  dayNamesMin: ['रवि', 'सोम', 'मंगल', 'बुध', 'गुरु', 'शुक्र', 'शनि'],
  dayText: 'दिन',
  delimiter: '.',
  hourText: 'घंटा',
  minuteText: 'मिनट',
  monthNames: ['जनवरी ', 'फरवरी', 'मार्च', 'अप्रेल', 'मई', 'जून', 'जूलाई', 'अगस्त ', 'सितम्बर', 'अक्टूबर', 'नवम्बर', 'दिसम्बर'],
  monthNamesShort: ['जन', 'फर', 'मार्च', 'अप्रेल', 'मई', 'जून', 'जूलाई', 'अग', 'सित', 'अक्ट', 'नव', 'दि'],
  monthText: 'महीना',
  secText: 'सेकंड',
  timeFormat: 'H:ii',
  yearText: 'साल',
  nowText: 'अब',
  pmText: 'अपराह्न',
  amText: 'पूर्वाह्न',
  // Calendar component
  firstDay: 1,
  dateText: 'तिथि',
  timeText: 'समय',
  todayText: 'आज',
  prevMonthText: 'पिछ्ला महिना',
  nextMonthText: 'अगले महीने',
  prevYearText: 'पिछला साल',
  nextYearText: 'अगले वर्ष',
  closeText: 'बंद',
  eventText: 'इवेट३',
  eventsText: 'इवेट३',
  allDayText: 'पूरे दिन',
  noEventsText: 'Ei tapahtumia',
  moreEventsText: '{count} और',
  // Daterange component
  fromText: 'से',
  toText: 'तक',
  // Measurement components
  wholeText: 'समूचा',
  fractionText: 'अंश',
  unitText: 'इकाई',
  // Time / Timespan component
  labels: ['साल', 'महीने', 'दिन', 'घंटे', 'मिनट', 'सेकंड', ''],
  labelsShort: ['साल', 'महीने', 'दिन', 'घंटे', 'मिनट', 'सेकंड', ''],
  // Timer component
  startText: 'प्रारंभ',
  stopText: 'रोकें',
  resetText: 'रीसेट करें',
  lapText: 'लैप',
  hideText: 'छिपाना',
  // Listview
  backText: 'वापस',
  // check
  undoText: 'वापस लाएं',
  // Form
  offText: 'बंद',
  onText: 'चालू',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Croatian
mobiscroll.i18n.hr = {
  // Core
  setText: 'Postavi',
  cancelText: 'Izlaz',
  clearText: 'Izbriši',
  selectedText: '{count} odabran',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Nedjelja', 'Ponedjeljak', 'Utorak', 'Srijeda', 'Četvrtak', 'Petak', 'Subota'],
  dayNamesShort: ['Ned', 'Pon', 'Uto', 'Sri', 'Čet', 'Pet', 'Sub'],
  dayNamesMin: ['Ne', 'Po', 'Ut', 'Sr', 'Če', 'Pe', 'Su'],
  dayText: 'Dan',
  delimiter: '.',
  hourText: 'Sat',
  minuteText: 'Minuta',
  monthNames: ['Siječanj', 'Veljača', 'Ožujak', 'Travanj', 'Svibanj', 'Lipanj', 'Srpanj', 'Kolovoz', 'Rujan', 'Listopad', 'Studeni', 'Prosinac'],
  monthNamesShort: ['Sij', 'Velj', 'Ožu', 'Tra', 'Svi', 'Lip', 'Srp', 'Kol', 'Ruj', 'Lis', 'Stu', 'Pro'],
  monthText: 'Mjesec',
  secText: 'Sekunda',
  timeFormat: 'H:ii',
  yearText: 'Godina',
  nowText: 'Sada',
  pmText: 'pm',
  amText: 'am',
  // Calendar component
  firstDay: 1,
  dateText: 'Datum',
  timeText: 'Vrijeme',
  todayText: 'Danas',
  prevMonthText: 'Prethodni mjesec',
  nextMonthText: 'Sljedeći mjesec',
  prevYearText: 'Prethodni godina',
  nextYearText: 'Slijedeće godine',
  closeText: 'Zatvori',
  eventText: 'Događaj',
  eventsText: 'događaja',
  allDayText: 'Cijeli dan',
  noEventsText: 'Bez događaja',
  moreEventsText: 'Još {count}',
  // Daterange component
  fromText: 'Počinje',
  toText: 'Završava',
  // Measurement components
  wholeText: 'Cjelina',
  fractionText: 'Frakcija',
  unitText: 'Jedinica',
  // Time / Timespan component
  labels: ['godina', 'mjesec', 'dan', 'sat', 'minuta', 'sekunda', ''],
  labelsShort: ['god', 'mje', 'dan', 'sat', 'min', 'sec', ''],
  // Timer component
  startText: 'Početak',
  stopText: 'Prekid',
  resetText: 'Resetiraj',
  lapText: 'Ciklus',
  hideText: 'Sakriti',
  // Listview
  backText: 'Natrag',
  undoText: 'Poništavanje',
  // Form
  offText: 'Uklj.',
  onText: 'Isklj.',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Magyar
mobiscroll.i18n.hu = {
  // Core
  setText: 'OK',
  cancelText: 'Mégse',
  clearText: 'Törlés',
  selectedText: '{count} kiválasztva',
  // Datetime component
  dateFormat: 'yy.mm.dd.',
  dayNames: ['Vasárnap', 'Hétfő', 'Kedd', 'Szerda', 'Csütörtök', 'Péntek', 'Szombat'],
  dayNamesShort: ['Va', 'Hé', 'Ke', 'Sze', 'Csü', 'Pé', 'Szo'],
  dayNamesMin: ['V', 'H', 'K', 'Sz', 'Cs', 'P', 'Sz'],
  dayText: 'Nap',
  delimiter: '.',
  hourText: 'Óra',
  minuteText: 'Perc',
  monthNames: ['Január', 'Február', 'Március', 'Április', 'Május', 'Június', 'Július', 'Augusztus', 'Szeptember', 'Október', 'November', 'December'],
  monthNamesShort: ['Jan', 'Feb', 'Már', 'Ápr', 'Máj', 'Jún', 'Júl', 'Aug', 'Szep', 'Okt', 'Nov', 'Dec'],
  monthText: 'Hónap',
  secText: 'Másodperc',
  timeFormat: 'H:ii',
  yearText: 'Év',
  nowText: 'Most',
  pmText: 'pm',
  amText: 'am',
  // Calendar component
  firstDay: 1,
  dateText: 'Dátum',
  timeText: 'Idő',
  todayText: 'Ma',
  prevMonthText: 'Előző hónap',
  nextMonthText: 'Következő hónap',
  prevYearText: 'Előző év',
  nextYearText: 'Következő év',
  closeText: 'Bezár',
  eventText: 'esemény',
  eventsText: 'esemény',
  allDayText: 'Egész nap',
  noEventsText: 'Nincs esemény',
  moreEventsText: '{count} további',
  // Daterange component
  fromText: 'Eleje',
  toText: 'Vége',
  // Measurement components
  wholeText: 'Egész',
  fractionText: 'Tört',
  unitText: 'Egység',
  // Time / Timespan component
  labels: ['Év', 'Hónap', 'Nap', 'Óra', 'Perc', 'Másodperc', ''],
  labelsShort: ['Év', 'Hó.', 'Nap', 'Óra', 'Perc', 'Mp.', ''],
  // Timer component
  startText: 'Indít',
  stopText: 'Megállít',
  resetText: 'Visszaállít',
  lapText: 'Lap',
  hideText: 'Elrejt',
  // Listview
  backText: 'Vissza',
  undoText: 'Visszavon',
  // Form
  offText: 'Ki',
  onText: 'Be',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Italiano 
mobiscroll.i18n.it = {
  // Core
  setText: 'OK',
  cancelText: 'Annulla',
  clearText: 'Chiarire',
  selectedText: '{count} selezionato',
  selectedPluralText: '{count} selezionati',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Domenica', 'Lunedì', 'Martedì', 'Mercoledì', 'Giovedì', 'Venerdì', 'Sabato'],
  dayNamesShort: ['Do', 'Lu', 'Ma', 'Me', 'Gi', 'Ve', 'Sa'],
  dayNamesMin: ['D', 'L', 'M', 'M', 'G', 'V', 'S'],
  dayText: 'Giorno',
  hourText: 'Ore',
  minuteText: 'Minuti',
  monthNames: ['Gennaio', 'Febbraio', 'Marzo', 'Aprile', 'Maggio', 'Giugno', 'Luglio', 'Agosto', 'Settembre', 'Ottobre', 'Novembre', 'Dicembre'],
  monthNamesShort: ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'],
  monthText: 'Mese',
  secText: 'Secondi',
  timeFormat: 'HH:ii',
  yearText: 'Anno',
  nowText: 'Ora',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Oggi',
  // Calendar component
  firstDay: 1,
  dateText: 'Data',
  timeText: 'Volta',
  closeText: 'Chiudere',
  allDayText: 'Tutto il giorno',
  noEventsText: 'Nessun evento',
  eventText: 'Evento',
  eventsText: 'Eventi',
  moreEventsText: '{count} altro',
  moreEventsPluralText: 'altri {count}',
  // Daterange component
  fromText: 'Inizio',
  toText: 'Fine',
  // Measurement components
  wholeText: 'Intero',
  fractionText: 'Frazione',
  unitText: 'Unità',
  // Time / Timespan component
  labels: ['Anni', 'Mesi', 'Giorni', 'Ore', 'Minuti', 'Secondi', ''],
  labelsShort: ['Anni', 'Mesi', 'Gio', 'Ore', 'Min', 'Sec', ''],
  // Timer component
  startText: 'Inizio',
  stopText: 'Arresto',
  resetText: 'Ripristina',
  lapText: 'Lap',
  hideText: 'Nascondi',
  // Listview
  backText: 'Indietro',
  undoText: 'Annulla',
  // Form
  offText: 'Via',
  onText: 'Su',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// 日本語 - Japanese
mobiscroll.i18n.ja = {
  // Core
  setText: 'セット',
  cancelText: 'キャンセル',
  clearText: 'クリア',
  selectedText: '{count} 選択',
  // Datetime component
  dateFormat: 'yy年mm月dd日',
  dayNames: ['日', '月', '火', '水', '木', '金', '土'],
  dayNamesShort: ['日', '月', '火', '水', '木', '金', '土'],
  dayNamesMin: ['日', '月', '火', '水', '木', '金', '土'],
  dayText: '日',
  hourText: '時',
  minuteText: '分',
  monthNames: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
  monthNamesShort: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
  monthText: '月',
  secText: '秒',
  timeFormat: 'HH:ii',
  yearText: '年',
  nowText: '今',
  pmText: '午後',
  amText: '午前',
  yearSuffix: '年',
  monthSuffix: '月',
  daySuffix: '日',
  todayText: '今日',
  // Calendar component
  dateText: '日付',
  timeText: '時間',
  closeText: 'クローズ',
  allDayText: '終日',
  noEventsText: 'イベントはありません',
  eventText: 'イベント',
  eventsText: 'イベント',
  moreEventsText: '他 {count} 件',
  // Daterange component
  fromText: '開始',
  toText: '終わり',
  // Measurement components
  wholeText: '全数',
  fractionText: '分数',
  unitText: '単位',
  // Time / Timespan component
  labels: ['年間', '月間', '日間', '時間', '分', '秒', ''],
  labelsShort: ['年間', '月間', '日間', '時間', '分', '秒', ''],
  // Timer component
  startText: '開始',
  stopText: '停止',
  resetText: 'リセット',
  lapText: 'ラップ',
  hideText: '隠す',
  // Listview
  backText: 'バック',
  undoText: 'アンドゥ'
};

// Korean
mobiscroll.i18n.ko = {
  // Core
  setText: '설정',
  cancelText: '취소',
  clearText: '삭제',
  selectedText: '{count} 선택된',
  // Datetime component
  dateFormat: 'yy년mm월dd일',
  dayNames: ['일요일', '월요일', '화요일', '수요일', '목요일', '금요일', '토요일'],
  dayNamesShort: ['일', '월', '화', '수', '목', '금', '토'],
  dayNamesMin: ['일', '월', '화', '수', '목', '금', '토'],
  dayText: '일',
  delimiter: '-',
  hourText: '시간',
  minuteText: '분',
  monthNames: ['1월', '2월', '3월', '4월', '5월', '6월', '7월', '8월', '9월', '10월', '11월', '12월'],
  monthNamesShort: ['1월', '2월', '3월', '4월', '5월', '6월', '7월', '8월', '9월', '10월', '11월', '12월'],
  monthText: '달',
  secText: '초',
  timeFormat: 'H:ii',
  yearText: '년',
  nowText: '지금',
  pmText: '오후',
  amText: '오전',
  yearSuffix: '년',
  monthSuffix: '월',
  daySuffix: '일',
  // Calendar component
  firstDay: 0,
  dateText: '날짜',
  timeText: '시간',
  todayText: '오늘',
  prevMonthText: '이전 달',
  nextMonthText: '다음 달',
  prevYearText: '이전 년',
  nextYearText: '다음 년',
  closeText: '닫기',
  eventText: '이벤트',
  eventsText: '이벤트',
  allDayText: '종일',
  noEventsText: '이벤트 없음',
  moreEventsText: '{count}개 더보기',
  // Daterange component
  fromText: '시작',
  toText: '종료',
  // Measurement components
  wholeText: '정수',
  fractionText: '분수',
  unitText: '단위',
  // Time / Timespan component
  labels: ['년', '달', '일', '시간', '분', '초', ''],
  labelsShort: ['년', '달', '일', '시간', '분', '초', ''],
  // Timer component
  startText: '시작',
  stopText: '중지 ',
  resetText: '초기화',
  lapText: '기록',
  hideText: '숨는 장소',
  // Listview
  backText: '뒤로',
  undoText: '실행취소',
  // Form
  offText: '끔',
  onText: '켬',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Lietuvių
mobiscroll.i18n.lt = {
  // Core
  setText: 'OK',
  cancelText: 'Atšaukti',
  clearText: 'Išvalyti',
  selectedText: 'Pasirinktas {count}',
  selectedPluralText: 'Pasirinkti {count}',
  // Datetime component
  dateFormat: 'yy-mm-dd',
  dayNames: ['Sekmadienis', 'Pirmadienis', 'Antradienis', 'Trečiadienis', 'Ketvirtadienis', 'Penktadienis', 'Šeštadienis'],
  dayNamesShort: ['S', 'Pr', 'A', 'T', 'K', 'Pn', 'Š'],
  dayNamesMin: ['S', 'Pr', 'A', 'T', 'K', 'Pn', 'Š'],
  dayText: 'Diena',
  hourText: 'Valanda',
  minuteText: 'Minutes',
  monthNames: ['Sausis', 'Vasaris', 'Kovas', 'Balandis', 'Gegužė', 'Birželis', 'Liepa', 'Rugpjūtis', 'Rugsėjis', 'Spalis', 'Lapkritis', 'Gruodis'],
  monthNamesShort: ['Sau', 'Vas', 'Kov', 'Bal', 'Geg', 'Bir', 'Lie', 'Rugp', 'Rugs', 'Spa', 'Lap', 'Gruo'],
  monthText: 'Mėnuo',
  secText: 'Sekundes',
  amText: 'am',
  pmText: 'pm',
  timeFormat: 'HH:ii',
  yearText: 'Metai',
  nowText: 'Dabar',
  todayText: 'Šiandien',
  // Calendar component
  firstDay: 1,
  dateText: 'Data',
  timeText: 'Laikas',
  closeText: 'Uždaryti',
  allDayText: 'Visą dieną',
  noEventsText: 'Nėra įvykių',
  eventText: 'Įvykių',
  eventsText: 'Įvykiai',
  moreEventsText: 'Dar {count}',
  // Daterange component
  fromText: 'Nuo',
  toText: 'Iki',
  // Measurement components
  wholeText: 'Visas',
  fractionText: 'Frakcija',
  unitText: 'Vienetas',
  // Time / Timespan component
  labels: ['Metai', 'Mėnesiai', 'Dienos', 'Valandos', 'Minutes', 'Sekundes', ''],
  labelsShort: ['m', 'mėn.', 'd', 'h', 'min', 's', ''],
  // Timer component
  startText: 'Pradėti',
  stopText: 'Sustabdyti',
  resetText: 'Išnaujo',
  lapText: 'Ratas',
  hideText: 'Slėpti',
  // Listview
  backText: 'Atgal',
  undoText: 'Anuliuoti',
  // Form
  offText: 'Išj.',
  onText: 'Įj.',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Nederlands
mobiscroll.i18n.nl = {
  // Core
  setText: 'Instellen',
  cancelText: 'Annuleren',
  clearText: 'Leegmaken',
  selectedText: '{count} gekozen',
  // Datetime component
  dateFormat: 'dd-mm-yy',
  dayNames: ['Zondag', 'Maandag', 'Dinsdag', 'Woensdag', 'Donderdag', 'Vrijdag', 'Zaterdag'],
  dayNamesShort: ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'],
  dayNamesMin: ['z', 'm', 'd', 'w', 'd', 'v', 'z'],
  dayText: 'Dag',
  hourText: 'Uur',
  minuteText: 'Minuten',
  monthNames: ['januari', 'februari', 'maart', 'april', 'mei', 'juni', 'juli', 'augustus', 'september', 'oktober', 'november', 'december'],
  monthNamesShort: ['jan', 'feb', 'mrt', 'apr', 'mei', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'],
  monthText: 'Maand',
  secText: 'Seconden',
  timeFormat: 'HH:ii',
  yearText: 'Jaar',
  nowText: 'Nu',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Vandaag',
  // Calendar component
  firstDay: 1,
  dateText: 'Datum',
  timeText: 'Tijd',
  closeText: 'Sluiten',
  allDayText: 'Hele dag',
  noEventsText: 'Geen activiteiten',
  eventText: 'Activiteit',
  eventsText: 'Activiteiten',
  moreEventsText: 'nog {count}',
  // Daterange component
  fromText: 'Start',
  toText: 'Einde',
  // Measurement components
  wholeText: 'geheel',
  fractionText: 'fractie',
  unitText: 'eenheid',
  // Time / Timespan component
  labels: ['Jaren', 'Maanden', 'Dagen', 'Uren', 'Minuten', 'Seconden', ''],
  labelsShort: ['j', 'm', 'd', 'u', 'min', 'sec', ''],
  // Timer component
  startText: 'Start',
  stopText: 'Stop',
  resetText: 'Reset',
  lapText: 'Ronde',
  hideText: 'Verbergen',
  // Listview
  backText: 'Terug',
  undoText: 'Onged. maken',
  // Form
  offText: 'Uit',
  onText: 'Aan',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Norsk
mobiscroll.i18n.no = {
  // Core
  setText: 'OK',
  cancelText: 'Avbryt',
  clearText: 'Tømme',
  selectedText: '{count} valgt',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Søndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lørdag'],
  dayNamesShort: ['Sø', 'Ma', 'Ti', 'On', 'To', 'Fr', 'Lø'],
  dayNamesMin: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
  dayText: 'Dag',
  delimiter: '.',
  hourText: 'Time',
  minuteText: 'Minutt',
  monthNames: ['Januar', 'Februar', 'Mars', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Desember'],
  monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Des'],
  monthText: 'Måned',
  secText: 'Sekund',
  timeFormat: 'HH:ii',
  yearText: 'År',
  nowText: 'Nå',
  pmText: 'pm',
  amText: 'am',
  todayText: 'I dag',
  // Calendar component
  firstDay: 1,
  dateText: 'Dato',
  timeText: 'Tid',
  closeText: 'Lukk',
  allDayText: 'Hele dagen',
  noEventsText: 'Ingen hendelser',
  eventText: 'Hendelse',
  eventsText: 'Hendelser',
  moreEventsText: '{count} mere',
  // Daterange component
  fromText: 'Start',
  toText: 'End',
  // Measurement components
  wholeText: 'Hele',
  fractionText: 'Fraksjon',
  unitText: 'Enhet',
  // Time / Timespan component
  labels: ['År', 'Måneder', 'Dager', 'Timer', 'Minutter', 'Sekunder', ''],
  labelsShort: ['År', 'Mån', 'Dag', 'Time', 'Min', 'Sek', ''],
  // Timer component
  startText: 'Start',
  stopText: 'Stopp',
  resetText: 'Tilbakestille',
  lapText: 'Runde',
  hideText: 'Skjul',
  // Listview
  backText: 'Tilbake',
  undoText: 'Angre',
  // Form
  offText: 'Av',
  onText: 'På',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Polski
mobiscroll.i18n.pl = {
  // Core
  setText: 'Zestaw',
  cancelText: 'Anuluj',
  clearText: 'Oczyścić',
  selectedText: 'Wybór: {count}',
  // Datetime component
  dateFormat: 'yy-mm-dd',
  dayNames: ['Niedziela', 'Poniedziałek', 'Wtorek', 'Środa', 'Czwartek', 'Piątek', 'Sobota'],
  dayNamesShort: ['Niedz.', 'Pon.', 'Wt.', 'Śr.', 'Czw.', 'Pt.', 'Sob.'],
  dayNamesMin: ['N', 'P', 'W', 'Ś', 'C', 'P', 'S'],
  dayText: 'Dzień',
  hourText: 'Godziny',
  minuteText: 'Minuty',
  monthNames: ['Styczeń', 'Luty', 'Marzec', 'Kwiecień', 'Maj', 'Czerwiec', 'Lipiec', 'Sierpień', 'Wrzesień', 'Październik', 'Listopad', 'Grudzień'],
  monthNamesShort: ['Sty', 'Lut', 'Mar', 'Kwi', 'Maj', 'Cze', 'Lip', 'Sie', 'Wrz', 'Paź', 'Lis', 'Gru'],
  monthText: 'Miesiąc',
  secText: 'Sekundy',
  timeFormat: 'HH:ii',
  yearText: 'Rok',
  nowText: 'Teraz',
  amText: 'am',
  pmText: 'pm',
  todayText: 'Dzisiaj',
  // Calendar component
  firstDay: 1,
  dateText: 'Data',
  timeText: 'Czas',
  closeText: 'Zakończenie',
  allDayText: 'Cały dzień',
  noEventsText: 'Brak wydarzeń',
  eventText: 'Wydarzeń',
  eventsText: 'Wydarzenia',
  moreEventsText: 'Jeszcze {count}',
  // Daterange component
  fromText: 'Rozpoczęcie',
  toText: 'Koniec',
  // Measurement components
  wholeText: 'Cały',
  fractionText: 'Ułamek',
  unitText: 'Jednostka',
  // Time / Timespan component
  labels: ['Lata', 'Miesiąc', 'Dni', 'Godziny', 'Minuty', 'Sekundy', ''],
  labelsShort: ['R', 'M', 'Dz', 'Godz', 'Min', 'Sek', ''],
  // Timer component
  startText: 'Rozpoczęcie',
  stopText: 'Zatrzymać',
  resetText: 'Zresetować',
  lapText: 'Zakładka',
  hideText: 'Ukryć',
  // Listview
  backText: 'Wróć',
  undoText: 'Cofnij',
  // Form
  offText: 'Wył',
  onText: 'Wł',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Português Brasileiro
mobiscroll.i18n['pt-BR'] = {
  // Core
  setText: 'Selecionar',
  cancelText: 'Cancelar',
  clearText: 'Claro',
  selectedText: '{count} selecionado',
  selectedPluralText: '{count} selecionados',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Domingo', 'Segunda-feira', 'Terça-feira', 'Quarta-feira', 'Quinta-feira', 'Sexta-feira', 'Sábado'],
  dayNamesShort: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb'],
  dayNamesMin: ['D', 'S', 'T', 'Q', 'Q', 'S', 'S'],
  dayText: 'Dia',
  hourText: 'Hora',
  minuteText: 'Minutos',
  monthNames: ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
  monthNamesShort: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
  monthText: 'Mês',
  secText: 'Segundo',
  timeFormat: 'HH:ii',
  yearText: 'Ano',
  nowText: 'Agora',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Hoje',
  // Calendar component
  dateText: 'Data',
  timeText: 'Tempo',
  closeText: 'Fechar',
  allDayText: 'Dia inteiro',
  noEventsText: 'Nenhum evento',
  eventText: 'Evento',
  eventsText: 'Eventos',
  moreEventsText: 'Mais {count}',
  // Daterange component
  fromText: 'In&iacute;cio',
  toText: 'Fim',
  // Measurement components
  wholeText: 'Inteiro',
  fractionText: 'Fração',
  unitText: 'Unidade',
  // Time / Timespan component
  labels: ['Anos', 'Meses', 'Dias', 'Horas', 'Minutos', 'Segundos', ''],
  labelsShort: ['Ano', 'M&ecirc;s', 'Dia', 'Hora', 'Min', 'Seg', ''],
  // Timer component
  startText: 'Começar',
  stopText: 'Pare',
  resetText: 'Reinicializar',
  lapText: 'Lap',
  hideText: 'Esconder',
  // Listview
  backText: 'Anterior',
  undoText: 'Desfazer',
  // Form
  offText: 'Desl',
  onText: 'Lig',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Português Europeu
mobiscroll.i18n['pt-PT'] = {
  // Core
  setText: 'Seleccionar',
  cancelText: 'Cancelar',
  clearText: 'Claro',
  selectedText: '{count} selecionado',
  selectedPluralText: '{count} selecionados',
  // Datetime component
  dateFormat: 'dd-mm-yy',
  dayNames: ['Domingo', 'Segunda-feira', 'Terça-feira', 'Quarta-feira', 'Quinta-feira', 'Sexta-feira', 'Sábado'],
  dayNamesShort: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb'],
  dayNamesMin: ['D', 'S', 'T', 'Q', 'Q', 'S', 'S'],
  dayText: 'Dia',
  hourText: 'Horas',
  minuteText: 'Minutos',
  monthNames: ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
  monthNamesShort: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
  monthText: 'Mês',
  secText: 'Segundo',
  timeFormat: 'HH:ii',
  yearText: 'Ano',
  nowText: 'Actualizar',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Hoy',
  // Calendar component
  firstDay: 1,
  dateText: 'Data',
  timeText: 'Tempo',
  closeText: 'Fechar',
  allDayText: 'Todo o dia',
  noEventsText: 'Nenhum evento',
  eventText: 'Evento',
  eventsText: 'Eventos',
  moreEventsText: 'mais {count}',
  // Daterange component
  fromText: 'Início',
  toText: 'Fim',
  // Measurement components
  wholeText: 'Inteiro',
  fractionText: 'Fracção',
  unitText: 'Unidade',
  // Time / Timespan component
  labels: ['Anos', 'Meses', 'Dias', 'Horas', 'Minutos', 'Segundos', ''],
  labelsShort: ['Ano', 'Mês', 'Dia', 'Hora', 'Min', 'Seg', ''],
  // Timer component
  startText: 'Começar',
  stopText: 'Parar',
  resetText: 'Reinicializar',
  lapText: 'Lap',
  hideText: 'Esconder',
  // Listview
  backText: 'Anterior',
  undoText: 'Anular',
  // Form
  offText: 'Desl',
  onText: 'Lig',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Română
mobiscroll.i18n.ro = {
  // Core
  setText: 'Setare',
  cancelText: 'Anulare',
  clearText: 'Ştergere',
  selectedText: '{count} selectat',
  selectedPluralText: '{count} selectate',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Duminică', 'Luni', 'Marți', 'Miercuri', 'Joi', 'Vineri', 'Sâmbătă'],
  dayNamesShort: ['Du', 'Lu', 'Ma', 'Mi', 'Jo', 'Vi', 'Sâ'],
  dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
  dayText: ' Ziua',
  delimiter: '.',
  hourText: ' Ore ',
  minuteText: 'Minute',
  monthNames: ['Ianuarie', 'Februarie', 'Martie', 'Aprilie', 'Mai', 'Iunie', 'Iulie', 'August', 'Septembrie', 'Octombrie', 'Noiembrie', 'Decembrie'],
  monthNamesShort: ['Ian.', 'Feb.', 'Mar.', 'Apr.', 'Mai', 'Iun.', 'Iul.', 'Aug.', 'Sept.', 'Oct.', 'Nov.', 'Dec.'],
  monthText: 'Luna',
  secText: 'Secunde',
  timeFormat: 'HH:ii',
  yearText: 'Anul',
  nowText: 'Acum',
  amText: 'am',
  pmText: 'pm',
  todayText: 'Astăzi',
  prevMonthText: 'Luna anterioară',
  nextMonthText: 'Luna următoare',
  prevYearText: 'Anul anterior',
  nextYearText: 'Anul următor',
  eventText: 'Eveniment',
  eventsText: 'Evenimente',
  allDayText: 'Toată ziua',
  noEventsText: 'Niciun eveniment',
  moreEventsText: 'Încă unul',
  moreEventsPluralText: 'Încă {count}',
  // Calendar component
  firstDay: 1,
  dateText: 'Data',
  timeText: 'Ora',
  closeText: 'Închidere',
  // Daterange component
  fromText: 'Start',
  toText: 'Final',
  // Measurement components
  wholeText: 'Complet',
  fractionText: 'Parţial',
  unitText: 'Unitate',
  // Time / Timespan component
  labels: ['Ani', 'Luni', 'Zile', 'Ore', 'Minute', 'Secunde', ''],
  labelsShort: ['Ani', 'Luni', 'Zile', 'Ore', 'Min.', 'Sec.', ''],
  // Timer component
  startText: 'Start',
  stopText: 'Stop',
  resetText: 'Resetare',
  lapText: 'Tură',
  hideText: 'Ascundere',
  // Listview
  backText: 'Înapoi',
  undoText: 'Anulează',
  // Form
  offText: 'Nu',
  onText: 'Da',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Русский (UA)
mobiscroll.i18n['ru-UA'] = {
  // Core
  setText: 'Установить',
  cancelText: 'Отменить',
  clearText: 'Очиститьr',
  selectedText: '{count} Вібрать',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['воскресенье', 'понедельник', 'вторник', 'среда', 'четверг', 'пятница', 'суббота'],
  dayNamesShort: ['вс', 'пн', 'вт', 'ср', 'чт', 'пт', 'сб'],
  dayNamesMin: ['в', 'п', 'в', 'с', 'ч', 'п', 'с'],
  dayText: 'День',
  delimiter: '.',
  hourText: 'Часы',
  minuteText: 'Минуты',
  monthNames: ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'],
  monthNamesShort: ['Янв.', 'Февр.', 'Март', 'Апр.', 'Май', 'Июнь', 'Июль', 'Авг.', 'Сент.', 'Окт.', 'Нояб.', 'Дек.'],
  monthText: 'Месяцы',
  secText: 'Сикунды',
  timeFormat: 'HH:ii',
  yearText: 'Год',
  nowText: 'Сейчас',
  amText: 'am',
  pmText: 'pm',
  todayText: 'Cегодня',
  // Calendar component
  firstDay: 1,
  dateText: 'Дата',
  timeText: 'Время',
  closeText: 'Закрыть',
  allDayText: 'Весь день',
  noEventsText: 'Нет событий',
  eventText: 'Мероприятия',
  eventsText: 'Мероприятия',
  moreEventsText: 'Ещё {count}',
  // Daterange component
  fromText: 'Начало',
  toText: 'Конец',
  // Measurement components
  wholeText: 'Весь',
  fractionText: 'Часть',
  unitText: 'Единица',
  // Time / Timespan component
  labels: ['Годы', ' Месяцы ', ' Дни ', ' Часы ', ' Минуты ', ' Секунды', ''],
  labelsShort: ['Год', 'Мес.', 'Дн.', 'Ч.', 'Мин.', 'Сек.', ''],
  // Timer component
  startText: 'Старт',
  stopText: 'Стоп',
  resetText: ' Сброс ',
  lapText: ' Этап ',
  hideText: ' Скрыть ',
  // Listview
  backText: 'назад',
  undoText: 'ОтменитЬ',
  // Form
  offText: 'O',
  onText: 'I',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Русский
mobiscroll.i18n['ru-RU'] = mobiscroll.i18n.ru = {
  // Core
  setText: 'Установить',
  cancelText: 'Отмена',
  clearText: 'Очистить',
  selectedText: '{count} Выбрать',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['воскресенье', 'понедельник', 'вторник', 'среда', 'четверг', 'пятница', 'суббота'],
  dayNamesShort: ['вс', 'пн', 'вт', 'ср', 'чт', 'пт', 'сб'],
  dayNamesMin: ['в', 'п', 'в', 'с', 'ч', 'п', 'с'],
  dayText: 'День',
  delimiter: '.',
  hourText: 'Час',
  minuteText: 'Минут',
  monthNames: ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'],
  monthNamesShort: ['Янв', 'Фев', 'Мар', 'Апр', 'Май', 'Июн', 'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'],
  monthText: 'Месяц',
  secText: 'Секунд',
  timeFormat: 'HH:ii',
  yearText: 'Год',
  nowText: 'Сейчас',
  amText: 'am',
  pmText: 'pm',
  todayText: 'Cегодня',
  // Calendar component
  firstDay: 1,
  dateText: 'Дата',
  timeText: 'Время',
  closeText: 'Закрыть',
  allDayText: 'Весь день',
  noEventsText: 'Нет событий',
  eventText: 'Мероприятия',
  eventsText: 'Мероприятия',
  moreEventsText: 'Ещё {count}',
  // Daterange component
  fromText: 'Начало',
  toText: 'Конец',
  // Measurement components
  wholeText: 'Целое',
  fractionText: 'Дробное',
  unitText: 'Единица',
  // Time / Timespan component
  labels: ['Лет', 'Месяцев', 'Дней', 'Часов', 'Минут', 'Секунд', ''],
  labelsShort: ['Лет', 'Мес', 'Дн', 'Час', 'Мин', 'Сек', ''],
  // Timer component
  startText: 'Старт',
  stopText: 'Стоп',
  resetText: 'Сбросить',
  lapText: 'Круг',
  hideText: 'Скрыть',
  // Listview
  backText: 'назад',
  undoText: 'ОтменитЬ',
  // Form
  offText: 'O',
  onText: 'I',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Slovencina
mobiscroll.i18n.sk = {
  // Core
  setText: 'Zadaj',
  cancelText: 'Zrušiť',
  clearText: 'Vymazať',
  selectedText: 'Označený: {count}',
  // Datetime component
  dateFormat: 'd.m.yy',
  dayNames: ['Nedeľa', 'Pondelok', 'Utorok', 'Streda', 'Štvrtok', 'Piatok', 'Sobota'],
  dayNamesShort: ['Ne', 'Po', 'Ut', 'St', 'Št', 'Pi', 'So'],
  dayNamesMin: ['N', 'P', 'U', 'S', 'Š', 'P', 'S'],
  dayText: 'Ďeň',
  hourText: 'Hodiny',
  minuteText: 'Minúty',
  monthNames: ['Január', 'Február', 'Marec', 'Apríl', 'Máj', 'Jún', 'Júl', 'August', 'September', 'Október', 'November', 'December'],
  monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Máj', 'Jún', 'Júl', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
  monthText: 'Mesiac',
  secText: 'Sekundy',
  timeFormat: 'H:ii',
  yearText: 'Rok',
  nowText: 'Teraz',
  amText: 'am',
  pmText: 'pm',
  todayText: 'Dnes',
  // Calendar component
  firstDay: 1,
  dateText: 'Datum',
  timeText: 'Čas',
  closeText: 'Zavrieť',
  allDayText: 'Celý deň',
  noEventsText: 'Žiadne udalosti',
  eventText: 'Udalostí',
  eventsText: 'Udalosti',
  moreEventsText: '{count} ďalšia',
  moreEventsPluralText: '{count} ďalšie',
  // Daterange component
  fromText: 'Začiatok',
  toText: 'Koniec',
  // Measurement components
  wholeText: 'Celý',
  fractionText: 'Časť',
  unitText: 'Jednotka',
  // Time / Timespan component
  labels: ['Roky', 'Mesiace', 'Dni', 'Hodiny', 'Minúty', 'Sekundy', ''],
  labelsShort: ['Rok', 'Mes', 'Dni', 'Hod', 'Min', 'Sec', ''],
  // Timer component
  startText: 'Start',
  stopText: 'Stop',
  resetText: 'Resetovať',
  lapText: 'Etapa',
  hideText: 'Schovať',
  // Listview
  backText: 'Späť',
  undoText: 'Späť',
  // Form
  offText: 'O',
  onText: 'I',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Serbian
mobiscroll.i18n.sr = {
  // Core
  setText: 'Постави',
  cancelText: 'Откажи',
  clearText: 'Обриши',
  selectedText: '{count} изабрана',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Недеља', 'Понедељак', 'Уторак', 'Среда', 'Четвртак', 'Петак', 'Субота'],
  dayNamesShort: ['Нед', 'Пон', 'Уто', 'Сре', 'Чет', 'Пет', 'Суб'],
  dayNamesMin: ['Не', 'По', 'Ут', 'Ср', 'Че', 'Пе', 'Су'],
  dayText: 'Дан',
  delimiter: '.',
  hourText: 'Час',
  minuteText: 'Минут',
  monthNames: ['Јануар', 'Фебруар', 'Март', 'Април', 'Мај', 'Јун', 'Јул', 'Август', 'Септембар', 'Октобар', 'Новембар', 'Децембар'],
  monthNamesShort: ['Јан', 'Феб', 'Мар', 'Апр', 'Мај', 'Јун', 'Јул', 'Авг', 'Сеп', 'Окт', 'Нов', 'Дец'],
  monthText: 'месец',
  secText: 'Секунд',
  timeFormat: 'H:ii',
  yearText: 'година',
  nowText: 'сада',
  pmText: 'pm',
  amText: 'am',
  // Calendar component
  firstDay: 1,
  dateText: 'Датум',
  timeText: 'време',
  todayText: 'Данас',
  prevMonthText: 'Претходни мјесец',
  nextMonthText: 'Следећег месеца',
  prevYearText: 'Претходна године',
  nextYearText: 'Следеће године',
  closeText: 'Затвори',
  eventText: 'Догађај',
  eventsText: 'Догађаји',
  allDayText: 'Цео дан',
  noEventsText: 'Нема догађаја',
  moreEventsText: 'Још {count}',
  // Daterange component
  fromText: 'Од',
  toText: 'До',
  // Measurement components
  wholeText: 'цео',
  fractionText: 'Фракција',
  unitText: 'единица',
  // Time / Timespan component
  labels: ['Године', 'Месеци', 'Дана', 'Сати', 'Минута', 'Секунди', ''],
  labelsShort: ['Год', 'Мес', 'Дана', 'Сати', 'Мину', 'Секу', ''],
  // Timer component
  startText: 'Започни',
  stopText: 'Стоп',
  resetText: 'Ресетуј',
  lapText: 'Круг',
  hideText: 'Сакрити',
  // Listview
  backText: 'Повратак',
  undoText: 'Опозови',
  // Form
  offText: 'нe',
  onText: 'да',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Svenska
mobiscroll.i18n.sv = {
  // Core
  setText: 'OK',
  cancelText: 'Avbryt',
  clearText: 'Klara',
  selectedText: '{count} vald',
  // Datetime component
  dateFormat: 'yy-mm-dd',
  dayNames: ['Söndag', 'Måndag', 'Tisdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lördag'],
  dayNamesShort: ['Sö', 'Må', 'Ti', 'On', 'To', 'Fr', 'Lö'],
  dayNamesMin: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
  dayText: 'Dag',
  hourText: 'Timme',
  minuteText: 'Minut',
  monthNames: ['Januari', 'Februari', 'Mars', 'April', 'Maj', 'Juni', 'Juli', 'Augusti', 'September', 'Oktober', 'November', 'December'],
  monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Maj', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
  monthText: 'Månad',
  secText: 'Sekund',
  timeFormat: 'HH:ii',
  yearText: 'År',
  nowText: 'Nu',
  pmText: 'pm',
  amText: 'am',
  todayText: 'I dag',
  // Calendar component
  firstDay: 1,
  dateText: 'Datum',
  timeText: 'Tid',
  closeText: 'Stäng',
  allDayText: 'Heldag',
  noEventsText: 'Inga aktiviteter',
  eventText: 'Händelse',
  eventsText: 'Händelser',
  moreEventsText: '{count} till',
  // Daterange component
  fromText: 'Start',
  toText: 'Slut',
  // Measurement components
  wholeText: 'Hela',
  fractionText: 'Bråk',
  unitText: 'Enhet',
  // Time / Timespan component
  labels: ['År', 'Månader', 'Dagar', 'Timmar', 'Minuter', 'Sekunder', ''],
  labelsShort: ['År', 'Mån', 'Dag', 'Tim', 'Min', 'Sek', ''],
  // Timer component
  startText: 'Start',
  stopText: 'Stopp',
  resetText: 'Återställ',
  lapText: 'Varv',
  hideText: 'Dölj',
  // Listview
  backText: 'Tillbaka',
  undoText: 'Ångra',
  // Form
  offText: 'Av',
  onText: 'På'
};

// Türkçe
mobiscroll.i18n.tr = {
  // Core
  setText: 'Seç',
  cancelText: 'İptal',
  clearText: 'Temizleyin',
  selectedText: '{count} seçilmiş',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Pazar', 'Pazartesi', 'Salı', 'Çarşamba', 'Perşembe', 'Cuma', 'Cumartesi'],
  dayNamesShort: ['Paz', 'Pzt', 'Sal', 'Çar', 'Per', 'Cum', 'Cmt'],
  dayNamesMin: ['P', 'P', 'S', 'Ç', 'P', 'C', 'C'],
  dayText: 'Gün',
  delimiter: '.',
  hourText: 'Saat',
  minuteText: 'Dakika',
  monthNames: ['Ocak', 'Şubat', 'Mart', 'Nisan', 'Mayıs', 'Haziran', 'Temmuz', 'Ağustos', 'Eylül', 'Ekim', 'Kasım', 'Aralık'],
  monthNamesShort: ['Oca', 'Şub', 'Mar', 'Nis', 'May', 'Haz', 'Tem', 'Ağu', 'Eyl', 'Eki', 'Kas', 'Ara'],
  monthText: 'Ay',
  secText: 'Saniye',
  timeFormat: 'HH:ii',
  yearText: 'Yıl',
  nowText: 'Şimdi',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Bugün',
  // Calendar component
  firstDay: 1,
  dateText: 'Tarih',
  timeText: 'Zaman',
  closeText: 'Kapatmak',
  allDayText: 'Tüm gün',
  noEventsText: 'Etkinlik Yok',
  eventText: 'Etkinlik',
  eventsText: 'Etkinlikler',
  moreEventsText: '{count} tane daha',
  // Daterange component
  fromText: 'Başla',
  toText: 'Son',
  // Measurement components
  wholeText: 'Tam',
  fractionText: 'Kesir',
  unitText: 'Birim',
  // Time / Timespan component
  labels: ['Yıl', 'Ay', 'Gün', 'Saat', 'Dakika', 'Saniye', ''],
  labelsShort: ['Yıl', 'Ay', 'Gün', 'Sa', 'Dak', 'Sn', ''],
  // Timer component
  startText: 'Başla',
  stopText: 'Durdur',
  resetText: 'Sıfırla',
  lapText: 'Tur',
  hideText: 'Gizle',
  // Listview
  backText: 'Geri',
  undoText: 'Geri Al',
  // Form
  offText: 'O',
  onText: 'I',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: '.'
};

// Vietnamese 
mobiscroll.i18n.vi = {
  // Core
  setText: 'Đặt',
  cancelText: 'Hủy bò',
  clearText: 'Xóa',
  selectedText: '{count} chọn',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Chủ Nhật', 'Thứ Hai', 'Thứ Ba', 'Thứ Tư', 'Thứ Năm', 'Thứ Sáu', 'Thứ Bảy'],
  dayNamesShort: ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'],
  dayNamesMin: ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'],
  dayText: '',
  delimiter: '/',
  hourText: 'Giờ',
  minuteText: 'Phút',
  monthNames: ['Tháng Một', 'Tháng Hai', 'Tháng Ba', 'Tháng Tư', 'Tháng Năm', 'Tháng Sáu', 'Tháng Bảy', 'Tháng Tám', 'Tháng Chín', 'Tháng Mười', 'Tháng Mười Một', 'Tháng Mười Hai'],
  monthNamesShort: ['Tháng 1', 'Tháng 2', 'Tháng 3', 'Tháng 4', 'Tháng 5', 'Tháng 6', 'Tháng 7', 'Tháng 8', 'Tháng 9', 'Tháng 10', 'Tháng 11', 'Tháng 12'],
  monthText: 'Tháng',
  secText: 'Giây',
  timeFormat: 'H:ii',
  yearText: 'Năm',
  nowText: 'Bây giờ',
  pmText: 'pm',
  amText: 'am',
  // Calendar component
  firstDay: 0,
  dateText: 'Ngày',
  timeText: 'Hồi',
  todayText: 'Hôm nay',
  prevMonthText: 'Tháng trước',
  nextMonthText: 'Tháng tới',
  prevYearText: 'Măm trước',
  nextYearText: 'Năm tới',
  closeText: 'Đóng',
  eventText: 'Sự kiện',
  eventsText: 'Sự kiện',
  allDayText: 'Cả ngày',
  noEventsText: 'Không có sự kiện',
  moreEventsText: '{count} thẻ khác',
  // Daterange component
  fromText: 'Từ',
  toText: 'Tới',
  // Measurement components
  wholeText: 'Toàn thể',
  fractionText: 'Phân số',
  unitText: 'đơn vị',
  // Time / Timespan component
  labels: ['Năm', 'Tháng', 'Ngày', 'Giờ', 'Phút', 'Giây', ''],
  labelsShort: ['Năm', 'Tháng', 'Ngày', 'Giờ', 'Phút', 'Giây', ''],
  // Timer component
  startText: 'Bắt đầu',
  stopText: 'Dừng',
  resetText: 'Đặt lại',
  lapText: 'Vòng',
  hideText: 'Giấu',
  // Listview
  backText: 'Quay lại',
  undoText: 'Hoàn tác',
  // Form
  offText: 'Tất',
  onText: 'Bật',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Chinese
mobiscroll.i18n.zh = {
  // Core
  setText: '确定',
  cancelText: '取消',
  clearText: '明确',
  selectedText: '{count} 选',
  // Datetime component
  dateFormat: 'yy年mm月d日',
  dayNames: ['周日', '周一', '周二', '周三', '周四', '周五', '周六'],
  dayNamesShort: ['日', '一', '二', '三', '四', '五', '六'],
  dayNamesMin: ['日', '一', '二', '三', '四', '五', '六'],
  dayText: '日',
  hourText: '时',
  minuteText: '分',
  monthNames: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
  monthNamesShort: ['一', '二', '三', '四', '五', '六', '七', '八', '九', '十', '十一', '十二'],
  monthText: '月',
  secText: '秒',
  timeFormat: 'HH:ii',
  yearText: '年',
  nowText: '当前',
  pmText: '下午',
  amText: '上午',
  yearSuffix: '年',
  monthSuffix: '月',
  daySuffix: '日',
  todayText: '今天',
  // Calendar component
  dateText: '日',
  timeText: '时间',
  closeText: '关闭',
  allDayText: '全天',
  noEventsText: '无事件',
  eventText: '活动',
  eventsText: '活动',
  moreEventsText: '他 {count} 件',
  // Daterange component
  fromText: '开始时间',
  toText: '结束时间',
  // Measurement components
  wholeText: '合计',
  fractionText: '分数',
  unitText: '单位',
  // Time / Timespan component
  labels: ['年', '月', '日', '小时', '分钟', '秒', ''],
  labelsShort: ['年', '月', '日', '点', '分', '秒', ''],
  // Timer component
  startText: '开始',
  stopText: '停止',
  resetText: '重置',
  lapText: '圈',
  hideText: '隐藏',
  // Listview
  backText: '返回',
  undoText: '复原',
  // Form
  offText: '关闭',
  onText: '开启',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

var themes$1 = mobiscroll.themes;
themes$1.frame.ios = {
  display: 'bottom',
  // frame
  headerText: false,
  // frame
  btnWidth: false,
  // frame
  deleteIcon: 'ios-backspace',
  // numpad
  scroll3d: os != 'wp' && (os != 'android' || majorVersion > 7)
};
themes$1.scroller.ios = extend$1({}, themes$1.frame.ios, {
  rows: 5,
  // scroller
  height: 34,
  // scroller
  minWidth: 55,
  // scroller
  selectedLineHeight: true,
  // scroller
  selectedLineBorder: 1,
  // scroller
  showLabel: false,
  // scroller
  useShortLabels: true,
  // timespan/timer
  btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
  // scroller
  btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',
  // scroller
  checkIcon: 'ion-ios7-checkmark-empty',
  // select
  filterClearIcon: 'ion-close-circled',
  // select
  dateDisplay: 'MMdyy',
  // date
  btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
  // calendar
  btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5' // calendar

});
themes$1.listview.ios = {
  leftArrowClass: 'mbsc-ic-ion-ios7-arrow-back',
  rightArrowClass: 'mbsc-ic-ion-ios7-arrow-forward'
};
themes$1.form.ios = {};

function _addRipple($control, ev) {
  var x = getCoord(ev, 'X', true),
      y = getCoord(ev, 'Y', true),
      control = $control[0],
      rect = $control.offset(),
      left = x - rect.left,
      top = y - rect.top,
      width = Math.max(left, control.offsetWidth - left),
      height = Math.max(top, control.offsetHeight - top),
      size = 2 * Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));

  _removeRipple($ripple);

  $ripple = $$1('<span class="mbsc-ripple"></span>').css({
    backgroundColor: getComputedStyle(control).color,
    width: size,
    height: size,
    top: y - rect.top - size / 2,
    left: x - rect.left - size / 2
  }).appendTo($control);
  setTimeout(function () {
    $ripple.addClass('mbsc-ripple-scaled mbsc-ripple-visible');
  }, 10);
}

function _removeRipple($r) {
  setTimeout(function () {
    if ($r) {
      $r.removeClass('mbsc-ripple-visible');
      setTimeout(function () {
        $r.remove();
      }, 2000);
    }
  }, 100);
}

function initRipple($markup, selector, disabled, nohl) {
  var startX,
      startY,
      markup = $markup[0];

  function onStart(ev) {
    var target = closest(markup, ev.target, selector);

    if (target && testTouch(ev, target)) {
      startX = getCoord(ev, 'X');
      startY = getCoord(ev, 'Y');
      $active$1 = $$1(target);

      if (!$active$1.hasClass(disabled) && !$active$1.hasClass(nohl)) {
        _addRipple($active$1, ev);
      } else {
        $active$1 = null;
      }
    }
  }

  function onMove(ev) {
    if ($active$1 && Math.abs(getCoord(ev, 'X') - startX) > 9 || Math.abs(getCoord(ev, 'Y') - startY) > 9) {
      _removeRipple($ripple);

      $active$1 = null;
    }
  }

  function onEnd() {
    if ($active$1) {
      setTimeout(function () {
        _removeRipple($ripple);
      }, 100);
      $active$1 = null;
    }
  }

  if (markup) {
    if (markup.__mbscRippleOff) {
      markup.__mbscRippleOff();
    }

    listen(markup, 'touchstart', onStart, {
      passive: true
    });
    listen(markup, 'mousedown', onStart);
    listen(markup, 'touchmove', onMove, {
      passive: true
    });
    listen(markup, 'mousemove', onMove);
    listen(markup, 'touchend', onEnd);
    listen(markup, 'touchcancel', onEnd);
    listen(markup, 'mouseleave', onEnd);
    listen(markup, 'mouseup', onEnd);

    markup.__mbscRippleOff = function () {
      unlisten(markup, 'touchstart', onStart, {
        passive: true
      });
      unlisten(markup, 'mousedown', onStart);
      unlisten(markup, 'touchmove', onMove, {
        passive: true
      });
      unlisten(markup, 'mousemove', onMove);
      unlisten(markup, 'touchend', onEnd);
      unlisten(markup, 'touchcancel', onEnd);
      unlisten(markup, 'mouseleave', onEnd);
      unlisten(markup, 'mouseup', onEnd);
      delete markup.__mbscRippleOff;
    };
  }
}

var $active$1,
    $ripple,
    themes$2 = mobiscroll.themes;
themes$2.frame.material = {
  headerText: false,
  btnWidth: false,
  deleteIcon: 'material-backspace',
  onMarkupReady: function onMarkupReady(ev) {
    initRipple($$1(ev.target), '.mbsc-fr-btn-e', 'mbsc-disabled', 'mbsc-fr-btn-nhl');
  }
};
themes$2.scroller.material = extend$1({}, themes$2.frame.material, {
  showLabel: false,
  selectedLineBorder: 2,
  weekDays: 'min',
  icon: {
    filled: 'material-star',
    empty: 'material-star-outline'
  },
  checkIcon: 'material-check',
  btnPlusClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-down',
  btnMinusClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-up',
  btnCalPrevClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-left',
  btnCalNextClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-right'
});
themes$2.listview.material = {
  leftArrowClass: 'mbsc-ic-material-keyboard-arrow-left',
  rightArrowClass: 'mbsc-ic-material-keyboard-arrow-right',
  onItemActivate: function onItemActivate(ev) {
    _addRipple($$1(ev.target), ev.domEvent);
  },
  onItemDeactivate: function onItemDeactivate() {
    _removeRipple($ripple);
  },
  onSlideStart: function onSlideStart(ev) {
    $$1('.mbsc-ripple', ev.target).remove();
  },
  onSortStart: function onSortStart(ev) {
    $$1('.mbsc-ripple', ev.target).remove();
  }
};
themes$2.navigation.material = {
  onInit: function onInit() {
    initRipple($$1(this), '.mbsc-ms-item.mbsc-btn-e', 'mbsc-disabled', 'mbsc-btn-nhl');
  },
  onMarkupInit: function onMarkupInit() {
    $$1('.mbsc-ripple', this).remove();
  },
  onDestroy: function onDestroy() {
    if (this.__mbscRippleOff) {
      this.__mbscRippleOff();
    }
  }
};
themes$2.form.material = {
  addRipple: function addRipple(elm, ev) {
    _addRipple(elm, ev);
  },
  removeRipple: function removeRipple() {
    _removeRipple($ripple);
  }
};

var themes$3 = mobiscroll.themes;
themes$3.frame.windows = {
  headerText: false,
  deleteIcon: 'backspace4',
  //setIcon: 'material-check',
  //cancelIcon: 'material-close',
  //closeIcon: 'material-close',
  //clearIcon: 'material-close',
  //okIcon: 'material-check',
  //nowIcon: 'loop2',
  //startIcon: 'play3',
  //stopIcon: 'pause2',
  //resetIcon: 'stop2',
  //lapIcon: 'loop2',
  //btnWidth: false,
  btnReverse: true
};
themes$3.scroller.windows = extend$1({}, themes$3.frame.windows, {
  rows: 6,
  // scroller
  minWidth: 88,
  height: 44,
  btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
  btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',
  checkIcon: 'material-check',
  dateDisplay: 'MMdyy',
  // date
  showLabel: false,
  showScrollArrows: true,
  btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
  // calendar
  btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5',
  // calendar
  dayNamesShort: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  useShortLabels: true // timespan/timer

});
themes$3.form.windows = {};

mobiscroll.customTheme('ios-dark', 'ios');

mobiscroll.customTheme('material-dark', 'material');

mobiscroll.customTheme('mobiscroll-dark', 'mobiscroll');

mobiscroll.customTheme('windows-dark', 'windows');

var themes$4 = mobiscroll.themes;
var theme = 'mobiscroll';

if (os == 'android') {
  theme = 'material';
} else if (os == 'ios') {
  theme = 'ios';
} else if (os == 'wp') {
  theme = 'windows';
}

$$1.each(themes$4.frame, function (key, settings) {
  // Stop at the first custom theme with the OS base theme
  if (theme && settings.baseTheme == theme && key != theme + '-dark') {
    mobiscroll.autoTheme = key;
    return false;
  } else if (key == theme) {
    mobiscroll.autoTheme = key;
  }
});

export { MbscAvatar, MbscButton, MbscCheckbox, MbscCommercialComponent, MbscDropdown, MbscForm, MbscFormsModule, MbscInput, MbscInputModule, MbscModule, MbscNote, MbscPage, MbscPageModule, MbscProgress, MbscRadio, MbscRadioGroup, MbscRating, MbscSegmented, MbscSegmentedGroup, MbscSlider, MbscStepper, MbscSwitch, MbscTextarea, mobiscroll, MbscOptionsService as ɵa, MbscInputService as ɵb, MbscBase as ɵc, MbscValueBase as ɵd, MbscCloneBase as ɵe, MbscControlBase as ɵf, MbscBaseModule as ɵg, MbscFormBase as ɵh, MbscFormValueBase as ɵi, MbscInputBase as ɵj, MbscRadioService as ɵk, MbscRadioGroupBase as ɵl, MbscFormGroup as ɵm, MbscFormGroupTitle as ɵn, MbscFormGroupContent as ɵo, MbscAccordion as ɵp };
